<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h2 id="opengl">OpenGL</h2><p>OpenGL is a rendering API which draws things on the screen. This API is usually implemented by the hardware driver, so the implementation depends on the GPU.</p><p><br></p><p>In order to rasterize (convert to pixels) a triangle, we use the following information:</p><ul><li>Triangles are just 3 connected vertices. Changing a vertex gives us a new triangle</li><li>We keep a list of vertices (which are lists of coordinates) and triangles (which are lists of vertices). OpenGL stores almost everything as buffer objects (arrays)</li></ul><p><br></p><p>So our graphics pipeline becomes:</p><ol><li>Input is buffer of vertices</li><li>Transform vertices (multiply them by a projection matrix)</li><li>Another input is buffer of triangles, connections between the vertices, connect them</li><li>Rasterize into fragments (not pixels). You get fragments for each triangle, so there are no pixels yet as they have to be "merged"</li><li>Interpolation, color the pixels</li></ol><p><br></p><p>How we color the fragments depends on the depth of the objects, there are a few options (given an orange and blue triangle):</p><ol><li>Orange / blue triangle is nearer to the camera, use depth test to decide</li><li>Average the color of the fragments</li></ol><p><br></p><h2 id="glsl-shaders">GLSL Shaders</h2><p>Shaders are programs that run in the GPU:</p><ul><li>on specific points int he graphics pipeline</li><li>initially designed for shading (rendering)</li><li>now much more versatile</li><li>they are very parallelizable, so the GPU can run thousands of tasks simultaneously </li></ul><p><br></p><p>This is what the pipeline looks like with shaders:</p><p><img src="https://i.imgur.com/WNUlQ9E.png" width="529"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><h3 id="vertex-shader">Vertex shader</h3><p>For each vertex it will perform calculations to transform the vertex and returns the transformed vertex.</p><ul><li>Vertex attributes: something that varies per vertex, e.g. coordinates</li><li>Uniform variables: something that is constant per vertex, e.g. projection matrix</li></ul><p><br></p><h3 id="fragment-shader">Fragment shader</h3><p>For each fragment that has been calculated in the previous steps, do something. This is often coloring of the fragments.</p><p><br></p><h2 id="tucano-framework">Tucano framework</h2><p>For the assignments we will be using the Tucano framework, which is written to make it easier to use OpenGL.</p><p><br></p><p>The basic structure of the program will be:</p><ul><li><em>main.cpp: </em>initializations, callbacks, main display loop</li><li><em>widget.*pp: </em>define camera and create geometry</li><li><em>helloworld.cpp: </em>initialize shader render function</li></ul><p><br></p><h3 id="camera">Camera</h3><p>For the camera you define the following properties:</p><ul><li>The perspective matrix - field of view (angle of camera), ratio for <span class="ql-formula" data-value="y">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">y</span></span></span></span></span>﻿</span>, parameter to define "near plane" and "far plane"</li><li>The viewport - the size and location of the viewport (a part of the window)</li><li>The view matrix - a translation of the camera</li></ul><p><br></p><h3 id="triangles">Triangles</h3><p>You can create triangles by making a vector of vertices and indexes, and loading them into a buffer</p><p><br></p><h3 id="rendering">Rendering</h3><p>Here you set the shaders which will be used in order to create the image. These shaders are written in GLSL, in which you have the following keywords:</p><ul><li><em>in, </em>input from the C++ side, different for each fragment</li><li><em>out: </em>output to the fragment shader for the vertex shader and actual output for the fragment shader</li><li><em>uniform: </em>input from C++, same for each fragment</li></ul><p><br></p><p>For the vertex shader we multiply the projection, view (note that we move the vertices and not the camera) and model matrices with the coordinates. We can use this to place the camera in the scene. Separation of view and model matrices is just a design choice.</p><p><br></p><p>Example code for a vertex shader:</p><div style="white-space: normal;" class="markdown-body"><pre data-lang="text/x-c++src"><code>#version 430
<p>// incoming position from the mesh properties
in vec4 in_Position;</p>
<p>uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;</p>
<p>void main(void) {
vec4 transformed_vertex = projectionMatrix * viewMatrix * projectionMatrix * in_Position;
gl_Position = transformed_vertex 
}
</code></pre></p>
</div><p><br></p><p><strong>View matrix</strong></p><p>We are not actually transforming the camera, we are transforming everything else. Thus we should actually inverse the view matrix.</p><p><br></p><p><img src="https://i.imgur.com/lxL3LT6.png" width="493"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><h3 id="interpolation">Interpolation</h3><p>We can assign a color to each vertex, and interpolate the color for all pixels based on that. We do this by passing the color from the vertex shader to the fragment shader:</p><p><img src="https://i.imgur.com/9qFxcZX.png" width="234"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><p><strong>Barycentric coordinates</strong></p><p>We need to find a way how to interpolate colors. Given values at the vertices, find value at <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span>. For this, we can use barycentric coordinates.</p><p><br></p><p>We can calculate the area of each of the 3 colored triangles, and their area will sum up to 1. The bigger the area, the more of the color the point will have:</p><ul><li><span class="ql-formula" data-value="p=\alpha v_0+\beta v_1+\gamma v_2">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mi>α</mi><msub><mi>v</mi><mn>0</mn></msub><mo>+</mo><mi>β</mi><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><mi>γ</mi><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p=\alpha v_0+\beta v_1+\gamma v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.73333em; vertical-align: -0.15em;"></span><span style="margin-right: 0.0037em;" class="mord mathdefault">α</span><span class="mord"><span style="margin-right: 0.03588em;" class="mord mathdefault">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05278em;" class="mord mathdefault">β</span><span class="mord"><span style="margin-right: 0.03588em;" class="mord mathdefault">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05556em;" class="mord mathdefault">γ</span><span class="mord"><span style="margin-right: 0.03588em;" class="mord mathdefault">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> </li><li><span class="ql-formula" data-value="\alpha+\beta+\gamma=1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>+</mo><mi>β</mi><mo>+</mo><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha+\beta+\gamma=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.0037em;" class="mord mathdefault">α</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05278em;" class="mord mathdefault">β</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05556em;" class="mord mathdefault">γ</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> </li><li><span class="ql-formula" data-value="\alpha,\beta,\gamma\ge0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>γ</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\alpha,\beta,\gamma\ge0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.0037em;" class="mord mathdefault">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.05278em;" class="mord mathdefault">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.05556em;" class="mord mathdefault">γ</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span></li></ul><p><img src="https://i.imgur.com/I8qDMUA.png" width="519"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><h3 id="perspective-correct-interpolation">Perspective correct interpolation</h3><p>Because in perspective projection, things that are further away are smaller, this will ruin our interpolation. You can see how the lengths of the pieces don’t match the lengths on the screen.</p><p><img src="https://i.imgur.com/oVmguyg.png" width="366"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><p>Fortunately, the solution is not hard. We adjust the formula for finding the <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span>:</p><p><img src="https://i.imgur.com/uSxiUcd.png" width="373"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p>
  </section>

    </section>
  </div>
</body>

</html>