<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h1 id="shading">Shading</h1><p>Given point properties (position, normal and other attributes), how do we compute a realistic color?</p><p><br></p><h2 id="light">Light</h2><p>As described in the first lecture, light bounces off objects in certain directions, depending on the material. These reflections look somewhat like this:</p><p><br></p><p><img src="https://i.imgur.com/etWAnY3.png" width="287"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><p>We could make actual measurements for each texture in the world, but then you'd need a lot of measurements, each of which are very expensive. So we want to mathematically describe material properties.</p><p><br></p><h2 id="phong-model">Phong model</h2><p>A phong model is a popular way of describing material properties. It is a sum of 3 terms:</p><ul><li>Ambient - flat</li><li>Diffuse - reflected light in all directions</li><li>Specular - highlights, strong reflections in a certain direction</li></ul><p><br></p><p><img src="https://i.imgur.com/DgC0RkE.png" width="410"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><h3 id="ambient">Ambient</h3><p>The ambient term is supposed to mimic the "scene light":  sky, diffusion from nearby surfaces etc.</p><p><br></p><p>The model is very simple: <span class="ql-formula" data-value="A=I_aK_a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><msub><mi>I</mi><mi>a</mi></msub><msub><mi>K</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">A=I_aK_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.07847em;" class="mord mathdefault">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span>, where (note that this is multiplied for each RGB color channel independently!)</p><ul><li><span class="ql-formula" data-value="I_a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">I_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.07847em;" class="mord mathdefault">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> is the light property (the color of light shining on the surface)</li><li><span class="ql-formula" data-value="K_a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">K_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> is the surface property (the color of light reflected by the surface)</li></ul><p><br></p><p>These values are typically between <span class="ql-formula" data-value="\left[0,1\right]">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[0,1\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top: 0em;">]</span></span></span></span></span></span>﻿</span></p><p><br></p><p>This ambient term is very simplistic, with no real physical basis and no indications on the shape of an object.</p><p><br></p><h3 id="diffuse">Diffuse</h3><p>In diffuse surfaces, light is reflected uniformly in all directions.</p><p><br></p><p>The model is <span class="ql-formula" data-value="D=I_dK_d\cos\theta">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><msub><mi>I</mi><mi>d</mi></msub><msub><mi>K</mi><mi>d</mi></msub><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">D=I_dK_d\cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.07847em;" class="mord mathdefault">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.33610799999999996em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.33610799999999996em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">θ</span></span></span></span></span>﻿</span>, where</p><ul><li><span class="ql-formula" data-value="I_d">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">I_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.07847em;" class="mord mathdefault">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.33610799999999996em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="K_d">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">K_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.33610799999999996em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> are the same as with ambient lighting</li><li><span class="ql-formula" data-value="\theta">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">θ</span></span></span></span></span>﻿</span> is the angle of the light from the normal vector (the angle of the incoming light). This term accounts for light shining on a larger surface when the angle of the light is large, thus the light density being smaller.</li></ul><p><br></p><p><img src="https://i.imgur.com/5AzufD8.png" width="411"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><p>Some notions:</p><ul><li>Shading varies along surface</li><li>Diffuse lighting doesn't depend on the observer position</li><li>The light source should be above the point, otherwise no light can reach it</li></ul><p><br></p><h3 id="specular">Specular</h3><p>This represents reflection from glossy / mirror surfaces.&nbsp;</p><p><br></p><p>The model assumes that light is mostly reflected around the mirrored ray.</p><p><br></p><p>The model is <span class="ql-formula" data-value="S=I_sK_s\left(\cos\phi\right)^n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><msub><mi>I</mi><mi>s</mi></msub><msub><mi>K</mi><mi>s</mi></msub><msup><mrow><mo fence="true">(</mo><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mo fence="true">)</mo></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">S=I_sK_s\left(\cos\phi\right)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1.054292em; vertical-align: -0.25em;"></span><span class="mord"><span style="margin-right: 0.07847em;" class="mord mathdefault">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mop">cos</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord mathdefault">ϕ</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>﻿</span>, where</p><ul><li><span class="ql-formula" data-value="I_s">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">I_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.07847em;" class="mord mathdefault">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="K_s">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.07153em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> are the same as with ambient lighting</li><li><span class="ql-formula" data-value="\phi">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span></span>﻿</span> is the direction to the camera</li><li><span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> is the shininess</li></ul><p><br></p><p><img src="https://i.imgur.com/2Ut0h83.png" width="183"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><h2 id="interesting-shader-things">Interesting shader things</h2><h3 id="non-photorealistic-materials">Non-photorealistic materials</h3><p>Using cel-shading we can also create non-photorealistic materials by putting a threshold on the diffuse shading</p><p><img src="https://i.imgur.com/cGIXeU9.png" width="310"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><h3 id="in-practice">In practice</h3><p>For all stages, we apply a Phong model to produce a color. But:</p><ul><li>In early days: compute color per face - produces "facets"</li><li>Later: compute color per vertex (<strong>Gouraud shading</strong>) - produces a smooth look by interpolating color from vertices over a triangle</li><li>Today: compute result per pixel (<strong>Phong shading</strong>, not Phong model) - produces smooth specularities by interpolating parameters of the Phong model</li></ul><p><br></p><h1 id="textures">Textures</h1><p>Something is still missing: we would like to add some textures to our boring surfaces, because we can't quickly change materials to a different color, which is very costly. </p><p><br></p><p>We can add textures by mapping an image onto the surface. Plainly said: take an image and put it onto our model. For this, we need to specify the coordinates of each vertex on the image. We should make sure that the image we are using is of a good enough quality.</p><p><br></p><p>For example:</p><p><img src="https://i.imgur.com/ODCcpLL.png" width="527"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><p>We can even store more in textures:</p><ul><li><strong>Normal mapping: </strong>we can change the normal direction at different places on a surface, which creates 'fake' bumps on our surface, very cheaply.&nbsp;</li><li><strong>Light mapping: </strong>we can pre-compute illumination, as long as our environment is static. This will take a long time when the illumination is computed, but can drastically speed up the rendering.</li></ul><p><br></p><p>It is also possible to merge multiple textures:</p><p><img src="https://i.imgur.com/N5WvBWJ.png" width="426"></p><p>Here:</p><ul><li><strong>Ambient occlusion</strong> are precalculated light values for things where there is not much light</li><li><strong>Roughness </strong>is the shininess, where you are going to have more reflection</li><li><strong>Albedo </strong>is the diffuse</li><li><strong>Thickness </strong>simulates how much skin is underneath that position</li><li><strong>Normals </strong>has some height mapping, so the geometry can be simpler </li></ul><p><br></p><p>But there are some issues with textures: they don't always look beautiful because of aliasing: there is no 1 to 1 mapping from screen to texture</p><p><br></p><h3 id="oversampling">Oversampling</h3><p>It could be that there are too few pixels in your texture (<strong>oversampling</strong>). If you zoom in, the image will look bad. </p><p><br></p><p>The pixels from your texture could blow up (pixels in texture = <strong>texel</strong>), but often texture interpolation is used, to "merge" the pixels in your texture. </p><p><br></p><p>This can be decided by using the color of the neighbor, but that gives very blocky corners. We can also use linear interpolation between two texels in order to create a high resolution transition between two texels. For 2D, we first apply horizontal interpolation and then vertical interpolation (bilinear interpolation)</p><p><br></p><h3 id="undersampling">Undersampling</h3><p>Too many pixels in your texture (<strong>undersampling</strong>). Which texel to map to the screen almost becomes arbitrary:</p><p><img src="https://i.imgur.com/xme7Z3d.png" width="456"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><p>On the left you can see the original render, on the right you see the averaged pixels. You get rid of the noise, but this approach is very, very expensive because for every pixel, you have to look up all the texels that are covered by that pixel. </p><p><br></p><p>An improvement of this is MipMapping:</p><ul><li>Start with your original image</li><li>Create an hierarchy, where in each step, the resolution is lowered by a factor 2 until you reach a 1x1 image</li><li>If you need a 4x4 pixel representation of your model, just use that map instead of calculating it entirely</li></ul><p><br></p><p>If you switch from one MipMap level to another, you should do linear interpolation between the two levels, called TriLinear Filtering. With Anisotropic Filtering it can become even better.</p><p><br></p><h1 id="shadows">Shadows</h1><p>A shadow can be defined as the region of space for which at least one point of the light source is occluded.</p><p><br></p><p>If we define our image into three parts: the <em>lit</em> part, the <em>umbra </em>part (where there is no light) and the <em>penumbra </em>part (where is there is little light), we get the following image:</p><p><img src="https://i.imgur.com/1ahN54g.png" width="510"></p><p><br></p><p>According to the previous definition, the shadow would be both the umbra and penumbra, because in both cases the complete light sources is not visible.</p><p><br></p><p>But, drawing correct shadows is quite hard to do. We often go for drawing "plausible" shadows, which are correct enough. But how do we determine if there is a shadow somewhere?</p><p><br></p><h3 id="calculating-shadows">Calculating shadows</h3><p>First off, keep in mind that a light source is often not just coming from 1 place. If that were true, all shadows would have very sharp edges. Instead, there are often many light sources shining simultaneously. </p><p><br></p><div style="white-space: normal;" class="markdown-body"><p>But first for the single light source option: take a light source <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> that is emitting light, defined by the function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span>. This light is emitted towards point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>. Then the we define a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Transfer</mtext><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Transfer}(P,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Transfer</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> function which transfers light from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> to eye <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>.</p>
</div><p><br></p><div style="white-space: normal;" class="markdown-body"><p>If there is an object in the middle which is blocking the light, we use a visibility function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v(P,L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span>. This is a binary function, it returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> if the light towards <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> is blocked and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> if the light is not blocked.</p>
</div><p><br></p><div style="white-space: normal;" class="markdown-body"><p>But as said previously, light exists of many light sources, so we integrate over all these light sources: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mtext>Light</mtext></msub><mi>E</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo><mi>v</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>L</mi><mo stretchy="false">)</mo><mtext>Transfer</mtext><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo><mi>d</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">B(P)=\int_\text{Light}E(L)v(P,L)\text{Transfer}(P,E)dL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.296928em;vertical-align:-0.49192800000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.13028799999999985em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">Light</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49192800000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mord text"><span class="mord">Transfer</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span></span></span></span></p>
</div><p><br></p><p>This technique is physically correct enough, robust and easy to implement. But this is very slow to implement for every pixel: for every pixel we create a view of the light source and count the amount of pixels which you can see of the light source and determine shadow level based on that.</p><p><br></p><h3 id="shadow-sampling">Shadow sampling</h3><p>Now let's improve this technique (for a single light source). Keep in mind that for each pixel we keep a depth value and a color value and the GPU changes these values based on the current triangle (which is all it knows of). But for shadows, knowledge of a single triangle is not enough.</p><p><br></p><p>A solution to this is rendering an image from the light source and store this result in a texture (<strong>shadow map</strong>). Then render from the viewpoint and for each drawn pixel:</p><ul><li>Compare its distance to the corresponding distance in the shadow map</li><li>If equal: pixel is lit</li><li>If farther: pixel is in shadow</li></ul><p><br></p><p>In other words: using triangle coordinates and depth values we can determine which points are visible for the light source. If the light source cannot see the triangle but the eye can, it will be in shadow.</p><p><br></p><p><strong>Problem 1</strong></p><p>The problem of this is that you create images and compare pixel values. This means that rasterization has already taken place, and thus the resolution is limited and you can see the square pixels in shadows.</p><p><br></p><p><strong>Problem 2</strong></p><p>In our algorithm, we compare if pixel distances are equal, but this checks for equality of floating points. But we have limited precision available, so this means that for some pixels, this will work and for others it won't. In the following image you can see an example of how that works (the red stripes are the depth values from the shadow map):</p><p><img src="https://i.imgur.com/P6L4Scd.png" width="302"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><p>This means that you could get shadows cast on the object itself. The solution to this is by pushing the depth values of the shadows a bit to the back, so that the pixels aren't in shadow anymore, but not too much:</p><p><img src="https://i.imgur.com/aBKLRgQ.png" width="334"></p><p><em>Image taken from slides by Elmar Eisemann</em></p><p><br></p><p><strong>Problem 3</strong></p><p>Another problem is oversampling of the shadows map and undersampling of the screen: you have very fine structures that cast shadows, which on zooming in leads to noise.</p><p><br></p>
  </section>

    </section>
  </div>
</body>

</html>