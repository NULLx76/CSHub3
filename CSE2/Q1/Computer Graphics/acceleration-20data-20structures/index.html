<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h2 id="2d-points">2D Points</h2><p>Note that all these structures have a 3D counterpart.</p><p><br></p><h3 id="in-an-array">In an array</h3><p>Getting a certain point is <span class="ql-formula" data-value="O\left(1\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mn>1</mn><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(1\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord">1</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>, finding points that are close to another point is <span class="ql-formula" data-value="O\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> </p><p><br></p><h3 id="in-a-regular-grid">In a regular grid</h3><p>Finding points near other points must be better than <span class="ql-formula" data-value="O\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>. For that we can use a grid, which we split in cells and put all points in the corresponding cell. Each cell stores a linked list of <span class="ql-formula" data-value="m">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>﻿</span> points.</p><p><br></p><p>Getting a certain point is <span class="ql-formula" data-value="O\left(n+m\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(n+m\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>, <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> for the amount of points and <span class="ql-formula" data-value="m">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>﻿</span> is the amount of cells. Note that this is worst case scenario, in reality this is much better as our radius won't be the entire grid. </p><p><br></p><h3 id="combined">Combined</h3><p>Now let's combine these two: for each element in a cell we point to the array element. Then we can get a single point in <span class="ql-formula" data-value="O\left(1\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mn>1</mn><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(1\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord">1</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> and finding points that are close is still <span class="ql-formula" data-value="O\left(n+m\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(n+m\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>, but a better <span class="ql-formula" data-value="O\left(n+m\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(n+m\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> because not everything will be in one cell / your radius will be small.</p><p><br></p><p>Another question we can ask is can we detect collisions between two moving points, in a better way than <span class="ql-formula" data-value="O\left(n^2\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(n^2\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141079999999999em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></span>﻿</span>? We can with grids assuming that points do not move too fast. You for example know that two points that are not in the same cell won't collide.</p><p><br></p><p>But this grid has a few downsides:</p><ul><li>For high resolution data there's a large memory footprint</li><li>May waste space on empty cells</li><li>One size does not fit all: "Teapot in a stadium" problem, where there are many points in one place whereas the rest is empty</li></ul><p><br></p><h3 id="multiresolution-grids-(quad-tree)">Multiresolution grids (quad tree)</h3><p>A solution to this is by using a multiresolution grid: </p><ul><li>You divide your entire space into a few cells</li><li>For each cell, you have an extra zoom level, which is again made up of a few cells</li><li>Etc</li></ul><p><br></p><p>This gives you a pyramid of layers which can be put together into a lower resolution image which you get in the end. This will be represented as a tree.</p><p><br></p><p>We subdivide only where there is a higher density. We have a maximum amount of elements per cell, and subdivide if we exceed this (but we have a stopping criterion to not split too many times)</p><p><br></p><p><strong>Finding points in disc</strong></p><ul><li>Traverse the tree querying for cell-disc intersection</li><li>If cell-disc intersection: test children</li><li>If leaf: check which primitives are inside of the disc</li></ul><p><br></p><p><strong>Finding closest neighbor</strong></p><ul><li>Traverse the tree keeping track of the <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> closest points</li><li>When we find <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> points, only check points that are closer than the farthest point. If the point is closer, we update our farthest point</li></ul><p><br></p><p>We can keep track of these points using a priority queue</p><p><br></p><p><img src="https://i.imgur.com/z4fnDli.png" width="274"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><h3 id="k-d-trees">k-d trees</h3><p>k-d trees are more compact than QuadTrees by having a tighter subdivision criterion:</p><ul><li>Split one axis at a time</li><li>Alternate on which axis you are splitting</li><li>Place subdivision at optimal position</li></ul><p><br></p><p>When inserting into an empty square, the optimal subdivision is exactly through the point:</p><p><br></p><p><img src="https://i.imgur.com/3DgCm2J.png" width="441"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><h2 id="triangles">Triangles</h2><p>In CG we don't use points though, but triangles. How can we insert triangles into the above data structures? We need to do nearest neighbor searches for ray tracing.&nbsp;</p><p><br></p><p>Common query: what is the first primitive that this ray intersects? Every cell stores all primitives which are (at least) partially in the cell. If we are using multiresolution grids, we split until there is only 1 primitive per cell:</p><p><img src="https://i.imgur.com/6FNORfh.png" width="239"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><p>Then we can just store all primitives which intersect with the ray.</p><p><br></p><p>We can also use a k-d tree:</p><p><img src="https://i.imgur.com/gFJxKwd.png" width="330"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><h3 id="binary-space-partition">Binary Space Partition</h3><p>We can make sure that there’s only 1 polygon per area. Generally not worth it, makes space very complex.</p><p><img src="https://i.imgur.com/lmbouAY.png" width="288"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><h3 id="bounding-volumes-(bv)-and-bounding-volume-hierarchy">Bounding volumes (BV) and Bounding Volume Hierarchy</h3><p>To see if a ray intersects a model, draw an axis-aligned box around the model and check first if the ray intersects the box. We can create subdivisions of the bounding volumes.&nbsp;</p><p><br></p><p>But that can cost a lot of performance if there are many boxes. First off, we group all bounding boxes, to create a BV of all objects. If our ray doesn't intersect with our BV, it won't intersect with any of the objects.</p><p><br></p><p>Then we split. A naive way to choose which axis to use:</p><ul><li>Choose longest axis</li><li>Split on median</li></ul><p><br></p><p><img src="https://i.imgur.com/oo89IBr.png" width="348"></p><p><em>Image taken from slides by Ricardo Marroquim</em></p><p><br></p><p>This splitting may create a large empty space, a better idea is to use an area heuristic: find subdivision that minimizes area, a Surface Area Heuristic</p><p><br></p><p><strong>Surface Area Heuristic</strong></p><p>The main idea is the following: find the subdivision that minimizes the area so that:</p><ul><li>Reducing visited nodes during traversal</li><li>If ray hits node you have a higher chance of hitting an element inside</li></ul><p><br></p><p>But brute forcing this is a NP problem, so we use a probabilistic approach: we create a cost function. This cost function for a node with 2 child nodes is composed of:</p><ul><li>traversal cost<strong> </strong>node and cost of which children intersect ray</li><li>probability of hitting <strong>first </strong>node and checking elements</li><li>probability of hitting <strong>second </strong>node and checking elements</li></ul><p><br></p><p>For this we need to know:</p><ul><li>the cost of intersecting primitives and cost of traversal (constant)</li><li>the probabilities of hitting the BVs: the area of volume <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span> divided by the total area</li><li>how to divide primitives into two groups: this is very costly to determine exactly, so we use predefined split planes and compute the cost for each plane</li></ul><p><br></p>
  </section>

    </section>
  </div>
</body>

</html>