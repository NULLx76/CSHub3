<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h2 id="test-adequacy-criteria">Test Adequacy Criteria</h2><p><strong>Adequacy criteria</strong>: they measure how thoroughly our test cases exercise the program under analysis. See SQT</p><p><br></p><p>We make a distinction between a few types of testing:</p><ul><li><strong>White-box testing</strong>: testing internal structures or workings of an application, as opposed to its functionality</li><li><strong>Subsume relation</strong>: a coverage criterion C1 subsumes C2 if and only if every test set that satisfies criterion C1 also satisfies C2</li><li><strong>Black-box testing: </strong>functional testing, model-based testing, input space partitioning</li></ul><p><br></p><h3 id="oracle-problem">Oracle problem</h3><p>Reaching 100% test coverage is not enough, if you don't assert the functional behavior of your code. We can test this by doing mutation tests.</p><p><br></p><h2 id="mutation-testing">Mutation Testing</h2><p>See <a href="https://cshub.nl/post/523354533" target="_blank">this post</a> for more information.</p><p><br></p><p>Some more operators not covered there:</p><ul><li>Shift Operator Replacement (<strong>SOR</strong>): e.g. replacing <span class="ql-formula" data-value=">>">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&amp;gt;</mo><mo>&amp;gt;</mo></mrow><annotation encoding="application/x-tex">&amp;gt;&amp;gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&gt;</span></span></span></span></span>﻿</span> by <span class="ql-formula" data-value="<<">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&amp;lt;</mo><mo>&amp;lt;</mo></mrow><annotation encoding="application/x-tex">&amp;lt;&amp;lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span></span></span></span></span>﻿</span></li><li>Unary Operation Insertion and Deletion (<strong>UOI / UOD</strong>): a unary operator <span class="ql-formula" data-value="+,\ -,\ !,\ \sim">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mo separator="true">,</mo><mtext>&nbsp;</mtext><mo>−</mo><mo separator="true">,</mo><mtext>&nbsp;</mtext><mo>!</mo><mo separator="true">,</mo><mtext>&nbsp;</mtext><mo>∼</mo></mrow><annotation encoding="application/x-tex">+,\ -,\ !,\ \sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="mord">+</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="mord">−</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="mclose">!</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mspace">&nbsp;</span><span class="mrel">∼</span></span></span></span></span>﻿</span> is inserted / deleted before an expression</li><li>Object Oriented Operators: e.g. changing access modifiers, overriding method deletion etc.</li></ul><p><br></p><h2 id="regression-testing">Regression Testing</h2><p>Regression testing is the process of re-testing software that has been modified. On every new version, we need to verify that newly added or modified code behaves correctly and the unchanged code continues to behave correctly.</p><p><br></p><p>In regression testing, test cases that already existed in <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span> (previous version of the program) can be classified into three main categories:</p><ul><li><strong>Obsolete</strong>: test cases are obsolete if their input/output relation is no longer correct due to changes in specifications or if they are related to deleted functionalities</li><li><strong>Reusable</strong>: reusable test cases only execute the parts of the program that remain unchanged between two versions, i.e. the parts of the program that are common to <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="P'">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">P&amp;#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span></li><li><strong>Retestable</strong>: retestable test cases execute the parts of <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span> that have been changed in <span class="ql-formula" data-value="P'">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">P&amp;#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span>. These test cases should be re-executed</li></ul><p><br></p><h3 id="regression-strategies">Regression strategies</h3><ul><li><strong>Retest all</strong>: the easiest, just execute all test cases. But this is very expensive in very large software</li><li><strong>Test case selection: </strong>selecting only an adequate subset of the test suite for execution. More formally, given the program, <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span>, its modified version <span class="ql-formula" data-value="P'">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">P&amp;#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span>, and a test suite, <span class="ql-formula" data-value="T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span>. Find a subset of <span class="ql-formula" data-value="T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span>, <span class="ql-formula" data-value="T'">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">T&amp;#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span>, for testing <span class="ql-formula" data-value="P'">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">P&amp;#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span>. Usually applied when there aren't enough resources to execute the full test suite</li><li><strong>Test case prioritization: </strong>executing the available test cases in a specific order that increases the likelihood of revealing regression faults earlier. So you might terminate earlier in the ordered test suite, as you've had the most important ones by then.</li></ul><p><br></p><p>In order to determine which test cases are important, we use heuristics or software metrics that correlate with the fault detection capabilities of tests. We can learn from the past by running test cases that:</p><ul><li>Detected bugs in earlier versions (so use past fault coverage)</li><li>Cover the largest parts of the program (so use past code coverage)</li><li>Cover the most critical requirements</li><li>Exercise parts of the code that interact with the changed parts</li><li>Are more diverse w.r.t in and output</li></ul><p><br></p><h3 id="white-box-heuristics">White-box heuristics</h3><p>If we are using code coverage heuristics, we try to get the maximum branch coverage by using as few tests. We can use <strong>exhaustive search</strong> for that: consider all possible subsets of the test suite <span class="ql-formula" data-value="T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span> and then select the smallest subset with highest coverage.</p><p><br></p><p>But the total number of sub-suites grows exponentially with the number of tests, but if we sort the test cases in descending order based on past code coverage, we select the top-most positions until maximum coverage is reached.</p><p><br></p><p>This doesn't always work though, as some test suites may overlap. We can also sort by the test cases in descending order based on additional code coverage. This will make sure that overlapping tests aren't both executed.</p><p><br></p><p>For now we assumed that all tests are equally expensive, which is not true. We should actually change it <strong>additional coverage per unit time</strong></p><p><br></p><h3 id="black-box-heuristics">Black-box heuristics</h3><p>There are bunch of black-box heuristics we can use:</p><ul><li>Input diversity (euclidean distance for numbers, edit distance for string)</li><li>Output diversity, the diversity of assertions </li><li>Model-based distance (path coverage, transition coverage)</li></ul><p><br></p><h3 id="impact-analysis-heuristics">Impact analysis heuristics</h3><p>We can look at which classes depend on other classes and create a tree of used classes. </p><ul><li>If we change a class, we run the tests for that class.</li><li>Then we run the classes that directly depend on this changed class etc. </li></ul><p><br></p><p>Note that none of these heuristics always provide the best solution, only exhaustive search will, but this is actually an NP-complete problem.</p>
  </section>

    </section>
  </div>
</body>

</html>