<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h2 id="creational-patterns">Creational patterns</h2><p>Main idea: classes should be open for extension, but closed for modification.</p><p><img src="https://i.imgur.com/730gG0n.png" width="487"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><h3 id="factory-pattern">Factory pattern</h3><p>The Factory Method defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p><p><br></p><p>So: there is a "creator" which creates an instance of a certain interface, often based on some kind of identifier (enum / string).</p><p><br></p><p><img src="https://i.imgur.com/tFGrM38.png" width="524"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when:</p><ul><li>A class can’t anticipate the class of objects it must create.</li><li>A class wants its subclasses to specify the objects it creates.</li></ul><p><br></p><h3 id="abstract-factory-pattern">Abstract factory pattern</h3><p>The Abstract Factory provides an interface for creating families of related or dependent objects without specifying their concrete classes.</p><p><br></p><p>So: you have an abstract factory and multiple concrete implementations of this factory. Each concrete implementation gives an implementation of classes for their "type".</p><p><br></p><p><img src="https://i.imgur.com/mmpS62s.png" width="563"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when:</p><ul><li>A system should be independent of how its products are created, composed, and represented.</li><li>A system should be configured with one of multiple families of products.</li><li>A family of related product objects is designed to be used together, and you need to enforce this constraint.</li></ul><p><br></p><p>Note that this pattern is just a higher abstraction than the factory pattern. This even abstracts away the creation of factories.</p><p><br></p><h3 id="builder-pattern">Builder pattern</h3><p>The Builder Pattern separates the construction of a complex object from its representation so that the same construction process can create different representations. A product is built step-by-step.</p><p><br></p><p>You often have methods which set fields on an instance and return the instance, so it can be chained.</p><p><img src="https://i.imgur.com/a8mxTFP.png" width="541"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when:</p><ul><li>The algorithm for creating a complex object should be independent of the parts that make up the object and how they’re assembled.</li><li>The construction process must allow different representations for the object that is constructed.</li></ul><p><br></p><p>The difference between the builder pattern and the abstract factory pattern is that the builder pattern focuses on constructing a complex object step by step, whereas the factory pattern concerns with creating families of objects.</p><p><br></p><h3 id="singleton-pattern">Singleton pattern</h3><p>The Singleton Pattern ensures that a class only has one instance at any one time, and provide a global point (the static method <em>getInstance()</em>) of access to it.</p><p><br></p><p>You use this pattern when there must be exactly one instance of a class for the lifetime of the application, and it must be accessible to clients from a well-known access.</p><p><br></p><p>Note that they have some drawbacks:</p><ul><li>A singleton cannot be sub-classed: a singleton with subclasses means that any subclass can create (multiple) instances of the singleton class obviously violate the principle of singletons.</li><li>It makes unit testing difficult as classes may depend on singletons (which are obtained by static methods)</li></ul><p><br></p><p>When using DI (dependency injection) frameworks you (often) also use singletons, but these limitations are fixed there (but the exam will expect you to hate singletons!).</p>
  </section>

    </section>
  </div>
</body>

</html>