<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h2 id="structural-patterns">Structural patterns</h2><p>Structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships among entities.</p><p><br></p><p><img src="https://i.imgur.com/f50Abju.png" width="472"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><h3 id="adapter-pattern">Adapter pattern</h3><p>The Adapter Pattern converts the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.</p><p><br></p><p>So if you have a legacy class you can adapt it to work with your new class, thus reducing code duplication.</p><p><br></p><p><img src="https://i.imgur.com/46BPw4r.png" width="532"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when:</p><ul><li>You want to use an existing class, and its interface does not match the one you need.</li><li>You want to create a reusable class that cooperates with unrelated or unforeseen classes, that is, classes that don’t necessarily have compatible interfaces.</li></ul><p><br></p><h3 id="bridge-pattern">Bridge pattern</h3><p>The Bridge Pattern decouples an abstraction from its implementation so that the two can vary independently.</p><p><br></p><p>So: if we have two types that often change and we want them to work together (use one in the other example), we can use the bridge pattern to reference to each other in abstracted form.</p><p><br></p><p><img src="https://i.imgur.com/tVCmtSR.png" width="533"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when:</p><ul><li>You want to avoid a permanent binding between an abstraction and its implementation.</li><li>Both the abstractions and their implementations should be extensible by subclassing.</li><li>Changes in the implementation of an abstraction should have no impact on clients.</li></ul><p><br></p><h3 id="composite-pattern">Composite pattern</h3><p>The Composite Pattern composes objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</p><p><br></p><p>So: all (sub)components in the tree have the same interface, so we don't have to implement common methods for each element in the tree, as they all extend the same class.</p><p><img src="https://i.imgur.com/LWzaMzm.png" width="641"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/65/W3sDesign_Composite_Design_Pattern_UML.jpg" width="561"></p><p><em>Image taken from Wikipedia</em></p><p><br></p><p>Here:</p><ul><li>Client is the class using the tree</li><li>A component is a node in the tree</li><li>A leaf is a leaf in the tree</li><li>A composite is a node in the tree that is not a leaf, it can refer to other composite nodes or to leaves</li></ul><p><br></p><h3 id="decorator-pattern">Decorator pattern</h3><p>The Decorator Pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p><p><br></p><p>So: it adds the possibility for adding methods to classes by decorating them. This decorator wraps the instance of the class to be decorated and acts upon it and implements the same interface as the class to be decorated. Note that this is different than just subclassing, because this allows you to do this <strong>dynamically</strong>, which subclassing doesn't allow you to do.</p><p><br></p><p><img src="https://i.imgur.com/OTBayLa.png" width="551"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><h3 id="facade-pattern">Facade pattern</h3><p>The Facade Pattern provides a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</p><p><br></p><p>So: we expose certain methods in a higher level interface which under the hood can call lower level APIs of subsystems: </p><p><img src="https://i.imgur.com/oY9eLLg.png" width="506"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><h3 id="flyweight-pattern">Flyweight pattern</h3><p>The Flyweight Pattern uses sharing to support large numbers of fine-grained objects efficiently. Objects are shared for at least two reasons: efficiency and consistency. Flyweight focuses on sharing for space efficiency.</p><p><br></p><p>So: instead of creating similar objects every time it's needed, we only create them (flyweights) once and store references to these objects.</p><p><img src="https://i.imgur.com/r14i8SM.png" width="687"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>We have the following participants:</p><ul><li><strong>Flyweight</strong>: declares an interface through which flyweights can receive and act on extrinsic state</li><li><strong>ConcreteFlyweight: </strong>implements the flyweight interface and adds storage for intrinsic state if any. This object must be shareable. Any state it stores must be instrinsic: independent of the ConcreteFlyweight's context.</li><li><strong>UnsharedConcreteFlyweight: </strong>contains the information that isn't shared, they <em>can</em> contain a ConcreteFlyweight as part of their state</li><li><strong>FlyweightFactory: </strong>creates and manages flyweights and ensures that they are shared properly. Depending on what the client is requesting, it creates a new flyweight or returns the existing one</li><li><strong>Client: </strong>maintains a reference to the flyweights and computes/stores the extrinsic states.</li></ul><p><br></p><p>You should use this pattern when:</p><ul><li>An application uses a large number of objects which costs a lot of RAM / storage</li><li>Most object state is external to the object (<strong>extrinsic</strong>)</li><li>Many groups of objects can be replaced by few shared objects once extrinsic state is removed from those objects</li><li>The application doesn't depend on object identity, as they will be shared</li></ul><p><br></p><h3 id="proxy-pattern">Proxy pattern</h3><p>The Proxy Pattern provides a surrogate or placeholder for another object to control access to it. The proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.</p><p><br></p><p>There are a few scenarios in which they are used:</p><ul><li><strong>Remote proxy: </strong>for distributed object communication. We have a proxy that represents an object that we don't have locally. This proxy will make sure you still have access to this remote object.</li><li><strong>Virtual proxy: </strong>when loading a complex or heavy object, we load it on demand instead of loading it up front. This reduces the start up time of something a lot</li><li><strong>Protection proxy: </strong>control access to a resource based on access rights</li><li><strong>Caching proxy: </strong>used to cache requests when the results of a request is large and expensive to generate.</li></ul><p><br></p><p><br></p><p><br></p>
  </section>

    </section>
  </div>
</body>

</html>