<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h2 id="introduction">Introduction</h2><p>A context-free language has</p><ul><li>Variables (non-terminals)</li><li>Terminals (symbols from alphabet)</li><li>Rules (productions, e.g. <strong><span class="ql-formula" data-value="E\ ::=E+T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mtext>&nbsp;</mtext><mo>:</mo><mo>:</mo><mo>=</mo><mi>E</mi><mo>+</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">E\ ::=E+T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mspace">&nbsp;</span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span></strong>\)</li><li>Start variable (often <strong><span class="ql-formula" data-value="s">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>﻿</span></strong> </li></ul><p><br></p><p><strong>A sentential form</strong> is any string derivable from the start symbol. If we have a rule <strong><span class="ql-formula" data-value="E\to E+T\mid T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>→</mo><mi>E</mi><mo>+</mo><mi>T</mi><mo>∣</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">E\to E+T\mid T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span></strong>) we can derive that into a<strong>sential form <span class="ql-formula" data-value="E=E+T=E+T+T=T+T+T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>E</mi><mo>+</mo><mi>T</mi><mo>=</mo><mi>E</mi><mo>+</mo><mi>T</mi><mo>+</mo><mi>T</mi><mo>=</mo><mi>T</mi><mo>+</mo><mi>T</mi><mo>+</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">E=E+T=E+T+T=T+T+T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span></strong>  .</p><p><br></p><p>We can define left-most derivation and right-most derivation as choosing the left most or right most variable to derive, until you can't derive any further. The result between the two is the same.</p><p><br></p><p>In parse trees you can see which rules are used where in order to end up with a certain derivation:</p><p><strong><img src="https://i.imgur.com/tpQUZRs.png" width="302"></strong></p><p><em>Image taken from videos by Harry Porter</em></p><p><br></p><h2 id="definition"><strong>Definition</strong></h2><p>A context-free grammar <strong><span class="ql-formula" data-value="G=\left(V,\Sigma,R,\ S\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>V</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>R</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>S</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">G=\left(V,\Sigma,R,\ S\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span></strong>  wher</p><ul><li><strong><span class="ql-formula" data-value="V">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span></span></span></span></span>﻿</span></strong>e is the set of variables (non-terminals</li><li><strong><span class="ql-formula" data-value="\Sigma">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Σ</span></span></span></span></span>﻿</span></strong>) is the set of terminal</li><li><strong><span class="ql-formula" data-value="R">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span></span></span></span></span>﻿</span></strong>s is the set of rule</li></ul><p><strong><span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span></strong>s is the start variable,<strong><span class="ql-formula" data-value="S\in V">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">S\in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72243em; vertical-align: -0.0391em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span></span></span></span></span>﻿</span> </strong></p><p>The language of a grammar is <span class="ql-formula" data-value="\left\{w\mid w\in\Sigma^{\ast}\wedge S\Rightarrow w\right\}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mi>w</mi><mo>∣</mo><mi>w</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo>∧</mo><mi>S</mi><mo>⇒</mo><mi>w</mi><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left\{w\mid w\in\Sigma^{\ast}\wedge S\Rightarrow w\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">{</span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span class="mclose delimcenter" style="top: 0em;">}</span></span></span></span></span></span>﻿</span> (<span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span> is derivable to <span class="ql-formula" data-value="w">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span></span></span></span></span>﻿</span>), a context-free language is a language generated by a context-free grammar.</p><p><br></p><p>An <strong>ambiguous string </strong>is a string that has more than one corresponding parse trees. An <strong>ambiguous grammar </strong>is a grammar that has a string that can be derived in more than one way, so some string has multiple parse trees.</p><p><br></p><h2 id="regular-language">Regular language</h2><p>Every regular language is a context-free language. We can convert between a DFA and a grammar by:</p><ul><li>Making a variable for each state</li><li>Make the variable for the starting state the starting variable</li><li>Make a rule for each edge</li><li>Add an epsilon rule for each accept state</li></ul><p><br></p><h2 id="notions">Notions</h2><ul><li>Context-Free languages are closed under union and concatenation</li><li>CFL are not closed under intersection and complement (because if it were, intersection should also be closed as <span class="ql-formula" data-value="A\cap B=\overline{\overline{A}\cup\overline{B}}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi><mo>=</mo><mover accent="true"><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>∪</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">A\cap B=\overline{\overline{A}\cup\overline{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1.0833300000000001em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 1.0833300000000001em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8833300000000001em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8833300000000001em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span><span class="" style="top: -4.00333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>﻿</span> )</li><li>Grammars are <strong>equivalent </strong>if they generate the same language. Determining equivalence is an undeciable problem, a program might never halt. We can do the following:</li><li class="ql-indent-1">Generate every possible string</li><li class="ql-indent-1">Test whether each string is accepted by grammar 1 and 2 by finding parse trees</li><li class="ql-indent-1">If you find a counterexample, they are not equivalent and halt. Else keep on looking</li></ul><p><br></p><h2 id="chomsky-normal-form">Chomsky Normal Form</h2><p>A CFG is in Chomsky Normal Form if the grammar has the form:</p><ul><li><span class="ql-formula" data-value="A\to BC">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">A\to BC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>﻿</span> (exactly two variables)</li><li><span class="ql-formula" data-value="A\to a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A\to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span> (or a single terminal symbol)</li></ul><p><span class="ql-formula" data-value="S\to\epsilon">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S\to\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span>﻿</span> is also allowed</p><p><br></p><p>Every CFL can be generated by a grammar in chomsky normal form, so for every CFG there is an equivalent CNF:</p><ol><li>Make sure start symbol does not appear on the right hand side</li><li>Remove rules like <span class="ql-formula" data-value="A\to\epsilon">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A\to\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span>﻿</span> </li><li>Get rid of all unit rules like <span class="ql-formula" data-value="A\to B">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span></span></span>﻿</span> </li><li>Get rid of rules with more than 2 symbols on the right hand side like <span class="ql-formula" data-value="A\to BCDE">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>C</mi><mi>D</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">A\to BCDE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span></span></span></span></span>﻿</span> </li><li>Make sure that the we have 2 variables on the right or 1 terminal symbol</li></ol><p><br></p><p>An example of this can be found in the examples tab.</p><p><br></p><h2 id="pushdown-automata-(pda)">Pushdown automata (PDA)</h2><p>The input is the same as in a FSM, but we can now push and pop from a stack, which can serve as memory. A state transition may depend on the stack and may push onto the stack. This is non-deterministic!</p><p><br></p><p>This stack has an alphabet <span class="ql-formula" data-value="\Gamma">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Γ</span></span></span></span></span>﻿</span>, which may be different from the input alphabet <span class="ql-formula" data-value="\Sigma">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Σ</span></span></span></span></span>﻿</span>.</p><p><br></p><p>The label of a transition can now be <span class="ql-formula" data-value="a,b\to c">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a,b\to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span>﻿</span>, where:</p><ul><li><span class="ql-formula" data-value="a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span> is the input symbol, may be <span class="ql-formula" data-value="\epsilon">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span>﻿</span> </li><li><span class="ql-formula" data-value="b">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>﻿</span> is the symbol on top of the stack, which will be popped. <span class="ql-formula" data-value="\epsilon">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span>﻿</span> means that the stack is neither read nor popped</li><li><span class="ql-formula" data-value="c">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span>﻿</span> is the symbol that is pushed onto the stack, <span class="ql-formula" data-value="\epsilon">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span>﻿</span> means nothing is pushed</li></ul><p><br></p><p>If we use <span class="ql-formula" data-value="\Gamma=\left\{\$,\ 0\right\}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>=</mo><mrow><mo fence="true">{</mo><mi mathvariant="normal">$</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><mn>0</mn><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\Gamma=\left\{\$,\ 0\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">{</span><span class="mord">$</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="mord">0</span><span class="mclose delimcenter" style="top: 0em;">}</span></span></span></span></span></span>﻿</span>, we could detect the bottom of the stack. Given the following pushdown automata:</p><p><img src="https://i.imgur.com/WYmxTlo.png" width="508"></p><ul><li>First we take the <span class="ql-formula" data-value="A\to B">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span></span></span>﻿</span> transition, and push <span class="ql-formula" data-value="\$">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">$</mi></mrow><annotation encoding="application/x-tex">\$</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="mord">$</span></span></span></span></span>﻿</span> to the stack</li><li>If the input symbol is <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span>, we push <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span> to the stack</li><li>If we take the <span class="ql-formula" data-value="B\to C">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">B\to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>﻿</span> transition, we do nothing</li><li>If the input symbol is <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>, we read a <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span> from the stack, to make sure that the <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>s and <span class="ql-formula" data-value="0s">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">0s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord mathdefault">s</span></span></span></span></span>﻿</span> align</li><li>When we reach the final transition, our stack should be empty except for our <span class="ql-formula" data-value="\$">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">$</mi></mrow><annotation encoding="application/x-tex">\$</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="mord">$</span></span></span></span></span>﻿</span></li></ul><p><br></p><p>A string is accepted when:</p><ul><li>We end in an accept state</li><li>Consume all the input symbols</li><li>There is a path through the finite state control, you can't pop an empty stack or you can't pop something that is not on the top of the stack</li></ul><p><br></p><h3 id="formal-definition">Formal definition</h3><p>Given <span class="ql-formula" data-value="\left(Q,\Sigma,\Gamma,\delta,q_0,F\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(Q,\Sigma,\Gamma,\delta,q_0,F\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.03785em;" class="mord mathdefault">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord"><span style="margin-right: 0.03588em;" class="mord mathdefault">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>, meaning:</p><ul><li><span class="ql-formula" data-value="Q">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8777699999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></span>﻿</span> is the set of states</li><li><span class="ql-formula" data-value="\Sigma">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Σ</span></span></span></span></span>﻿</span> is the input alphabet</li><li><span class="ql-formula" data-value="\Gamma">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Γ</span></span></span></span></span>﻿</span> is the stack alphabet</li><li><span class="ql-formula" data-value="\delta:Q\times\Sigma_{\epsilon}\times\Gamma_{\epsilon}\to P\left(Q\times\Gamma_{\epsilon}\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><msub><mi mathvariant="normal">Σ</mi><mi>ϵ</mi></msub><mo>×</mo><msub><mi mathvariant="normal">Γ</mi><mi>ϵ</mi></msub><mo>→</mo><mi>P</mi><mrow><mo fence="true">(</mo><mi>Q</mi><mo>×</mo><msub><mi mathvariant="normal">Γ</mi><mi>ϵ</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\delta:Q\times\Sigma_{\epsilon}\times\Gamma_{\epsilon}\to P\left(Q\times\Gamma_{\epsilon}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03785em;" class="mord mathdefault">δ</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.8777699999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϵ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">Γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϵ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord"><span class="mord">Γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϵ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>, given a state, an input symbol and a symbol from the stack, we get a power set of possible states, and for each state you get an symbol that is pushed to the stack</li><li><span class="ql-formula" data-value="q_0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span style="margin-right: 0.03588em;" class="mord mathdefault">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> is the starting state, <span class="ql-formula" data-value="q_0\in Q">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0\in Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7335400000000001em; vertical-align: -0.19444em;"></span><span class="mord"><span style="margin-right: 0.03588em;" class="mord mathdefault">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.8777699999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></span>﻿</span> </li><li><span class="ql-formula" data-value="F">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span></span></span></span></span>﻿</span> are accept states, <span class="ql-formula" data-value="F\subseteq Q">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">F\subseteq Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8193em; vertical-align: -0.13597em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.8777699999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></span>﻿</span> </li></ul><p><br></p><h2 id="similarity-cfg-and-pda-">Similarity CFG and PDA </h2><p>This proof consists of two parts:</p><ol><li>Given a CFG, show how to construct a PDA that recognizes it</li><li>Given a PDA, show how to construct a CFG that recognizes the same strings</li></ol><p><br></p><p>In general a derivation of a CFG consists of a part with terminals <span class="ql-formula" data-value="aaaaaaaa">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aaaaaaaa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span> (for example) and the rest of the grammar <span class="ql-formula" data-value="BaBBaCa">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>a</mi><mi>B</mi><mi>B</mi><mi>a</mi><mi>C</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">BaBBaCa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span class="mord mathdefault">a</span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span class="mord mathdefault">a</span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span> (for example). In our PDA we will have a stack which will represent the setential form of the elements that we still need to parse.</p><p> </p><p>At each step we will be expanding the top of the stack and pushing the result of this to the stack.</p><p><br></p><p>If the top of our stack contains <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span> and our rule would be <span class="ql-formula" data-value="A\to BCD">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">A\to BCD</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span></span></span></span></span>﻿</span>, we'd get the following PDA:</p><p><img src="https://i.imgur.com/UUuAlkc.png" width="516"></p><p><em>Image taken from video lecture by Harry Porter</em></p><p><br></p><p>As a PDA is non-deterministic, we just try the different rules in parallel.</p><p><br></p><p>So we start with pushing <span class="ql-formula" data-value="\$">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">$</mi></mrow><annotation encoding="application/x-tex">\$</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="mord">$</span></span></span></span></span>﻿</span> to the stack, then pushing starting state <span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span>. Then we have a cycle which contains all the rules. Once we have procssed all of them we will pop <span class="ql-formula" data-value="\$">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">$</mi></mrow><annotation encoding="application/x-tex">\$</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="mord">$</span></span></span></span></span>﻿</span> from the stack and reach our acceptance state:</p><p><img src="https://i.imgur.com/iWZ7TpS.png" width="306"></p><p><em>Image taken from video lecture by Harry Porter</em></p><p><br></p>
  </section>

    </section>
  </div>
</body>

</html>