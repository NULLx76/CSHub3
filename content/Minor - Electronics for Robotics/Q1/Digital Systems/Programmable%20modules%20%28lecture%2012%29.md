+++
title = "Programmable modules (lecture 12)"
date = 2020-10-24
+++
<h1 id="programmable-modules">Programmable Modules</h1><h2 id="psa">PSA</h2><p>A <strong>PSA </strong>is a PLA (programmable logic array) connected with a <strong>state register.</strong></p><p><img src="https://i.imgur.com/IMgpOUU.png" width="282"></p><p>It outputs a value based on the state and the current input:</p><p><img src="https://i.imgur.com/rRySAG1.png" width="346"></p><p><br></p><h2 id="rom">ROM</h2><p>A ROM is a storage element containing <span class="ql-formula" data-value="2^n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> rows and <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> elements per row. We have <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> inputs (to select which row to pick) and <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> outputs:</p><p><img src="https://i.imgur.com/lgPySCK.png" width="224"></p><p>We use a decoder to map between <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> input bits to one of <span class="ql-formula" data-value="2^n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> rows:</p><p><img src="https://i.imgur.com/Yvdww3P.png" width="256"></p><p>Each column of a ROM module can be seen as a huge truth table, where every column is a truth table (so it is a universal set by itself). We can thus implement <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> functions using one ROM.</p><p><br></p><h3 id="implementation-of-switching-functions">Implementation of switching functions</h3><p>You can for example implement the <span class="ql-formula" data-value="+">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">+</span></span></span></span></span>﻿</span> function:</p><p><img src="https://i.imgur.com/HXSRMlM.png" width="364"></p><p>For every possible permutation of the two operands, you have a row in the ROM which corresponds to the solution of this addition.</p><p><br></p><h3 id="usage-in-sequential-systems">Usage in sequential systems</h3><p>You can use the ROM together with a state register:</p><p><img src="https://i.imgur.com/goAYaSt.png" width="306"></p><p>You see that the output of the state register again feeds into the ROM.</p><p><br></p><h3 id="types-of-roms">Types of ROMs</h3><ul><li>Mask-programmed ROM - can't change</li><li>Field-programmable ROM, <strong>PROMs</strong> - change once</li><li>Erasable ROM (<strong>EPROM</strong>) - erasing using light</li><li>Electrically Erasable ROM (<strong>EEPROM</strong>) - erasing using electrical signals</li></ul><p><br></p><h3 id="building-larger-roms">Building larger ROMs</h3><p>We can build larger ROMs by using multiple ROMs (see image):</p><ul><li>If we vertically add ROMs, we add more rows (i.e. add more inputs)</li><li class="ql-indent-1">We decide which enable port to use by creating a <span class="ql-formula" data-value="2-4">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2-4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span>﻿</span> decoder</li><li class="ql-indent-1">Since we need 2 extra bits, we have <span class="ql-formula" data-value="k+2">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span>﻿</span> address bits</li><li class="ql-indent-1">We also need to select which ROM to use for an output, using a multiplexer. In this case, the decoder isn't necessary</li><li>If we horizontally add ROMs, we add more columns (i.e. add more functions)</li></ul><p><img src="https://i.imgur.com/33hCzZR.png" width="446"></p><p><br></p><h2 id="fpga">FPGA</h2><p>A field-programmable gate array is a piece of hardware that can be reprogrammed (any combinational logic / sequential system):</p><p><img src="https://i.imgur.com/1c6dEZx.png" width="406"></p><p>In an FPGA, you'll see about <span class="ql-formula" data-value="30\%">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span></span>﻿</span> logic and <span class="ql-formula" data-value="70\%">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span></span>﻿</span> wiring: you want this chip to be flexible so you need a lot of wires.</p><p><br></p><h3 id="plb">PLB</h3><p>The <strong>Programmable Logic Block (PLB) </strong>can be reprogrammed. using:</p><ul><li>A ROM, called Look-Up Tables in FPGA's to implement some combinational logic (not very large)</li><li>Muxes, to select how connections are being made between components</li><li>Registers to allow for sequential logic</li></ul><p><br></p><p>We connect multiple PLBs together there are direct wires. This way we can compute more complicated functions.</p><p><br></p><h3 id="design">Design</h3><ol><li>Create a behavioral description (VHDL)</li><li>Using CAD tools to create a design</li><li>Partition the design into submodules that can be mapped onto PLBs</li><li>Place &amp; route the submodules</li></ol><p><br></p><h1 id="rtl-systems">RTL systems</h1><p>A register-transfer level systems abstract away how individual bits flow through a design. We can look at two things: </p><ul><li>Where is data stored and how do you move data from storage to storage</li><li>Which operations are performed on the data during transfer (<strong>register transfer</strong>)</li></ul><p><br></p><p>We use two systems to achieve this:</p><ol><li><strong>Data subsystem</strong>: how to move and transform data from register to register</li><li><strong>Control subsystem: </strong>changing how the data subsystem behaves</li></ol><p><img src="https://i.imgur.com/0EhGew5.png" width="296"></p><p>The control inputs can also be seen as machine code.</p><p><br></p><h2 id="execution-graph">Execution Graph</h2><p>We can compute a function in a sequential and concurrent way. <strong>Execution graphs </strong>allow us to highlight the operations needed to execute such a function:</p><p><img src="https://i.imgur.com/2S3xL0c.png" width="349"></p><p><br></p><p>A concurrent execution graph specifies multiple operations in a single node of the graph:</p><p><img src="https://i.imgur.com/8BTQgfj.png" width="223"></p><p><br></p><h2 id="data-subsystem">Data subsystem</h2><p>To design the data subsystem, we:</p><ol><li>Determine the operators (functional units)</li><li>Determine the registers required to store operands, results and intermediate variables</li><li>Connect the component by datapaths (wires and MUXes) as required by transfers in the sequence</li><li>Determine the control signals and conditions required by the sequence</li><li>Describe the structure of the data section by a logic diagram, a net list or a VHDL structural description</li></ol><p><br></p><h3 id="parts">Parts</h3><p>A data subsystem consists of:</p><ul><li><strong>Storage modules:</strong> registers, arrays of registers, combination</li><li><strong>Functional modules:</strong> e.g. ALU</li><li><strong>Datapaths: </strong>unidirectional, bidirectional, complete interconnection (many wires), single bus interconnection (one wire)</li><li><strong>Control points: </strong>external inputs</li><li><strong>Condition points: </strong>outputs</li></ul><p><br></p><h3 id="types-of-systems">Types of systems</h3><p>FU = Functional Unit</p><ul><li><strong>Non-sharing system: </strong>one FU for each node</li><li><strong>Sharing system: </strong>sharing FUs, requires scheduling of FUs</li><li><strong>Uni-module system: </strong>only one FU</li></ul><p><br></p><h3 id="types-of-control">Types of control</h3><ul><li><strong>Centralized control:</strong> there is 1 controller that controls everything</li><li><strong>Decentralized control: </strong>the modules do everything by themselves</li><li><strong>Semicentralized control:</strong> mix</li></ul><p><img src="https://i.imgur.com/wIGG4NY.png" width="350"></p><p><strong>Non-sharing &amp; decentralized control</strong></p><p>Non-sharing:</p><ul><li>Data flows through design</li><li>Registers aren't re-used to store intermediate results</li></ul><p><br></p><p>Decentralized control:</p><ul><li>Autonomous operation</li><li>No control from outside, only start</li></ul><p><img src="https://i.imgur.com/dFvT7J6.png" width="263"></p><p>As you can see, each operation has their own FU.</p><p><br></p><p><strong>Sharing &amp; centralized control</strong></p><p>Some FUs are shared, so we have a controller that needs to schedule the FUs</p><p><img src="https://i.imgur.com/n5DVyUZ.png" width="352"></p><p>This does the same as the previous example, but with a controller &amp; less FUs.</p><p><br></p><p><strong>Uni-module with control</strong></p><p>The operations must be <strong>transformed </strong>to the operation of the uni-module and they must be sequentialized. Therefore it's generally slower.</p><p><img src="https://i.imgur.com/gAqsDyC.png" width="383"></p><p><br></p><h2 id="control-subsystem">Control subsystem</h2><p>To design the control system, we:</p><ol><li>Determine the register-transfer sequence</li><li class="ql-indent-1">Input 1: control input (higher level)</li><li class="ql-indent-1">Input 2: conditions from data sub-system</li><li>Assign one state to each Register Transfer group</li><li>Determine state-transitions and output functions. The outputs are control signals for the data subsystem</li><li>Implement the corresponding sequential system</li></ol><p><br></p><h3 id="state-assignment">State assignment</h3><p>We can move from one to another state in two ways:</p><ul><li><strong>Unconditional:</strong> only one successor to a state, we don't need logic to pick the next state</li><li class="ql-indent-1">You can use one flip-flop per state</li><li><strong>Conditional:</strong> several possible successors depending on the value of a condition (from the data subsystem)</li><li class="ql-indent-1">You need a demux with conditions as input to pick the next successor state</li></ul><p><br></p><h3 id="example">Example</h3><p><img src="https://i.imgur.com/eVge0PF.png" width="562"></p><p>As you can see here, we can transition between states, and then emit control signals based on the current state.</p><p><br></p><h1 id="microprogrammed-controller">Microprogrammed controller</h1><p>We control a data subsystem by:</p><ol><li>Controlling control signals <strong>over time</strong></li><li>Collect the control signals per <strong>step</strong></li><li>Store them in a ROM, instead of generating them per state</li><li>We can translate the state bits to retrieve the right row from the ROM to send to the data subsystem</li></ol><p><br></p><h2 id="architecture">Architecture</h2><p><img src="https://i.imgur.com/FSXPKnU.png" width="358"></p><ul><li>The <strong>CS</strong> is the ROM that contains the microinstructions, it is writable.</li><li>After a row is selected, it is forwarded to the <strong>decoder</strong>. In the decoder, the control bits are extracted and send sent to data subsystem</li><li>Based on the sequencing bits (from the microinstruction) and the conditions (received from the data subsystem), the <strong>address generator</strong> determines which next microinstruction to select</li><li>The location of the <strong>microinstruction</strong> in the ROM is stored as an index in the <strong>CSAR</strong> register. A sequence of microinstructions is called a <strong>microprogram.</strong></li></ul><p><br></p><h3 id="advantages">Advantages</h3><ul><li>Modular and regular structure of controller, independent of the data subsystem</li><li>Implementation of controller is translated into writing microprogram to control data subsystem</li><li>Writing microcode is simpler than designing a fixed controller</li><li>Can be easily modified</li></ul><p><br></p><h3 id="disadvantages">Disadvantages</h3><ul><li>Might be slower</li></ul><p><br></p><h2 id="microinstruction">Microinstruction</h2><p>A microinstruction is a series of bits, which has two fields:</p><ul><li><strong>The control field:</strong> contains the values of control signals</li><li class="ql-indent-1"><em>Horizontal (unpacked, decoded):</em> all control signals are in one field</li><li class="ql-indent-1"><em>Vertical (packed, encoded)</em>: control signals are combined into sub-fields. A value is assigned to the same subfield if they can't both be used at the same time. It requires the decoding of these sub-fields.</li></ul><p><img src="https://i.imgur.com/r5wx8rV.png" width="367"></p><ul><li><strong>A sequencing field:</strong> specifies the address of the next microinstruction. This way you know which instruction to execute after this one</li><li class="ql-indent-1"><strong>Explicit addressing</strong>: specifying an exact address</li><li class="ql-indent-1"><strong>Implicit addressing: </strong>only go to an address when conditions are true. If you don't jump, you just go to the next instruction (address <span class="ql-formula" data-value="+1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span></span>﻿</span>)</li></ul><p><br></p><h3 id="timing">Timing</h3><ol><li>Loading the address of the next microinstruction into CSAR</li><li>Fetching the corresponding microinstruction</li><li>Decoding the fields</li><li>Executing the microoperations</li><li>Calculating the address of the next microinstruction (may overlap with the execution)</li></ol><p><img src="https://i.imgur.com/l5z7spO.png" width="323"></p><p>This is very similar to <strong>processor pipelining. </strong></p><p><br></p>