+++
title = "Complexity analysis"
date = 2019-01-21
+++
<h2>Complexity analysis</h2><p>Complexity Analysis boils down to analyzing the efficiency of an algorithm. This efficiency is measured by two elements:</p><ul><li>Time complexity - The amount of time it takes for a given algorithm to execute.</li><li>Space complexity - The amount of space a given algorithm uses at most during execution.</li></ul><p><br></p><h2>Empirical time analysis</h2><p>Empirical time analysis is an analysis method for time complexity that is roughly equivalent to a brute force approach when programming or a proof by exhaustion for Reasoning and Logic. You simply execute the algorithm and measure the time it takes to finish.</p><div style="white-space: normal;" class="markdown-body"><pre data-lang="text/x-java">long startTime = System.currentTimeMillis();   // record the starting time
/* (run the algorithm) */
long endTime = System.currentTimeMillis();     // record the ending time
long elapsed = endTime - startTime;            // calculate the elapsed time
</pre>
</div><h2><br></h2><p><strong>Problems with empirical time analysis</strong></p><p>The most prominent problems with empirical time analysis are the following:</p><ul><li>Results may differ when different hardware / compiler / OS / etc. are used.</li><li>Experiments are restricted to a limited set of inputs.</li><li>Requires a full implementation of the algorithm.</li><li>A compiler may optimize your code or require a warm up time.</li></ul><p><br></p><h2>Theoretical complexity analysis for time</h2><p>Theoretical complexity analysis for time is a way to analyse the efficiency of an algorithm without having to run additional code. In fact, you don't even need to execute your algorithm to analyse it. </p><p><br></p><p>What we do is, we assign a mathematical function to the algorithm that describes the running time.</p><p><br></p><div style="white-space: normal;" class="markdown-body"><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>l</mi><mi>g</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>m</mi></mrow></msub><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mtext>"number&nbsp;of&nbsp;primitive&nbsp;operations&nbsp;performed&nbsp;for&nbsp;an&nbsp;input&nbsp;size&nbsp;n"</mtext></mrow><annotation encoding="application/x-tex">T_{algorithm}(n)=\text{"number of primitive operations performed for an input size n"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">"number&nbsp;of&nbsp;primitive&nbsp;operations&nbsp;performed&nbsp;for&nbsp;an&nbsp;input&nbsp;size&nbsp;n"</span></span></span></span></span></p>
</div><p><br></p><p>Number of primitive operations performed. What does this mean? Primitive operations are operations that have a run time of 1.</p><p>We consider the following primitive operations:</p><ul><li>Assigning a value to a variable</li><li>Performing an arithmetic operation</li><li>Comparing two numbers ( and no more than two)</li><li>Accessing a single element of an array by index</li><li>Calling and returning from a method</li></ul><p><br></p><p>When setting up this  <span class="ql-formula" data-value="T_{a\lg orithm}\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>lg</mi><mo>⁡</mo><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>m</mi></mrow></msub><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">T_{a\lg orithm}\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.036108em; vertical-align: -0.286108em;"></span><span class="mord"><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361079999999999em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mspace mtight" style="margin-right: 0.19516666666666668em;"></span><span class="mop mtight">l<span style="margin-right: 0.01389em;">g</span></span><span class="mspace mtight" style="margin-right: 0.19516666666666668em;"></span><span class="mord mathdefault mtight">o</span><span style="margin-right: 0.02778em;" class="mord mathdefault mtight">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> we go through a number of steps:</p><ol><li>State the size of the problem <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> . Most often this is the length of an array.</li><li>Simplify the program to only using primitive operations (optional).</li><li>Express the running time by counting operations.</li></ol><p><br></p><p><em>! Note that when expressing the running time, we consider the worst-case of our problem </em><span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> .</p><p><em>! Note that a + only represents an arithmetic operation when applied to numbers.</em></p><p><br></p><h2>Theoretical complexity analysis for space</h2><p>Space complexity differs from time complexity in the sense that space used can go down, while time can not. You could say that space can be reused, while time is gone forever after it has been used. That's why we only look at the most space used at any given time during the execution of an algorithm when analyzing its space complexity. Where we counted the number of primitive operations performed for time complexity, for space complexity we count the number of stack frames used.</p><p><br></p><div style="white-space: normal;" class="markdown-body"><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>a</mi><mi>l</mi><mi>g</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>m</mi></mrow></msub><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mtext>"maximum&nbsp;amount&nbsp;of&nbsp;memory&nbsp;needed&nbsp;at&nbsp;any&nbsp;point&nbsp;in&nbsp;the&nbsp;algorithm&nbsp;for&nbsp;an&nbsp;input&nbsp;size&nbsp;n"</mtext></mrow><annotation encoding="application/x-tex">S_{algorithm}(n)=\text{"maximum amount of memory needed at any point in the algorithm for an input size n"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">"maximum&nbsp;amount&nbsp;of&nbsp;memory&nbsp;needed&nbsp;at&nbsp;any&nbsp;point&nbsp;in&nbsp;the&nbsp;algorithm&nbsp;for&nbsp;an&nbsp;input&nbsp;size&nbsp;n"</span></span></span></span></span></p>
</div><p><br></p><p>To do this you have to remember that a stack frame is added or<strong> pushed</strong> onto the stack when a method is called and is only removed or <strong>popped</strong> off the stack when you return from the method. This means that with a recursive method, it is possible to have multiple stack frames on the stack at once.</p><p><br></p><h2>Big O proof</h2><p>If we have a formula and a claimed Big O notation of that formula, we can prove whether this is the correct one. To prove this we first have to understand what it means for a Big O Notation to be correct. A Big O Notation <span class="ql-formula" data-value="O\left(g\left(n\right)\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>g</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(g\left(n\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span style="margin-right: 0.03588em;" class="mord mathdefault">g</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> <span class="ql-formula" data-value="O\left(g\left(x\right)\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>g</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(g\left(x\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span style="margin-right: 0.03588em;" class="mord mathdefault">g</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">x</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>of a function <span class="ql-formula" data-value="f\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.10764em;" class="mord mathdefault">f</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> is correct if there is a positive constant c such that <span class="ql-formula" data-value="f\left(n\right)\ \le\ c\ \cdot g\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow><mtext>&nbsp;</mtext><mo>≤</mo><mtext>&nbsp;</mtext><mi>c</mi><mtext>&nbsp;</mtext><mo>⋅</mo><mi>g</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f\left(n\right)\ \le\ c\ \cdot g\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.10764em;" class="mord mathdefault">f</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mspace">&nbsp;</span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mspace">&nbsp;</span></span><span class="base"><span class="strut" style="height: 0.44445em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mspace">&nbsp;</span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">g</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> and there is a constant <span class="ql-formula" data-value="n_0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> such that <span class="ql-formula" data-value="n\ \ge\ n_0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mtext>&nbsp;</mtext><mo>≥</mo><mtext>&nbsp;</mtext><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n\ \ge\ n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7719400000000001em; vertical-align: -0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mspace">&nbsp;</span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mspace">&nbsp;</span></span><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span>. Given <span class="ql-formula" data-value="f\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.10764em;" class="mord mathdefault">f</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="g\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">g\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">g</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> we can prove there is (or isn't) a constant c and <span class="ql-formula" data-value="n_0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.30110799999999993em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span>  such that this holds.</p>