+++
title = "NoSQL"
date = 2019-01-21
+++
<h1>NoSQL</h1><h2>What's wrong with relational databases?</h2><br><p><strong>Unneeded complexity</strong><span>:</span></p><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>too many features</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>too strict data consistency</li><br><p><strong>Low throughput</strong><span>:</span></p><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>extreme OLTP scenarios are badly served by RDBMs</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>sometimes reliability is not everything</li><br><p><strong>Cost of scalability</strong><span>:</span></p><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>RDBMs are difficult to scale horizontally, and they require highly available hardware</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>The present is distributed and on the cloud</li><br><p><strong>Impedance mismatch</strong><span>:</span></p><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>Mapping between database representation and program representation of data is expensive</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>Object-relational mappers help, but they add complexity and affect performance</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>This impedance mismatch is because of the normalization of RDBMs, meaning that data is not duplicated, and when inserting, deleting or updating this data should still be consistent.</li><br><br><h2>What is NoSQL?</h2><p><strong>Data models:</strong></p><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><em>Key, value store</em><span>: Redis</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><em>Document: </em><span>MongoDb</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><em>Column family (not covered): </em><span>Cassandra</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><em>Graph: </em><span>Neo4J</span></li><br><p><strong>Aggregate-oriented models</strong></p><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>They acknowledge the need to operate on data unit having a more complex structure than a set of tuples (list, map, other data structures)</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>An aggregate is a <strong>collection </strong><span>of related objects used as a </span><strong><span>unit </span></strong><span>for data manipulation, management and consistency</span></li><br><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>Easier for application programmers to work with (no impedance mismatch)</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>The link between two pieces of data is not normalized, data can be duplicated. There can still be references, but data that won't change will just be copied.</li><br><p>Thus:</p><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>Aggregation minimizes the number of aggregates accessed during data interaction</li><li data-list="bullet" class="ql-indent-1"><span class="ql-ui" contenteditable="false"></span>We have to think about accessing that data</li><li data-list="bullet" class="ql-indent-1"><span class="ql-ui" contenteditable="false"></span>We make this part of our thinking when developing the application data model</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>There is no universal answer on <strong>how </strong><span>we draw aggregate boundaries: </span><strong><span>it depends </span></strong><span>on data manipulation operations</span></li><br><p><strong>Schemaless databases</strong></p><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>With RDBMs the (fixed) schema has to be defined beforehand</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>NoSQL databases are schemaless, they can store "anything": the data model can be easily changed</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>But the implicit schema exists in the application, the database cannot enforce integrity</li><br><br>