+++
title = "Logical storage"
date = 2019-09-29
+++
<h2 id="accessing-data"><strong>Accessing data</strong></h2><p><strong>Physical tuning </strong>of the database is an important task, this includes:</p><ul><li>Allocating of data on the disks: DBMS focus on <strong>HDD </strong>storage, with a strong performance gap between primary (HDD) and secondary (RAM) storage </li><li>Intelligent buffer management</li><li>Creating access paths and indexing data</li></ul><p><br></p><p><strong>File structure</strong></p><ul><li>Database are mapped into files</li><li>Each file is partitioned into fixed length <strong>blocks (</strong>defined by the DB, a multiple of an OS block)</li><li>Complete blocks are transferred from disk to main memory, done by the <strong>buffer manager</strong></li></ul><p><br></p><p><strong>Requesting data</strong></p><p>When data is requested: </p><ul><li>If buffered, return it. </li><li>Else, allocate space in the buffer, fetch from disk and return</li></ul><p><br></p><p><strong>Replacement strategies</strong></p><p>Often, currently buffered blocks will be evicted on fetching new blocks, if they have been modified, they must be written back to disk</p><p><br></p><p>In order to do this, the buffer manager uses the following techniques</p><ul><li>Blocks that cannot yet be written to disk are called <strong>pinned blocks, </strong>when there are pointers to that block in the database which would become dangling</li><li><strong>Forced output </strong>of blocks, blocks will be written back to disk before buffer space is needed, to make sure data survives</li><li>Replacement strategies</li><li class="ql-indent-1"><strong>LRU</strong>, see <a href="https://cshub.nl/post/860217015" target="_blank">here</a></li><li class="ql-indent-1"><strong>Toss immediate: </strong>after the db has finished processing the block, it will immediately be replaced</li><li class="ql-indent-1"><strong>Expected reuse: </strong>statistics about query frequencies determine which block will get evicted</li></ul><p><br></p><h2 id="blocks">Blocks</h2><p>An example of a block (ORACLE data block):</p><ul><li><strong>Header: </strong>contains general block information (block address, type of segment)</li><li><strong>Table directory: </strong>shows tables that have rows in the block</li><li><strong>Row directory: </strong>contains information about the rows in the block</li><li><strong>Row data: </strong>the row data</li></ul><p><br></p><p>Records of different relations should be stored in <strong>individual files</strong>. Storing related records in the same block minimizes disk accesses</p><p><br></p><p><strong>Multi-table clustering</strong> file organization may store records of different tables in the same block, which can be good for often occurring joins</p><p><br></p><h2 id="file-organization"><strong>File organization</strong></h2><p>Data records have to be written in a file such that the entire record can be accessed with minimal disk accesses.</p><p><br></p><p><strong>Fixed length records</strong></p><ul><li>E.g. 42 bytes for every record</li><li><strong>Problem: </strong>if the block size is not a multiple of 42 bytes, records may cross boundaries</li><li><strong>Problem: </strong>deleting a record can either be done by marking it as deleted, or by replacing it with some other record</li></ul><p><br></p><p><strong>Variable length records</strong></p><ul><li>Necessary for multi-table files or records that allow variable length attributes</li><li><strong>Problem: </strong>how to know when a record ends?</li><li class="ql-indent-1">Introduce <strong>end-of-record </strong>symbols or store record length at the beginning of the record</li><li class="ql-indent-1"><strong>Slotted page structure: </strong>block header contains number of entries, end of free space and pointers to location/size of entries. Records are moved to use up space: no fragmentation!</li></ul><p><br></p><p><strong>File</strong></p><ul><li><strong>Unspanned </strong>record organization fills blocks only with complete records (upper part of image)</li><li><strong>Spanned </strong>organization uses pointers to divide records</li></ul><p><img src="https://i.imgur.com/gTDEGWQ.png" width="221"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><p><strong>Non-standard blocks</strong></p><ul><li>Necessary for large objects: binary large objects (<strong>blobs</strong>) and character large objects (<strong>clobs</strong>)</li><li>Large objects are not interpreted in databases, if an object is bigger than a block, contiguous pages of the buffer pool have to be allocated for storage</li></ul><p><br></p><p><strong>Types of queries</strong></p><ul><li>For the OLTP cases, a <strong>row-wise </strong>database is a good idea, rows are short and you would usually want to access it completely</li><li>For OLAP, we don't have to get specific rows, but a big query over the whole dataset</li></ul><p><br></p><h2 id="rows-vs.-columns">Rows vs. columns</h2><p><strong>Row stores</strong></p><ul><li>Many newer systems opt for column-oriented organizations</li><li>Multiple records stored per page</li><li>Easy to add new records</li><li>Efficient as often most parts of a record is needed</li><li>Might read unnecessary data</li></ul><p><br></p><p><strong>Column stores</strong></p><ul><li>Stores column data in different pages, reconstructing a whole record is hard</li><li>Efficient compression and column-based statistics</li><li>Can be more efficient for queries where only a few attributes of a relation are used, as they only read the required attributes</li><li>Writing a tuple requires multiple accesses</li></ul><p><br></p><p><strong>Row vs column stores</strong></p><p>Column stores can be significantly faster for some application, but slower for others. </p>