+++
title = "Indexing"
date = 2019-09-29
+++
<h1 id="indexes">Indexes</h1><h2 id="primary-sparse-block-indexes"><strong>Primary sparse block indexes</strong></h2><ul><li>Order data by some usually unique attribute (primary key) as indexing field and store database records in this order</li><li>Index record contains pointer to the respective storage place</li><li>This pointer only points to the first entry in the block, not to the other entries (<strong>sparse block indexes</strong>)</li></ul><p><br></p><p><strong>Advantages</strong>:</p><ul><li>Number of blocks needed for storing the index is small compared to data</li><li>Can be kept in a buffer</li><li>Insertions/deletions require few changes in the index</li></ul><p><br></p><p><strong>Disadvantages</strong>:</p><ul><li>Querying non-existent data still needs access to the data</li><li>Finding a data point might require bringing more blocks in memory than needed</li></ul><p><br></p><h2 id="primary-dense-block-indexes"><strong>Primary dense block indexes</strong></h2><p>Does the same as the primary sparse block index, but then points to every record</p><p><br></p><p><strong>Advantages</strong></p><ul><li>Existence of records can easily be checked</li></ul><p><br></p><p><strong>Disadvantages</strong></p><ul><li>Requires more space than a sparse index</li><li>Require more updates on insertion/deletion</li></ul><p><br></p><h2 id="secondary-indexes"><strong>Secondary indexes</strong></h2><p>Secondary indexes point to locations of records regarding a non-ordering attribute</p><ul><li>Indexing does not affect the storage order</li><li>There can be multiple secondary indexes for the same DB file</li></ul><p><br></p><p>Secondary indexes are usually dense</p><ul><li>Objects with same or adjacent value are usually not adjacent on disk</li><li>If the indexing field has unique values, all records have to be indexed</li></ul><p><br></p><h2 id="what-if-index-is-too-big?"><strong>What if index is too big?</strong></h2><ul><li>Binary search is possible</li><li>If indexes span multiple DB blocks: <span class="ql-formula" data-value="O\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> blocks need to be read from disk with <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> blocks</li></ul><p><br></p><h2 id="index-structures">Index structures</h2><p>A good index structure should support queries as efficient as possible, avoid block access to secondary storage wherever possible.</p><p><br></p><p>We use different index types for different queries:</p><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>Single Equality Condition</strong>: for example <code>WHERE x=5</code></li>
</ul>
</div><div style="white-space: normal;" class="markdown-body"><ul>
<li>Questions to ask: does it exist and if so, where?</li>
<li>Hash indexes and B+ Trees do well</li>
<li><strong>Range Conditions</strong>: for example <code>WHERE x&gt;5 AND x&lt;42</code>
<ul>
<li>Traverse indexes efficiently</li>
<li>B+ Trees do well</li>
</ul>
</li>
</ul>
</div><p><br></p><h2 id="hash-indexes"><strong>Hash indexes</strong></h2><ul><li>Fixed-size directly addressable index space <span class="ql-formula" data-value="\left[0\dots M\right]">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>0</mn><mo>…</mo><mi>M</mi><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[0\dots M\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span class="mclose delimcenter" style="top: 0em;">]</span></span></span></span></span></span>﻿</span> containing <span class="ql-formula" data-value="M+1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> buckets</li><li class="ql-indent-1">Buckets contain links to data</li><li class="ql-indent-1">Single link in internal hashing (memory)</li><li class="ql-indent-1">Multiple links for external hashing (harddisk)</li></ul><p><br></p><ul><li>Hash function <span class="ql-formula" data-value="h:\ \mathbb{Z}\to\left[0\dots M\right]">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>:</mo><mtext>&nbsp;</mtext><mi mathvariant="double-struck">Z</mi><mo>→</mo><mrow><mo fence="true">[</mo><mn>0</mn><mo>…</mo><mi>M</mi><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">h:\ \mathbb{Z}\to\left[0\dots M\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mspace">&nbsp;</span></span><span class="base"><span class="strut" style="height: 0.68889em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span class="mclose delimcenter" style="top: 0em;">]</span></span></span></span></span></span>﻿</span> (read more on these <a href="https://cshub.nl/post/18228403" target="_blank">here</a>)</li></ul><p><br></p><p><img src="https://i.imgur.com/D8AX3EI.png" width="331"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><h2 id="b+-trees"><strong>B+-Trees</strong></h2><p>We use B+-trees as they are optimized for blocks</p><p><br></p><p><strong>Structure</strong></p><ul><li>Index blocks are organized into a tree</li><li>The tree is balanced</li><li>Every block holds up to <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> search keys</li><li>Every blocks holds up to <span class="ql-formula" data-value="n+1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> pointers to the record in the block</li><li><span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> will be as large as possible, with respect to block size</li></ul><p><br></p><p><strong>Definition</strong></p><ul><li>Keys in the leaves are keys from the data (sorted across all leaves)</li><li>Root: at least two pointers used (all pointers point to B+-tree block one level below)</li><li>Leaves: last pointer points to leaf on the right</li><li>Inner nodes: pointers point to B+-tree blocks of level below</li></ul><p><br></p><p><strong>Keys and pointers</strong></p><ul><li><strong>All nodes</strong>: at most <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> keys and <span class="ql-formula" data-value="n+1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> pointers</li><li><strong>Root</strong>: at least <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> key and <span class="ql-formula" data-value="2">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span>﻿</span> pointers</li><li><strong>Inner nodes</strong>: at least <span class="ql-formula" data-value="\lceil\left(n+1\right)/2\rceil">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mrow><mo fence="true">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow><mi mathvariant="normal">/</mi><mn>2</mn><mo>⌉</mo></mrow><annotation encoding="application/x-tex">\lceil\left(n+1\right)/2\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌈</span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌉</span></span></span></span></span>﻿</span> pointers (for this example, this result is <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span>) and <span class="ql-formula" data-value="p-1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7777700000000001em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> keys.</li><li><strong>Leaves</strong>: 1 pointer to next leaf + at least <span class="ql-formula" data-value="\lfloor\left(n+1\right)/2\rfloor">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mrow><mo fence="true">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow><mi mathvariant="normal">/</mi><mn>2</mn><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\left(n+1\right)/2\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span></span>﻿</span> further pointers = <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span> pointers and <span class="ql-formula" data-value="p-1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7777700000000001em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> keys</li></ul><p><br></p><p><strong>Getting a range from B+-tree</strong></p><p>If we have a range, search for the leaf where that range starts and retrieve all the blocks until the upper value of the range is reached</p><p><br></p><p><strong>Insertion</strong></p><ul><li>Search corresponding leaf, if room, insert</li><li>If no room: overflow, split leaf in two parts and distribute equally</li><li>Split requires inserting a new key/pointer pair in parent node: recursively ascend the tree</li><li>If no space in root: split root and create new one with only 1 key</li></ul><p><br></p><p>The cost of insertion depends:</p><ul><li>Let <span class="ql-formula" data-value="h">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span></span></span></span></span>﻿</span> be the height, (often) in practice, <span class="ql-formula" data-value="h=3">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">h=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span></span></span></span></span>﻿</span> </li><li>Search for leaf node: <span class="ql-formula" data-value="O\left(h\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>h</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(h\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">h</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> </li><li>If no split needed: <span class="ql-formula" data-value="O\left(h+1\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>h</mi><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(h+1\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> </li><li>If split needed, worst case: ascend to root, so then <span class="ql-formula" data-value="O\left(3\left(h+1\right)\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mn>3</mn><mrow><mo fence="true">(</mo><mi>h</mi><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(3\left(h+1\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord">3</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> </li></ul><p><br></p><h2 id="multidimensional-indexes">Multidimensional indexes</h2><p><strong>Types of queries</strong></p><ul><li><strong>Point queries</strong>: retrieve all records with a specific <span class="ql-formula" data-value="X">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07847em;" class="mord mathdefault">X</span></span></span></span></span>﻿</span></li><li><strong>Partial queries</strong>: retrieve all records with only some of the dimensions restricted</li><li><strong>Range queries</strong>: retrieve all records where some value is between an upper and lower boundary</li><li class="ql-indent-1">Index all dimensions, building a B+-tree on <span class="ql-formula" data-value="X">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07847em;" class="mord mathdefault">X</span></span></span></span></span>﻿</span>, retrieve correct values for <span class="ql-formula" data-value="X">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07847em;" class="mord mathdefault">X</span></span></span></span></span>﻿</span> and remove false positives</li><li><strong>Nearest Neighbor queries: </strong>retrieve the nearest point to other point</li><li class="ql-indent-1">Index all dimensions and use Pythagoras' Theorem in the query or </li><li class="ql-indent-1">Find all points within a square around the point (easier to calculate), if a point is found, extend a bit more (as the found point might be further away then another point)</li></ul><p><br></p><p><strong>Multiple-Key indexes</strong></p><ul><li>Index on indexes, nodes on every level are indexes on single attributes. </li><li>If you found the value you are looking for you go one level down to the indexes on the second attribute (subindexes)</li><li>Subindexes are much smaller</li></ul><p><br></p><p><strong>Multiple-Key indexes performance</strong></p><ul><li>Partial queries: if first attribute, great, otherwise, scan all sub indexes</li><li>Range queries: work well, if indexes support range queries well</li><li>Nearest neighbor queries: select the distance and expand using a range query</li></ul><p><br></p><h2 id="kd-trees">kd-Trees</h2><ul><li><span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span>-dimensional trees</li><li>Generalization of binary search trees for <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> dimensions</li><li>Inner nodes</li><li class="ql-indent-1">Attribute and separator that partitions values for the attributes</li><li class="ql-indent-1">Attributes alternate through levels (every level is a different attribute)</li><li class="ql-indent-1">Two pointers to children (left and right)</li><li>Leaf nodes: disk blocks with records</li></ul><p><br></p><p><strong>Insertion (see slides)</strong></p><ul><li>Search corresponding leaf</li><li>If space: insert</li><li>If no space (if the node is full, there are already <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> elements): split</li></ul><p><br></p><p><strong>Example (2d-tree)</strong></p><p><img src="https://i.imgur.com/YrrMY4O.png" width="433"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><p><strong>Types of queries</strong></p><ul><li>Partial query<strong>: </strong>Descend once of on both subtrees depending on which attribute is searched for</li><li>Range query</li><li class="ql-indent-1">Good luck: complete range on one side of the node value</li><li class="ql-indent-1">Bad luck: range covers node value</li><li>Nearest neighbor query: same as range query</li></ul><p><br></p><p><strong>kd-Trees on disk</strong></p><ul><li>Assumption: 3 inner nodes per block</li><li>Merge together nodes on the same block</li></ul>