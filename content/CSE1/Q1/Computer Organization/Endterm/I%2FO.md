+++
title = "I/O"
date = 2018-11-06
+++
<h2>I/O</h2><ul><li><span style="background-color: transparent; color: rgb(0, 0, 0);">IO interface:</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Data registers to store incoming and outgoing data</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Status and control registers to certify status of devices and to control transfer</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Address decoder to detect if data is for this device</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">A CPU has a status register (PS) </span>which contains information about its current state of operation, including interrupt data</li></ul><p><br></p><ul><li><span style="background-color: transparent; color: rgb(0, 0, 0);">A typical motherboard:</span></li><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Northbridge </strong><span style="background-color: transparent; color: rgb(0, 0, 0);">(memory controller hub): High performance devices</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Memory, PCIe, CPU</span></li><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Southbridge </strong><span style="background-color: transparent; color: rgb(0, 0, 0);">(IO controller hub): Low performance devices</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">PCI Bus, USB, onboard graphics, ethernet etc</span></li></ul><p><br></p><ul><li><span style="background-color: transparent; color: rgb(0, 0, 0);">Types of buses:</span></li><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Synchronous bus</strong></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Perfect synchronization across all devices</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Instantaneous transitions</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">In reality there are many delays, so there are delays between the clock being high and devices putting data on the bus</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Propagation delay (wires)</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Setup time (gate delays)</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Drawbacks: slow as it is as fast as the slowest IO device</span></li></ul><p><br></p><ul><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Multi-cycle bus</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: Handle device variability, if device not ready within one clock cycle it has to send a secondary ready signal so the CPU knows when itâ€™s done.</span></li></ul><p><br></p><ul><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Asynchronous bus</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: Explicit handshaking (vs. synchronous clock): the CPU needs to tell the IO device that is has data for it. Timing must account for signal propagation delay/skew (the delay between primary ready signal and the signal on the bus). This happens in the following cycles:</span></li><li class="ql-indent-2">0: the master places the target address and command on the bus and slaves decode that address</li><li class="ql-indent-2">1: master sets master-ready to 1 to tell everyone it's ready</li><li class="ql-indent-2">2: the slave performs the operation and places its data on the bus. Then sets its slave-ready to 1</li><li class="ql-indent-2">3: the slave-ready arrives at the master and it loads the data into its register. Then drops the master-ready</li><li class="ql-indent-2">4: master removes the address and command from the bus</li><li class="ql-indent-2">5: when the slave notices the change it drops the slave-ready and data from the bus</li><li class="ql-indent-2">There are some delays to allow for skew on the bus, which occurs when two simultaneously transmitted signals arrive at a destination at different times as different bus lines may have different propagation speeds.</li></ul><p><br></p><ul><li class="ql-indent-1"><strong>Arbitration: </strong>Sometimes multiple entities want to get access to a slave. Then an arbiter circuit is used where each device sends a request and one of them (the one with the highest priority) will get a grant so it can access the slave. </li></ul><p><br></p><ul><li><strong>Program-controlled I/O: </strong>A program is written to do specific I/O tasks</li><li class="ql-indent-1">It can use a signaling protocol with a status flag. The CPU polls the I/O device for this status flag, and when it is set, it tries to read the data.</li></ul><p><br></p><ul><li><strong style="background-color: transparent; color: rgb(0, 0, 0);">Port-mapped I/O</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: Use separate memory space for I/O devices</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Uses special instructions to interact with this separate memory space</span></li></ul><p><br></p><ul><li><strong style="background-color: transparent; color: rgb(0, 0, 0);">Memory-mapped I/O</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: Map I/O devices to region in main memory</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Uses existing instructions to move data to/from device</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Assign an address range to each I/O device</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Use normal instructions to access device registers</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Ways for waiting for data:</span></li><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Use status registers and busy waiting</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">; naive implementation of reading from I/O device. Keep checking for new data</span></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Unconditional I/O</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">; no synchronization with I/O device</span></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Passive signaling (polling)</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">; synchronization between CPU and I/O device by programmed interrogation by CPU</span></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Active signaling (interrupts)</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">; synchronization between CPU and I/O device by active interrupting the CPU on data</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">At random times the CPU gets an interrupt, which it must handle (</span><em style="background-color: transparent; color: rgb(0, 0, 0);">IRQ</em><span style="background-color: transparent; color: rgb(0, 0, 0);">)</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Then the CPU stops, disables interrupts</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Device is informed of acceptance and clear </span><em style="background-color: transparent; color: rgb(0, 0, 0);">IRQ</em></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">CPU jumps to the interrupt routine (</span><em style="background-color: transparent; color: rgb(0, 0, 0);">ISR</em><span style="background-color: transparent; color: rgb(0, 0, 0);">, interrupt service routine, part of the device driver)</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Interrupts are enabled</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Return</span></li></ul><p><br></p><ul><li class="ql-indent-1"><strong>Nested interrupts</strong></li><li class="ql-indent-2">When a very important interrupt is thrown while another interrupt is being handled, it is possible to use nested interrupts</li><li class="ql-indent-2">Whether an interrupt is accepted depends on the priority that the I/O device is assigned to</li><li class="ql-indent-2">If it is allowed, the interrupts must be saved on the stack</li></ul><p><br></p><ul><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Daisy chain interrupt</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">:</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Rule out simultaneous interrupts by prioritizing devices</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Fixed order (from left to right), when inactive, pass signal on</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">The closer to the CPU, the more priority on the interrupts</span></li></ul><p><br></p><ul><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Vectored interrupts</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">:</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Interrupt vector: table that lists all the interrupt routines</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">No way to prioritize between devices</span></li></ul>