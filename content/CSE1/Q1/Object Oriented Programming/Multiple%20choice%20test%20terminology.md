+++
title = "Multiple choice test terminology"
date = 2019-09-09
+++
<p><strong><em>If you analyze old exams, there are many questions which are pretty similar or cover very similar topics. Here is a list of things that might be convenient for the midterm, sorted per category</em></strong></p><p><br></p><h2 id="methods">Methods</h2><ul><li><em>Lazy operators</em>: In Java, the &amp;&amp; and || are lazy operators. Meaning, if you have <em>statement1 &amp;&amp; statement2</em>, Java won't even check <em>statement2 </em>if <em>statement1 i</em>s false, as the outcome will be false anyway.  This can be useful with <em>null-checks</em>, in the first statement you check is an object is null. If so, Java won't even look further and you will avoid a <strong>NullPointerException </strong>when you reference a <strong>null </strong>object in the second statement. The reverse goes for <em>statement1 || statement2, </em>where <em>statement2</em> won't be checked if <em>statement1 </em>is already true. </li></ul><p><br></p><ul><li><em>Default constructor</em>: You don't have to provide a constructor. If you don't, Java will provide a default, parameterless constructor for you (probably for internal reasons as well). You can avoid the creation of this constructor by creating a private constructor yourself.</li></ul><p><br></p><ul><li><em>Formal / actual parameters: </em>When you call a method, you pass the parameters that will be used in the method. The parameters that you pass, the actual data, are called... actual parameters. The formal parameters are the parameters that are used within a method. See the following code example:</li></ul><div style="white-space: normal;" class="markdown-body"><pre data-lang="text/x-java"><code>private void doSomething(int formalParameter) {
    .... // Some code, probably using the formalParameter
}
 
// Somewhere else in your code
int actualParameter = 1;
 
// Calling the method using the actual parameter
doSomething(actualParameter); 
</code></pre>
</div><p><br></p><ul><li><em>Try-catch blocks: </em>If you are working in a <strong>try-catch(-finally)</strong> block (which contains the try statement, catch statement and optionally the finally statement), this is the order of operations when there is an error and when there is no error:</li><li class="ql-indent-1">With error:</li><li class="ql-indent-2">Try (which fails)</li><li class="ql-indent-2">Catch (optionally)</li><li class="ql-indent-2">Finally (optionally)</li><li class="ql-indent-2">Resume code after the complete block</li><li class="ql-indent-1">Without error:</li><li class="ql-indent-2">Try (which succeeds without exceptions)</li><li class="ql-indent-2">Finally (optionally)</li><li class="ql-indent-2">Resume code after the complete block</li></ul><p>		As you can see the finally block, if it exists, is called when an exception occurs and when no exception occurs. Another way to handle exceptions is by passing them on the the caller, by throwing them.</p><p><br></p><ul><li><em>Pass by value / reference: </em>To obtain access to parameters to methods, Java passes them by value. This means that when you for example call a method with an <strong>int </strong>as argument, you pass the value of the <strong>int</strong>, not a reference to the <strong>int </strong>(as <strong>int </strong>is a primitive value, <strong>Integer </strong>would work differently, as that is an object). This means that if you change this <strong>int </strong>in a method, the original <strong>int </strong>remains unchanged. Objects are <strong>reference types </strong>though, meaning that when creating an object, some memory is reserved. Then, when initializing a field with that object, you actually save the memory address of that object in a variable. So what you pass, is that variable: the reference to the object, so you still pass by value. But now, if you change the object, the reference doesn't change either, but the object value in memory does change.</li></ul><p><br></p><ul><li><em>Error / checked exception / unchecked exception: </em>An error is described by the <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html" target="_blank">JavaDoc</a> as <em>"An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions." </em>A checked exception <strong>must </strong>be caught (e.g. by throwing it or using a try-catch block), this will be checked by the compiler. An unchecked exception can be caught, but doesn't have to be.  This is up to the programmer. Unchecked exceptions are a subclass of <em>RuntimeException</em>.</li></ul><p><br></p><h2 id="threading-/-sockets">Threading / sockets</h2><ul><li><em>Sockets: </em>Sockets are a way of communicating. The client tries to connect to the server, and then the server accepts a client by calling the <em>accept() </em>method, which is part of the class <strong>ServerSocket</strong>. This is probably done in a while loop and each time a new client comes in, the server creates a new thread. This also happens because this method is blocking; it waits for a connection before anything else happens to the code, it <em>blocks </em>the thread in which it runs.</li></ul><p><br></p><ul><li><em>Runnable interface: </em>When you implement this interface, you can create a thread (see the comments on how it works):</li></ul><div style="white-space: normal;" class="markdown-body"><pre data-lang="text/x-java"><code>public class ExampleThread implements Runnable {
 
	@Override
    public void run() {
        // Do something
    }
}
 
// Somewhere else in your code
ExampleThread exampleThread = new ExampleThread();
 
//Note that start is used here, not run
new Thread(exampleThread).start(); 
</code></pre>
</div><p><br></p><ul><li><em>Synchronized: </em>If you have your application multi-threaded, it could be that multiple threads are trying to access a single class at the same time. The chance is pretty big this is not preferable, as all the threads could interfere with each other. There, the <strong>synchronized </strong>keyword comes in to play. When you mark a method method <strong>synchronized</strong>, it is only possible for one thread to access a <strong>synchronized </strong>method in that class. Non-synchronized methods can still be accessed, but if one thread (can be the "main thread") is calling a <strong>synchronized </strong>method, no other <strong>synchronized </strong>methods in that class will be called.</li></ul><p><br></p><ul><li><em>Deadlock: </em>If two threads "lock" two different objects, by calling methods with the <strong>synchronized </strong>keyword on them, everything should be fine. Something goes wrong though, when these methods try to access the other object, which is locked by the other thread. So the first thread waits for the second thread, while the second thread waits for the first thread. This is called deadlock, the only way out is to completely kill the process./</li></ul><p><br></p><h2 id="inheritance">Inheritance</h2><ul><li><em>Encapsulation: </em><strong>Encapsulation </strong>is one of the principles of object oriented programming (the others are <strong>polymorphism</strong>, <strong>inheritance</strong> and <strong>abstraction</strong>). It means that you can encapsulate fields or methods which a class consists of to the outside world. For that there are a few different modifiers (there are many more):</li><li class="ql-indent-1">Access modifiers</li><li class="ql-indent-2"><strong>private:</strong> The only place from which the method or field can be accessed from, is from its own class. </li><li class="ql-indent-2"><strong>no modifier: </strong>The places from which the method or field can be accessed are from its own class and from the package the class is in</li><li class="ql-indent-2"><strong>protected</strong>, same as the no modifier, but also accessible from subclasses (so classes extending it)</li><li class="ql-indent-2"><strong>public: </strong>accessible to all</li><li class="ql-indent-1">Other modifiers (there are many more!)</li><li class="ql-indent-2"><strong>static: </strong>this method or field is callable without initializing the class</li><li class="ql-indent-2"><strong>final</strong>: though a little different than the others, <strong>final </strong>states that a method or field can not be overriden, it is a constant.</li></ul><p><br></p><ul><li><em>Super call: </em>When you extend a class, you can call the constructor of the superclass in the constructor of the child class. The first thing in the constructor of a child class should be the call to the super class (by calling <em>super(....)). </em>Then you should initialize your own attributes, and then you can go on with whatever you want to do.</li></ul><p><br></p><ul><li><em>Overloading: </em>Overloading a method means that you have a method with the same name but different parameters. This allows for default values of parameters or some different functionality depending on the implementation.</li></ul><p><br></p><ul><li><em>Binding: </em><strong>Polymorphism </strong>is also an object oriented programming construct, which introduces "binding". There are different types of binding, static and dynamic binding:</li><li class="ql-indent-1"><strong>Static binding: </strong>when using static binding, the Java compiler knows which method to invoke, depending on the method name and signatures. So method overloading is also part of static binding, as from the parameters it becomes clear which method should actually be called</li><li class="ql-indent-1"><strong>Dynamic binding: </strong>when using dynamic binding, during runtime will be decided which method to call. It could be that you say you receive an object of type <em>Vehicle</em>, which contains the method <em>canItDrive(). </em>But you actually get an object of type <em>Car</em>, which extends <em>Vehicle. </em>The <em>Car </em>object has a different implementation of this <em>canItDrive() </em>method than the <em>Vehicle </em>object. During runtime will be decided which specific method to call (in this case you would call the <em>canItDrive() </em>method on the <em>Car</em> object). This is dynamic binding.</li></ul><p><br></p><ul><li><em>Abstract: </em><strong>Abstraction </strong>is another OOP construct. Marking a class <strong>abstract</strong> prohibits the instantiation of that class, so in order to create an instance of it you have to extend the class. You can implement some methods, and leave the implementation of other methods to the class that extends the abstract class. Those methods you should also mark abstract. The difference in comparison to an interface is that this abstract class can actually provide implementation of methods or declare fields, which is not possible in an interface.</li></ul><p><br></p><ul><li><em>Inheriting: </em><strong>Inheritance </strong>is the last OOP construct we will discuss. Java allows you to inherit (implement) from multiple interfaces and inherit (extend) from only 1 class (other languages allow multiple or use <a href="https://en.wikipedia.org/wiki/Mixin" target="_blank">mixins </a>to achieve this). When implementing an interface, you should implement all its methods and fields, when extending a class you don't have to do anything, but you can add methods or override existing methods.</li></ul><p><br></p><h2 id="events-/-mvc">Events / MVC</h2><ul><li><em>Observer &amp; Overservable: </em>These are classes which allow for MVC (Model View Controller) to be implemented in Java. An <strong>observer </strong>is an objects which wants to get updated on the change of another object's state, and an <strong>observable </strong>object is an object which has a state that can be changed. An <strong>observable </strong>notifies its <strong>observers </strong>that something changed, and they respond to that (a much better JS implementation of this is <a href="https://github.com/reactivex/rxjs" target="_blank">RxJS</a>).</li></ul><p><br></p><ul><li><em>Event Listener / Event Source: </em>When a source emits an event (e.g. a mouse click), an EventListener handles the event. Each event has a corresponding listener, which you can use to handle the input of a user.</li></ul><p><br></p><ul><li><em>EventAdapter: </em>When a listener has multiple methods in its interface, so multiple events that are being handled, you would have to implement all of them and leave most of them empty. That is a hassle, you therefore you use an Adapter class, which is provided by Java. This has all the methods implemented, empty. You just need to override them to use the functionality.</li></ul><p><br></p><h2 id="other-terms">Other terms</h2><ul><li><em>Cyclic complexity: </em>This is used to view the complexity of your program. It is the amount of independent paths through a piece of code, which shows you the least amount of tests you have to use on that method. You can calculate it by counting the amount of conditions (so if you have an if, elseif statement, there are 2 conditions), and adding 1 to it. </li></ul><p><br></p><ul><li><em>Debugging</em></li><li class="ql-indent-1"><em>Breakpoint: </em>A breakpoint is a point on which the program will stop executing temporarily. Then you can see the values of all the fields and much more, very handy indeed.</li><li class="ql-indent-1"><em>Conditional breakpoint: </em>This is a breakpoint which only stops sometimes, in a loop it is very annoying to stop each iteration if you only want to stop when a specific field has a specific value</li><li class="ql-indent-1"><em>Hit counter: </em>This is another type of conditional breakpoint, this time only stopping after having done a number of iterations</li></ul><p><br></p><ul><li><em>Internal / external quality: </em>Internal quality talks about the quality (in terms of whitespace, design, code duplication etc) of the source and test code and external quality talks about how the user experiences it (ease of use, stability)</li></ul><p><br></p><ul><li><em>Heisenbugs: </em>These bugs are bugs which seem to vanish or change when you try to discover why it went wrong. These bugs are for example present in a different order of parallel operation, which might once have run in a different order which killed the program.</li></ul><p><br></p>