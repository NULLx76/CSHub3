+++
title = "Network Layer (chapter 5)"
date = 2019-06-27
+++
<p><span>The network layer is concerned with routing packets from the source all the way to the destination. The network layer is the lowest layer that deals with end-to-end transmission. </span><span style="background-color: transparent;">Bringing a packet from the source to the destination may require making intermediate hops in between. To achieve this, it must know the </span><strong style="background-color: transparent;">topology </strong><span style="background-color: transparent;"> of the network and choose the appropriate path based on this.</span></p><p><br></p><h1 id="network-layer-design-issues"><span>Network layer design issues</span></h1><p><span>This subsection will give a quick overview to the design issues, that had to be overcome when designing this layer.</span></p><p><br></p><p><strong>Store-and-Forward packet switching: </strong><span style="background-color: transparent;">We send the packet from node to node, at each node, we store the entire packet, verify its checksum, and then it's forwarded to the next router.</span></p><p><br></p><h2 id="services-provided-to-the-transport-layer"><strong>Services provided to the transport layer</strong></h2><p><span>The network layer has to provide services to the transport layer, while keeping the following goals in mind:</span></p><ol><li><span>The services should be independent of the router technology</span></li><li><span>The transport layer should be shielded from the number, type, and topology of the routers present</span></li><li><span>The network addresses made available to the transport layer should use a uniform numbering plan, even across LANs and WANs</span></li></ol><p><br></p><p><span style="background-color: transparent;">Out of this resulted two kinds of services:</span></p><ul><li><strong style="background-color: transparent;">End-to-end service</strong><span style="background-color: transparent;"> / </span><strong style="background-color: transparent;">argument</strong><span style="background-color: transparent;">: Only primitives are SEND PACKET and RECEIVE PACKET, each packet must contain entire address. No packet ordering or flow control.</span></li><li><strong style="background-color: transparent;">Connection-oriented</strong><span style="background-color: transparent;">: Should be reliable, useful for real-time traffic.</span></li></ul><p><br></p><h2 id="implementation-of-connectionless-service"><strong>Implementation of connectionless service</strong></h2><p><span>Packets are sent in individually and independently from each other. This is called </span><strong>datagram </strong><span>network. Routers have tables with each possible address and their next destination. This table is established using a </span><strong>routing algorithm</strong><span>.</span></p><p><span><img src="https://i.imgur.com/93Cxo56.png" width="526"></span></p><p><br></p><h2 id="implementation-of-connection-oriented-service"><span style="background-color: transparent;">Implementation of connection-oriented service</span></h2><p><span style="background-color: transparent;">First, a path from the sender to the receiver is established (a </span><strong style="background-color: transparent;">virtual circuit</strong><span style="background-color: transparent;">). Each connection has a unique identifier. If multiple connections from different “wires” have the same identifier, the router can replace one of the numbers in the outgoing wire. (Label switching)</span></p><p><span><img src="https://i.imgur.com/g1CMSUO.png" width="511"></span></p><p><br></p><h2 id="comparison-of-virtual-circuit-and-datagram-networks"><span>Comparison of Virtual-Circuit and Datagram Networks</span></h2><div style="white-space: normal;" class="markdown-body"><table>
<thead>
<tr>
<th>Issue</th>
<th>Datagram network</th>
<th>Virtual-circuit network</th>
</tr>
</thead>
<tbody>
<tr>
<td>Circuit setup</td>
<td>Not needed</td>
<td>Required</td>
</tr>
<tr>
<td>Addressing</td>
<td>Each packet contains the full source and destination address</td>
<td>Each packet contains a short VC number</td>
</tr>
<tr>
<td>State information</td>
<td>Routers do not hold state information about connections</td>
<td>Each VC requires router table space per connection</td>
</tr>
<tr>
<td>Routing</td>
<td>Each packet is routed independently</td>
<td>Route chosen when VC is set up; all packets follow it</td>
</tr>
<tr>
<td>Effect of router failures</td>
<td>None, except for packets lost during the crash</td>
<td>All VCs that passed through the failed router are terminated</td>
</tr>
<tr>
<td>Quality of service</td>
<td>Difficult</td>
<td>Easy if enough resources can be allocated in advance for each VC</td>
</tr>
<tr>
<td>Congestion control</td>
<td>Difficult</td>
<td>Easy if enough resources can be allocated in advance for each VC</td>
</tr>
</tbody>
</table>
</div><p><br></p><h1 id="routing-algorithms"><span>Routing algorithms</span></h1><p><strong style="background-color: transparent;">Routing:</strong><span style="background-color: transparent;"> Filling in and updating routing tables</span></p><p><strong style="background-color: transparent;">Forwarding:</strong><span style="background-color: transparent;"> Handling each packet according to the routing table</span></p><p><br></p><h3 id="properties-of-routing-algorithms:"><strong style="background-color: transparent;">Properties of routing algorithms:</strong></h3><p><strong style="background-color: transparent;">Robustness:</strong><span style="background-color: transparent;"> Must be able to handle routers going down, topology changes, etc, without reboot.</span></p><p><strong style="background-color: transparent;">Stability:</strong><span style="background-color: transparent;"> Algorithm must reach equilibrium quickly and stay there.</span></p><p><strong style="background-color: transparent;">Fairness:</strong><span style="background-color: transparent;"> Each router must be granted a fair amount of traffic</span></p><p><strong style="background-color: transparent;">Efficiency:</strong><span style="background-color: transparent;"> Maximize total throughput. (Fairness and efficiency are often contradictory)</span></p><p><br></p><h3 id="types-of-routing:"><strong style="background-color: transparent;">Types of routing:</strong></h3><p><strong style="background-color: transparent;">Static routing: </strong><span style="background-color: transparent;">The path to each node is computed in advance and externally. Does not respond to failures. For example: send all packets to the router with IP </span><span><span class="ql-formula" data-value="x">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>﻿</span></span></p><p><strong style="background-color: transparent;">Dynamic router:</strong><span style="background-color: transparent;"> Can respond to changes in topology, and changes in traffic. </span></p><p><br></p><h2 id="optimality-principle"><span style="background-color: transparent;">Optimality principle</span></h2><p><span style="background-color: transparent;">If router <span class="ql-formula" data-value="B">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span></span></span>﻿</span> is on the optimal path between <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="C">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>﻿</span>, then the optimal path from <span class="ql-formula" data-value="B">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span></span></span>﻿</span> to <span class="ql-formula" data-value="C">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>﻿</span> is the same route.  As a direct consequence of this, the set of optimal routes from all sources to a certain destination forms a </span><strong style="background-color: transparent;">sink tree. </strong><span style="background-color: transparent;">This is not necessarily unique, if we allow all equal length paths to be chosen, we form a directed acyclic graph. </span></p><p><span><img src="https://i.imgur.com/Wrqp1Rv.png" width="505"></span></p><p><br></p><h2 id="algorithm:-shortest-path"><span style="background-color: transparent;">Algorithm: Shortest path</span></h2><p><span style="background-color: transparent;">Assumes we know the structure of the entire network. Use Dijkstra’s shortest path algorithm, given a weighted graph. We can determine the weight as the mean delay of a test packet, or just set all weights to 1.</span></p><p><br></p><h2 id="algorithm:-flooding"><span style="background-color: transparent;">Algorithm: Flooding</span></h2><p><span style="background-color: transparent;">We don’t need to know anything of the structure of the network. Extremely robust, as long as a path exists, it will be found. A packet is sent out on every line except the one it came in on. Have a hop counter in each packet and stop sending the packet if hop counter is 0. If we put a sequence number on each packet, routers don’t send out the same packet twice. If a router crashes, it loses track of sequence numbers and restarts at 0. So we need to include the age of each packet and remove it from the sequence number from our cache if age reaches 0. Effective for broadcast packets, very inefficient for a single destination.</span></p><p><br></p><h2 id="algorithm:-distance-vector-routing"><span style="background-color: transparent;">Algorithm: Distance vector routing</span></h2><p><span style="background-color: transparent;">Each router has a table with a best known distance to each address. Every so often, we ask our neighbors for their tables, and we add the distance to each neighbor to their respective tables, and then choose the minimum for each address. So if the distance metric is hops, just add 1.</span></p><p><span style="background-color: transparent;">This has the </span><strong style="background-color: transparent;">count-to-infinity problem</strong><span style="background-color: transparent;">, if a node goes down, the path to a certain node might end up in a loop. If there is no maximum distance, this will go on indefinitely.</span></p><p><span style="background-color: transparent;"><img src="https://lh5.googleusercontent.com/-2mP7lizmam9Q0oAzt27PmKoz48SulcIxXWJZlZV9ak2GCP0Fso5r4I3UyMaZmUTDgXd8Zbu56fHwQq4e_vUskOwy9ofzQkcx81zQPmSoWvIKJYtD168vZZMCxd7Pv36DOdrnv-0" height="247" width="531"></span></p><h3 id=""><br></h3><h2 id="algorithm:-link-state-routing"><span style="background-color: transparent;">Algorithm: Link state routing</span></h2><p><span style="background-color: transparent;">Variants of this are still used in the internet.</span></p><p><span style="background-color: transparent;">Steps:</span></p><ul><li><span style="background-color: transparent;">Discover your neighbours and learn its network addresses</span></li><li><span style="background-color: transparent;">Compute the distance to each </span>neighbour</li><li><span style="background-color: transparent;">Construct a packet containing everything you just learned</span></li><li><span style="background-color: transparent;">Flood the network with this packet, and receive packets from all other routers.</span></li><li><span style="background-color: transparent;">Compute the shortest path to every other router</span></li></ul><p><span style="background-color: transparent;">To handle cables with multiple routers, like a LAN, create a node for the cable and select one designated router who pretends to be the node.</span></p><p><br></p><p><strong style="background-color: transparent;">Computing the path</strong></p><p><span style="background-color: transparent;">Every link between routers is represented twice, once for each direction. Use Dijkstra’s algorithm to find the shortest path in this directional graph. (Make sure to know Dijkstra’s as it will be on the exam)</span></p><p><br></p><p><span style="background-color: transparent;">The biggest problem with this algorithm is that a single malicious router (or broken router) can break the entire algorithm. It also requires a lot of memory and computational power.</span></p><p><br></p><h3 id="algorithm:-hierarchical-routing"><span style="background-color: transparent;">Algorithm: Hierarchical routing</span></h3><p><span style="background-color: transparent;">We don’t want to flood the entire internet with a packet once a single router comes up. Instead, all routers are divided into regions. Link state routing is used within each region. For large networks, it may be necessary to group the regions into clusters, the clusters into zones, the zones into groups, and so on. The optimal size of the hierarchy is <span class="ql-formula" data-value="\ln\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ln</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ln\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>, with <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> being the number of routers. This requires <span class="ql-formula" data-value="e\cdot\ln\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>⋅</mo><mi>ln</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">e\cdot\ln\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.44445em; vertical-align: 0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> entries per router.</span></p><p><br></p><p><span style="background-color: transparent;">All routers outside of a region are condensed into a single “virtual” router. This decreases the efficiency of paths slightly, but has enormous space and computation speed gains.</span></p><p><span style="background-color: transparent;"><img src="https://lh5.googleusercontent.com/jcGJgs7KkXjpZSv-wyu_g81yBP9LVQAGcFC7Lx-ylPG1FbL8CZD8unfv-EkHj6DItvP9rOlJz0nQ_MTgq1IwW-rg--b7SLUUF3JcM6u-2v0Xoi-Ksrr2lu7twUdiylS6XQWTfBjm" height="267" width="281"></span></p><p><br></p><h1 id="congestion-control-algorithms"><span>Congestion control algorithms</span></h1><p><strong style="background-color: transparent;">Congestion:</strong><span style="background-color: transparent;"> Packet delay because there are too many packets in a network. The responsibility of handling congestion is shared between the transport and network layer. </span><strong style="background-color: transparent;">Congestion control </strong><span style="background-color: transparent;">is global traffic control and </span><strong style="background-color: transparent;">flow control </strong><span style="background-color: transparent;">is traffic control over a single link (point to point traffic).</span></p><p><br></p><p><span style="background-color: transparent;">The most effective way to decrease congestion in both cases is to make the host send fewer packets. This is because congestion is not linear, sending 10% less packets can decrease delay by a lot.</span></p><p><span style="background-color: transparent;"><img src="https://lh3.googleusercontent.com/vJt-5eEAWGy7tEZKyfUt6y6VygaHgeKQx1DB-jIaZseYGg-MrlTGplArEGcWKyF9RhHrK_g-C-MUpJThOnfWTDuOViv1Lh3icmhQfdrMfjZKuh9MugL6bWaMKRMl9OdVSpcF1psN" height="223" width="365"></span></p><p><strong style="background-color: transparent;">Goodput:</strong><span style="background-color: transparent;"> Amount of useful packets delivered per second. We want to stay in the gray area.</span></p><p><br></p><h2 id="approaches-to-congestion-control"><span>Approaches to congestion control</span></h2><p><strong style="background-color: transparent;">Network provisioning</strong><span style="background-color: transparent;">: Building faster networks</span></p><p><strong style="background-color: transparent;">Traffic-aware routing:</strong><span style="background-color: transparent;"> Routing based on where congestion occurs</span></p><p><strong style="background-color: transparent;">Admission control:</strong><span style="background-color: transparent;"> Temporarily refusing new connections</span></p><p><strong style="background-color: transparent;">Traffic throttling:</strong><span style="background-color: transparent;"> Slowing down problematic connections</span></p><p><strong style="background-color: transparent;">Load shedding:</strong><span style="background-color: transparent;"> Discard packets you can’t deliver</span></p><p><span style="background-color: transparent;"><img src="https://lh6.googleusercontent.com/xatQElOfmoZBFSnzcJPp-9LlUG8OSIbVqLRWV1Jv5FNuaaJ2LGVjGyjcoXffLKc0Y0-97q3hNkzmefrZunz7KweKTK619R2ySGPli3gbWNCuXSiQoMEX8393l65FgbXLQsiceCvq" width="585" height="157"></span></p><p><br></p><h2 id="traffic-aware-routing"><span>Traffic-aware routing</span></h2><p><span style="background-color: transparent;">Include queuing delay when computing best routes. Link weight is a function of load and propagation delay. This was used in the early internet, but it tends to oscillate between paths rather than coming to an equilibrium. Attempts to reduce the influence of load only slow down oscillations. Instead, ignore load and only consider propagation delay and bandwidth.</span></p><p><br></p><h2 id="admission-control"><span>Admission control</span></h2><p><span style="background-color: transparent;">In a virtual-circuit network, we remove nodes from the network during path searching, if the nodes are congested. If this causes the network to become disconnected, then the network is overloaded so setting up new connections should temporarily not be allowed. This is better than the alternative of having a congested network. Estimating bandwidth is hard because traffic often comes in bursts, average rate is not good enough. </span></p><p><br></p><h2 id="traffic-throttling"><span>Traffic throttling</span></h2><p><span style="background-color: transparent;">Normally, senders adjust their traffic to send as much traffic as the network can deliver. When congestion is imminent, the network must tell the senders to slow down. This is called </span><strong style="background-color: transparent;">congestion avoidance</strong><span style="background-color: transparent;">.</span></p><p><br></p><p><span style="background-color: transparent;">Each router monitors the resources it is using: </span></p><ul><li><span style="background-color: transparent;">Congestion of the output link (too sensitive to bursts)</span></li><li><span style="background-color: transparent;">Size of the packet buffer (most useful)</span></li><li><span style="background-color: transparent;">Number of packets that are lost due to insufficient buffering (too late)</span></li></ul><p><br></p><p><span style="background-color: transparent;">Implementations of “telling senders to slow down”:</span></p><ul><li><strong style="background-color: transparent;">Choke packets: </strong><span style="background-color: transparent;">Send a “choke packet” back to the source host (the initial packet is then tagged so that it generates no more choke packets). If we pick random packets, the fastest host is more likely to receive choke packets. Also because of this, hosts should ignore choke packets for a specific time after receiving one.</span></li><li><strong style="background-color: transparent;">Explicit congestion notification (ECN): </strong><span style="background-color: transparent;">Two bits in the IP packet are used to signal that the packet has experienced congestion. The destination will then send the marks back to the sender with its next reply. This is used in the internet.</span></li><li><strong style="background-color: transparent;">Hop-by-hop backpressure: </strong><span style="background-color: transparent;">At high speeds or over long distances, many packets may be sent before the sender receives the congestion notification. Instead, we slow down a single link, which causes the previous link to become congested too. This will propagate back to the source.</span></li></ul><h2 id=""><br></h2><h2 id="load-shedding"><span>Load shedding</span></h2><p><span style="background-color: transparent;">A worst case solution. If routers get packets that they can’t handle, and nothing else helps, just throw them away. But which packets to throw away?</span></p><ul><li><span style="background-color: transparent;">For a file transfer, an old packet is more useful than a new one. (Called </span><strong style="background-color: transparent;">wine</strong><span style="background-color: transparent;">)</span></li><li><span style="background-color: transparent;">For real time media, a new packet is more useful than an old one. (Called </span><strong style="background-color: transparent;">milk)</strong></li></ul><p><br></p><p><span style="background-color: transparent;">Some packets may also be more important than others, e.g. a routing packet. So, we mark packets with their priority and drop the least important ones.</span></p><p><br></p><h3 id="random-early-detection-(red)"><strong style="background-color: transparent;">Random early detection (RED)</strong></h3><p><span style="background-color: transparent;">If the buffer is close to getting full, but not entirely full, we can throw away packets at random. If we do this without any congestion avoidance, senders can still know that they are sending data too fast because they never receive an acknowledgement. Senders will slow down when they lose packets, thus avoiding a buffer overrun. We will pick packets at random, so faster senders are more likely to be dropped. </span></p><p><span style="background-color: transparent;">ECN is better than RED, but ECN is not always available (some hosts don’t support it).</span></p><p><br></p><h1 id="quality-of-service"><span>Quality of Service</span></h1><p><span>In order to provide good quality of service, we can use </span><strong>overprovisioning, </strong><span>i.e. provisioning (allocating) more hardware than is strictly necessary.  But that is expensive, there are four key issues to be addressed in order to provide good quality of service:</span></p><ol><li><span>What applications need from the network</span></li><li><span>How to regulate the traffic that enters the network</span></li><li><span>How to reserve resources at routers to guarantee performance</span></li><li><span>Whether the network can safely accept more traffic</span></li></ol><p><br></p><h2 id="application-requirements"><span>Application requirements</span></h2><p><strong>Flow: </strong><span>A stream of packets from source to destination</span></p><p><strong style="background-color: transparent;">Delay:</strong><span style="background-color: transparent;"> Time it takes to get from source to target destination</span></p><p><strong style="background-color: transparent;">Jitter:</strong><span style="background-color: transparent;"> Variation in delay</span></p><p><strong style="background-color: transparent;">Packet loss:</strong><span style="background-color: transparent;"> Percentage of packets being dropped</span></p><p><strong style="background-color: transparent;">Bandwidth:</strong><span style="background-color: transparent;"> Maximum data rate, bits/s</span></p><p><br></p><h3 id="types-of-qos"><span style="background-color: transparent;">Types of QoS</span></h3><ul><li><strong style="background-color: transparent;">Constant bit rate: </strong><span style="background-color: transparent;">Useful for telephony</span></li><li><strong style="background-color: transparent;">Real-time variable bit rate: </strong><span style="background-color: transparent;">Useful for compressed video conferencing</span></li><li><strong style="background-color: transparent;">Non-real-time variable bit rate: </strong><span style="background-color: transparent;">Useful for watching a movie on demand</span></li><li><strong style="background-color: transparent;">Available bit rate: </strong><span style="background-color: transparent;">Useful for file transfers</span></li></ul><p><br></p><h2 id="traffic-shaping"><span>Traffic shaping</span></h2><p><span style="background-color: transparent;">To give guarantees on good QoS, the network needs to be able to control traffic. In order to do this, the user and the provider of the network need to agree on a traffic pattern. This is called </span><strong style="background-color: transparent;">traffic shaping</strong><span style="background-color: transparent;">.</span></p><p><br></p><h3 id="leaky-bucket"><strong style="background-color: transparent;">Leaky bucket</strong></h3><p><span style="background-color: transparent;">Each host is connected to the network using a ‘leaky bucket’. The output of the bucket is constant, either the ‘size of the hole’ or 0, if there is no data. Using this leaky bucket we can convert an uneven flow of packets into an even one. If the bucket is full, we need to discard the packet, or cache it somewhere in the OS.</span></p><p><br></p><p><span>However, for many applications, it is better to allow the output to speed up somewhat when large bursts arrive.&nbsp; </span><span style="background-color: transparent;">We can also imagine a bucket being filled with tokens (aka packets) at a constant rate, and to send packets we must take the tokens out of the bucket. This is called a </span><strong style="background-color: transparent;">token bucket </strong><span style="background-color: transparent;">and is equivalent to a leaky bucket.</span></p><p><br></p><p><span style="background-color: transparent;">Both allow short-term bursts, but limit the long-term rate. The bucket shapes the traffic to be less bursty and prevents overflowing the caches of routers.</span></p><p><br></p><h1 id="internetworking"><span>Internetworking</span></h1><p><span style="background-color: transparent;">This deals with packets having to go over different types of networks. The </span><strong style="background-color: transparent;">Internet</strong><span style="background-color: transparent;"> is the major interconnected network on earth. The layer where this is challenging is in the network layer, where we for example switch from connectionless to connection-oriented connection.</span></p><p><br></p><h2 id="how-networks-differ"><span>How networks differ</span></h2><div style="white-space: normal;" class="markdown-body"><table>
<thead>
<tr>
<th>Item</th>
<th>Some Possibilities</th>
</tr>
</thead>
<tbody>
<tr>
<td>Service offered</td>
<td>Connectionless versus connection oriented</td>
</tr>
<tr>
<td>Addressing</td>
<td>Different sizes, flat or hierarchical</td>
</tr>
<tr>
<td>Broadcasting</td>
<td>Present or absent (also multicast)</td>
</tr>
<tr>
<td>Packet size</td>
<td>Every network has its own maximum</td>
</tr>
<tr>
<td>Ordering</td>
<td>Ordered and unordered delivery</td>
</tr>
<tr>
<td>Quality of service</td>
<td>Present or absent; many different kinds</td>
</tr>
<tr>
<td>Reliability</td>
<td>Different levels of loss</td>
</tr>
<tr>
<td>Security</td>
<td>Privacy rules, encryption, etc.</td>
</tr>
<tr>
<td>Parameters</td>
<td>Different timeouts, flow specifications, etc.</td>
</tr>
<tr>
<td>Accounting</td>
<td>By connect time, packet, byte, or not at all</td>
</tr>
</tbody>
</table>
</div><h2 id="how-networks-can-be-connected"><span>How networks can be connected</span></h2><p><span style="background-color: transparent;">We created a transport layer (the IP protocol) as a common layer for all networks. Because different networks may have different addresses, we use IP addresses as a common ground.</span></p><p><br></p><p><span style="background-color: transparent;">A </span><strong style="background-color: transparent;">bridge</strong><span style="background-color: transparent;">, which is a router that interconnects networks, may have different address tables for different networks, and know where to go based on the IP address. We now have problems with IPv4 vs IPv6, because there are 2 different transport layers in the same network. </span><span>A router that can handle multiple network protocols is called a </span><strong>multiprotocol </strong><span>router. It must either translate the protocols, or leave connection for a higher protocol layer.&nbsp;</span></p><p><br></p><h2 id="tunneling"><span>Tunneling</span></h2><p><span style="background-color: transparent;">This is a special case of interconnecting where the source and destination are on the same type of network, but there is a different type in between.</span></p><p><br></p><p><span><img src="https://i.imgur.com/rG9CM3H.png" width="506"></span></p><p><span style="background-color: transparent;">We can wrap the packet inside the type of packet of the intermediate network. We often use this to develop a network with a new feature, like IPv6 in the picture above.</span></p><p><br></p><h2 id="internetwork-routing"><span>Internetwork routing</span></h2><p><span style="background-color: transparent;">Networks may internally use different routing algorithms. The weights across the internet will not be well defined, so shortest paths will not be well-defined. To fix this, we will use a </span><strong style="background-color: transparent;">interdomain gateway protocol </strong><span style="background-color: transparent;">(a gateway is an older word for a router). Since each network is then separate from the others, it is referred to as an </span><strong style="background-color: transparent;">Autonomous Network (AS)</strong><span style="background-color: transparent;">. In the internet, this protocol is called the </span><strong style="background-color: transparent;">Border Gateway Protocol</strong><span style="background-color: transparent;">.</span></p><p><br></p><h2 id="packet-fragmentation"><span>Packet fragmentation</span></h2><p><span style="background-color: transparent;">Packet sizes in different networks are limited by hardware, OSes, protocols, standards, law, the desire to reduce error-induced re-transmissions, preventing one packet from occupying the network for too long, etc. In order to fix this, we want to be able to split up packets and break them into </span><strong style="background-color: transparent;">fragments</strong><span style="background-color: transparent;">.</span></p><p><br></p><p><span style="background-color: transparent;">To re-combine packets, two opposing strategies exist:</span></p><ul><li><strong style="background-color: transparent;">Transparent fragmentation: </strong><span style="background-color: transparent;">Break the packets in the middle network and recombine them at the end. For this the end router needs to know when all packets arrived, so we need a ‘end of packet’ bit or a packet count.</span></li><li><strong style="background-color: transparent;">Non-transparent fragmentation: </strong><span style="background-color: transparent;">Keep the packets broken up after re-entering the end network. We need to number packets in such a way that the receiver can reconstruct the end message.</span></li></ul><p><br></p><p><span><img src="https://i.imgur.com/fh57scG.png" width="491"></span></p><p><span style="background-color: transparent;">Disadvantages:</span></p><ul><li><span style="background-color: transparent;">If packets are repeatedly split, this can cause quite a large overhead from all the extra headers that are carried.</span></li><li><span style="background-color: transparent;">Fragments are detrimental to performance, because if one fragment is lost, all packets are lost.</span></li></ul><p><br></p><h3 id="mtu-discovery"><strong style="background-color: transparent;">MTU Discovery</strong></h3><p><span style="background-color: transparent;">Instead of fragmenting, we send an ‘error’ packet back to the sender, requesting them to split up the packet into smaller ones. The sender then sends the smaller packets. The advantage is that the sender now knows the right size of packets to send, the disadvantage is that there is extra startup delay. </span></p><p><br></p><h1 id="network-layer-in-the-internet"><span>Network layer in the internet</span></h1><h3 id="the-top-10-principles-in-designing-the-ip-protocol:"><span>The top 10 principles in designing the IP protocol:</span></h3><ol><li><strong style="background-color: transparent;">Make sure it works, </strong><span style="background-color: transparent;">do not finalize design until it has proven to work</span></li><li><strong style="background-color: transparent;">Keep it simple, </strong><span style="background-color: transparent;">Occam’s razor, the simplest solution is most often the correct one</span></li><li><strong style="background-color: transparent;">Make clear choices, </strong><span style="background-color: transparent;">use only one solution</span></li><li><strong style="background-color: transparent;">Exploit modularity, </strong><span style="background-color: transparent;">have multiple protocol stacks which work independently of each other</span></li><li><strong style="background-color: transparent;">Expect heterogeneity,</strong><span style="background-color: transparent;"> network should be flexible for different types of hardware</span></li><li><strong style="background-color: transparent;">Avoid static options and parameters, </strong><span style="background-color: transparent;">negotiate instead of having fixed values</span></li><li><strong style="background-color: transparent;">Look for a good design; it doesn’t need to be perfect, </strong><span style="background-color: transparent;">put the burden on people with strange requirements</span></li><li><strong style="background-color: transparent;">Be strict when sending and tolerant when receiving, </strong><span style="background-color: transparent;">send packets that comply with the standards but be lenient when receiving</span></li><li><strong style="background-color: transparent;">Think about scalability</strong></li><li><strong style="background-color: transparent;">Consider performance and cost</strong></li></ol><p><br></p><h3 id="how-it-works"><span style="background-color: transparent;">How it works</span></h3><p><span style="background-color: transparent;">The transport layer takes the datastream and breaks it up into packets of up to 64KB each (although they are often 1500B to fit into an ethernet frame). </span></p><p><br></p><p><span style="background-color: transparent;">In the internet there is a lot more redundancy than visible in the following image:</span></p><p><br></p><p><span><img src="https://i.imgur.com/qnQREwa.png" width="506"></span></p><p><br></p><h2 id="ipv4"><span>IPv4</span></h2><p><span style="background-color: transparent;">The protocol is big endian (highest order bit first), where Intel x86 is little endian, so numbers need to be converted often. In retrospect, little endian would’ve been better, but it’s too late to change it now.</span></p><p><br></p><h3 id="fields"><strong style="background-color: transparent;">Fields</strong></h3><p><span><img src="https://i.imgur.com/811vSHT.png" width="583"></span></p><ul><li><strong style="background-color: transparent;">Version: </strong><span style="background-color: transparent;">Here version 4, by storing it at the front, we can switch the layout of the other fields around easily. </span></li><li><strong style="background-color: transparent;">IHL: </strong><span style="background-color: transparent;">Amount of 32 bit words in header, between <span class="ql-formula" data-value="5">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="15">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span></span>﻿</span>. </span></li><li><strong style="background-color: transparent;">Differentiated Services: </strong><span style="background-color: transparent;">Top 6 bits are used to tell the service class (Do we care about delay or speed), bottom 2 are used for congestion notifications.</span></li><li><strong style="background-color: transparent;">Total length: </strong><span style="background-color: transparent;">Length of header + data, max <span class="ql-formula" data-value="65535">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>65535</mn></mrow><annotation encoding="application/x-tex">65535</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">5</span></span></span></span></span>﻿</span> bytes.</span></li><li><strong style="background-color: transparent;">Identification:</strong><span style="background-color: transparent;"> Allows destination to determine to which packet the fragment belongs to.</span></li><li><a href="https://en.wikipedia.org/wiki/Evil_bit" target="_blank" style="background-color: transparent;"><strong><em>Unused bit</em></strong></a></li><li><strong style="background-color: transparent;">Don’t fragment bit:</strong><span style="background-color: transparent;"> When bit is set to <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>, the packet will never be fragmented further, and instead a error packet is sent. Useful in MTU discovery.</span></li><li><strong style="background-color: transparent;">More fragments bit: </strong><span style="background-color: transparent;">All fragments except the last have this bit set to <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>.</span></li><li><strong style="background-color: transparent;">Fragment offset:</strong><span style="background-color: transparent;"> Where in the current packet this fragment belongs. All fragments must be multiples of 8 bytes except for the last one. </span></li><li><strong style="background-color: transparent;">Time to live (TTL):</strong><span style="background-color: transparent;"> Amount of hops the packet has left to live. Decremented each hop. Packet is discarded and a warning is sent to the source when this hits <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span>. (In theory in seconds, in practice number of hops. In IPv6 it is called the hop limit to reflect this)</span></li><li><strong style="background-color: transparent;">Protocol: </strong><span style="background-color: transparent;">The protocol contained in the data. TCP and UDP are possibilities, there exists database of all numbers available. </span></li><li><strong style="background-color: transparent;">Header checksum:</strong><span style="background-color: transparent;"> Checksum for only the header. Add up all 16 bit words using one’s complement, then take the one’s complement of the result. Must be recomputed after every hop because time to live changes.</span></li><li><strong style="background-color: transparent;">Source address:</strong><span style="background-color: transparent;"> IP address of the source</span></li><li><strong style="background-color: transparent;">Destination address:</strong><span style="background-color: transparent;"> IP address of the destination</span></li><li><strong style="background-color: transparent;">Options:</strong><span style="background-color: transparent;"> Allows subsequent versions to add extra data to the header, and for experimenters to try new ideas. Also to avoid allocating header bits for rarely used data. Each begins with a <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>-byte code identifying the option, and are variable length. Should be padded out to be a multiple of 32 bytes.</span></li></ul><p><br></p><p><span><img src="https://i.imgur.com/kE8Nyyr.png" width="471"></span></p><p><br></p><h2 id="ip-addresses"><span>IP addresses</span></h2><p><span style="background-color: transparent;">IPv4 addresses are 32-bit number that uniquely identifies a network interface. Note that if a host is on 2 different networks, it will have 2 different IPs. Routers have multiple interfaces, so they have multiple IPs. They are written in </span><strong style="background-color: transparent;">dotted decimal notation</strong><span style="background-color: transparent;">, for example <span class="ql-formula" data-value="128.208.2.151">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128.208.2.151</mn></mrow><annotation encoding="application/x-tex">128.208.2.151</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mord">.</span><span class="mord">2</span><span class="mord">0</span><span class="mord">8</span><span class="mord">.</span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span><span class="mord">1</span></span></span></span></span>﻿</span></span></p><p><br></p><p><span style="background-color: transparent;">IPs are hierarchical, which means that each network has its own continuous block of IP addresses. The size of the host part is determined by the amount of bits that is used to identify the network. Since this can not be inferred from the address, routing protocols must contain this information. When written out such that the network part are <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>s, it is called the </span><strong style="background-color: transparent;">subnet mask. </strong><span style="background-color: transparent;">(See picture below)</span></p><p><span><img src="https://i.imgur.com/spzXpR6.png" width="467"></span></p><h3 id="advantages-&amp;-disadvantages"><strong style="background-color: transparent;">Advantages &amp; disadvantages</strong></h3><ul><li><span style="background-color: transparent;">The key advantage of this hierarchical model is that the place to forward the packet to can be determined by only the network portion. This significantly decreases the amount of addresses that a router has to store.</span></li><li><span style="background-color: transparent;">The first disadvantage is that your IP address will change if you change your network, so your IP address will change if you move around.</span></li><li><span style="background-color: transparent;">The second disadvantage is that the hierarchy is wasteful unless it is carefully managed. If the addresses are assigned to networks in too large blocks, there will be too many allocated addresses that are not in use. This is a major problem in the internet, which IPv6 fixes.</span></li></ul><p><br></p><h3 id="cidr---classless-interdomain-routing"><strong style="background-color: transparent;">CIDR - Classless InterDomain Routing</strong></h3><p><span style="background-color: transparent;">We can use </span><strong style="background-color: transparent;">route aggregation</strong><span style="background-color: transparent;">, where we can combine multiple small prefixes into a larger prefix. We group prefixes that are close together. Aggregation is used heavily around the internet, and reduces routing table sizes to around 200k prefixes. Packets are sent to the </span><strong style="background-color: transparent;">longest matching prefix</strong><span style="background-color: transparent;">.</span></p><p><span><img src="https://i.imgur.com/9FofiaN.png" width="593"></span></p><h3 id="classful-and-special-addressing"><strong style="background-color: transparent;">Classful and Special Addressing</strong></h3><p><span style="background-color: transparent;">This is the design that predated CIDR. There are class A/B/C networks with each different amounts of hosts allowed. This design wastes a lot of possible addresses, since class A is too big and class C is too small. Balancing the size of the classes turned out to be hard, so we stopped using them. Class D addresses are still used as multicast addresses.</span></p><p><span><img src="https://i.imgur.com/jNggRYi.png" width="458"></span></p><h3 id="special-addresses"><strong style="background-color: transparent;">Special addresses</strong></h3><p><span><img src="https://i.imgur.com/gI7Qbwk.png" width="559"></span></p><h3 id="network-address-translation-(nat)"><strong style="background-color: transparent;">Network address translation (NAT)</strong></h3><p><span style="background-color: transparent;">We have to use IPv4 addresses scarcely. This works well for some situations, however this does not work for company networks which are online 24/7. This also increasingly starts to apply to home networks, since phones are always online. The better fix we thought of was NAT. The idea is to assign each home or business a single IP address, and within each of these networks, every computer gets a (locally) unique IP Address. When a packet enters the public internet, the address is switched to the public address. Within each network, these ranges, which are not allowed to appear on the public internet, are used:</span></p><p><span><img src="https://i.imgur.com/EMwzw7k.png" width="511"></span></p><p><span style="background-color: transparent;">When the reply comes back, we can use the port in the TCP or UDP packets to identify which computer to send the packet to. Processes first have to </span><strong style="background-color: transparent;">bind</strong><span style="background-color: transparent;"> to a port, so that they can communicate over the internet. </span></p><p><br></p><p><span style="background-color: transparent;">Problems with NAT:</span></p><ul><li><span style="background-color: transparent;">It violates the model of the Internet Protocol, IP Addresses are no longer (globally) unique identifiers for each machine</span></li><li><span style="background-color: transparent;">NAT also breaks the end-to-end model of the internet, it’s no longer possible for every host to connect to every other host. In order to connect to a home user, special </span><strong style="background-color: transparent;">NAT traversal </strong><span style="background-color: transparent;">techniques are needed.</span></li><li><span style="background-color: transparent;">NAT changes the internet from a connectionless model to a weird kind of connected model. If the NAT box crashes, all the current TCP connections are lost.</span></li><li><span style="background-color: transparent;">NAT violates the rule of protocol layering, a layer may not make any assumptions about what inner layers put into their content. The IP protocol now requires a port.</span></li><li><span style="background-color: transparent;">Some applications use multiple ports in prescribed ways, since NAT knows nothing about this, it will fail without special care.</span></li><li><span style="background-color: transparent;">Each address only has 65536 ports, so this is not a permanent solution.</span></li></ul><p><br></p><h2 id="ipv6"><span>IPv6</span></h2><h3 id="goals"><span style="background-color: transparent;">Goals</span></h3><ul><li><span style="background-color: transparent;">Support billions of hosts, even with inefficient allocation</span></li><li><span style="background-color: transparent;">Reduce size of routing tables</span></li><li><span style="background-color: transparent;">Simplify the protocol, allowing routers to be faster</span></li><li><span style="background-color: transparent;">Provide better security</span></li><li><span style="background-color: transparent;">Pay more attention the the type of service</span></li><li><span style="background-color: transparent;">Allow for better multicasting (and disallow broadcasting)</span></li><li><span style="background-color: transparent;">Make it possible for a host to roam without changing IP addresses</span></li><li><span style="background-color: transparent;">Allow the protocol to evolve in the future</span></li><li><span style="background-color: transparent;">Permit the old and new protocols to coexist</span></li></ul><p><br></p><h3 id="improvements"><span style="background-color: transparent;">Improvements</span></h3><ul><li><span style="background-color: transparent;">128 bit addresses</span></li><li><span style="background-color: transparent;">Simplification of the header (7 fields instead of 13)</span></li><li><span style="background-color: transparent;">Better support for options</span></li><li><span style="background-color: transparent;">Big advance in security</span></li><li><span style="background-color: transparent;">More attention paid to Quality of Service</span></li></ul><p><br></p><h3 id="the-header"><strong style="background-color: transparent;">The header</strong></h3><ul><li><strong style="background-color: transparent;">Version: </strong><span style="background-color: transparent;">Set to 6</span></li><li><strong style="background-color: transparent;">Differentiated services:</strong><span style="background-color: transparent;"> Same as IPv4</span></li><li><strong style="background-color: transparent;">Flow label: </strong><span style="background-color: transparent;">A way to group packets with the same purpose together, forming a pseudo-connection. </span></li><li><strong style="background-color: transparent;">Payload length:</strong><span style="background-color: transparent;"> Amount of bytes that follow the 40-byte header, header bytes are no longer included.</span></li><li><strong style="background-color: transparent;">Next header:</strong><span style="background-color: transparent;"> Tells the type of the next header, which is the replacement for options. The last header will tell which transport protocol (TCP or UDP) the body is.</span></li><li><strong style="background-color: transparent;">Hop limit:</strong><span style="background-color: transparent;"> Amount of hops made by the packet, no longer in seconds.</span></li></ul><p><span><img src="https://i.imgur.com/0E2Dgf4.png" width="364"></span></p><h3 id="addresses"><strong style="background-color: transparent;">Addresses</strong></h3><p><span style="background-color: transparent;">Are now written in hexadecimal with a colon between every 4 digits, like: <span class="ql-formula" data-value="8000:0000:0000:0000:0123:4567:89AB:CDEF">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8000</mn><mo>:</mo><mn>0000</mn><mo>:</mo><mn>0000</mn><mo>:</mo><mn>0000</mn><mo>:</mo><mn>0123</mn><mo>:</mo><mn>4567</mn><mo>:</mo><mn>89</mn><mi>A</mi><mi>B</mi><mo>:</mo><mi>C</mi><mi>D</mi><mi>E</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">8000:0000:0000:0000:0123:4567:89AB:CDEF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mord">6</span><span class="mord">7</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">8</span><span class="mord">9</span><span class="mord mathdefault">A</span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span></span></span></span></span>﻿</span> .</span></p><p><span style="background-color: transparent;">Leading zeroes are allowed to be removed, and multiple groups of zeroes are allowed be compressed using <span class="ql-formula" data-value=":\ :">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo><mtext>&nbsp;</mtext><mo>:</mo></mrow><annotation encoding="application/x-tex">:\ :</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mrel">:</span><span class="mspace">&nbsp;</span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mrel">:</span></span></span></span></span>﻿</span> , making the above address: </span><span><span class="ql-formula" data-value="8000::123:4567:89AB:CDEF">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8000</mn><mo>:</mo><mo>:</mo><mn>123</mn><mo>:</mo><mn>4567</mn><mo>:</mo><mn>89</mn><mi>A</mi><mi>B</mi><mo>:</mo><mi>C</mi><mi>D</mi><mi>E</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">8000::123:4567:89AB:CDEF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mord">6</span><span class="mord">7</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">8</span><span class="mord">9</span><span class="mord mathdefault">A</span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span><span style="margin-right: 0.05764em;" class="mord mathdefault">E</span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span></span></span></span></span>﻿</span> </span></p><p><span style="background-color: transparent;">We can also write IPv4 addresses, using <span class="ql-formula" data-value="::192.31.20.46">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo><mo>:</mo><mn>192.31.20.46</mn></mrow><annotation encoding="application/x-tex">::192.31.20.46</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">.</span><span class="mord">3</span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mord">6</span></span></span></span></span>﻿</span></span></p><p><br></p><p><strong style="background-color: transparent;">Fragmentation: </strong><span style="background-color: transparent;">All fields about fragmentation have been removed, because fragmentation has been removed. It’s way more efficient if the source just sends the right size packet, so we use MTU discovery only.</span></p><p><strong style="background-color: transparent;">Checksum: </strong><span style="background-color: transparent;">The checksum field is gone because calculating it cost too much performance, and networks are reliable enough that is no longer a problem. </span></p><p><br></p><h3 id="extension-headers"><strong style="background-color: transparent;">Extension headers</strong></h3><div style="white-space: normal;" class="markdown-body"><table>
<thead>
<tr>
<th>Extension header</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hop-by-hop options</td>
<td>Miscellaneous information for routers, datagrams using this header extension are called <strong>jumbograms</strong></td>
</tr>
<tr>
<td>Destination options</td>
<td>Additional information for the destination</td>
</tr>
<tr>
<td>Routing</td>
<td>Loose list of routers to visit</td>
</tr>
<tr>
<td>Fragmentation</td>
<td>Management of datagram fragments</td>
</tr>
<tr>
<td>Authentication</td>
<td>Verification of the sender’s identity</td>
</tr>
<tr>
<td>Encrypted security payload</td>
<td>Information about the encrypted contents</td>
</tr>
</tbody>
</table>
</div><h2 id="internet-control-protocol"><span>Internet Control Protocol</span></h2><h3 id="icmp"><span>ICMP</span></h3><p><span>For when something unexpected occurs, a special protocol exists: </span><strong>Internet Control Message Protocol (ICMP)</strong><span>. Using this, networks can send “Warning messages” or other meta messages over the internet. About a dozen ICMP messages are defined, indicating all sorts of problems and useful testing items. These include:</span></p><ul><li><strong>Destination unreachable</strong><span>: packet could not be delivered</span></li><li><strong>Time exceeded</strong><span>: time to live field hit 0 (used by </span><em>traceroute</em><span>)</span></li><li><strong>Parameter problem</strong><span>: invalid header field</span></li><li><strong>Source quench</strong><span>: choke packet</span></li><li><strong>Redirect</strong><span>: redirect a packet somewhere else</span></li><li><strong>Echo and echo reply</strong><span>: check if a machine is alive (used by </span><em>ping</em><span>)</span></li><li><strong>Timestamp request/reply</strong><span>: same as echo, but with </span>timestamps</li><li><strong>Router advertisement/solicitation</strong><span>: find a nearby router</span></li></ul><p><br></p><h3 id="arp"><span>ARP</span></h3><p><span>How do IP addresses get mapped onto data link layer addresses such as Ethernet? One solution is to have a master configuration file somewhere, but keeping this up to date is an error-prone and time-consuming job. A better solution is for a host to output a broadcast packet onto a certain Ethernet asking who owns a certain IP-address. The response will be the Ethernet address to use. The protocol used for this is the Address Resolution Protocol (</span><strong>ARP</strong><span>). </span></p><p><br></p><p><span>This is easy to use and can be optimized by caches (which can be poisoned to "steal" IP addresses). </span><strong>Gratuitous ARPs</strong><span> can be broadcasted to inform the machines in the network that you are up and you pass your IP address. Normally, no response arrives but if another machine has the same IP address, there will be a response.</span></p><p><br></p><h3 id="dhcp"><span>DHCP</span></h3><p><span>ARP makes the assumption that hosts are configured with some basic information, such as their own IP addresses. But that is not necessarily the case. Here, </span><strong>DHCP </strong><span>comes into play, there will be a DHCP server in each network which is able to hand out IP addresses. A machine requests an IP address using a DHCP DISCOVER packet.</span></p><p><br></p><p><span>In order to make sure that the IP pool isn't filled with old, non-active machines, each DHCP assignment has a </span><strong>lease </strong><span>period, after which the host can ask for renewal.</span></p><p><br></p><h2 id="label-switching-and-mpls"><span>Label switching and MPLS</span></h2><p><span>To move packets across networks, ISPs use </span><strong>MPLS (Multi-Protocol Label Switching). </strong><span>It is very close to circuit switching. MPLS adds a label in front of each packet and forwards it based on that, instead of based on the destination address. These labels can then be stored in a lookup table, making routing very fast. This is called </span><strong>tag switching.</strong></p><p><br></p><p><span>When these packets arrive at a </span><strong>LSR (Label Switched Router)</strong><span>, the label is used as an index into a table to determine the new label and the outgoing line. The </span><strong>LER (Label Edge Router) </strong><span>will determine when to add and remove the label.</span></p><p><br></p><h2 id="ospf"><span>OSPF</span></h2><p><strong>Open Shortest Path First (OSPF) </strong><span>is a protocol which takes care of internal routing (or </span><strong>intradomain routing</strong><span>). OSPF was designed with the following requirements:</span></p><ul><li>The algorithm should be <strong>published openly</strong></li><li>The protocol should support a <strong>variety of distance</strong> metrics, e.g. physical distance, delay etc.</li><li>It had to be a <strong>dynamic algorithm, </strong>adaptive to changes of topology</li><li>It had to <strong>support routing based on type of service</strong>, i.e. provide different routing for a realtime service vs another service</li><li>It had to do <strong>loadbalancing, </strong>done by remembering which path<strong>s </strong>are shortest, and dividing load between those paths (<strong>Equal Cost MultiPath</strong>) </li><li>Support for <strong>hierarchical systems</strong> was needed</li><li>Some <strong>security </strong>was required to prevent spoofing</li><li><strong>Provision </strong>was needed to deal with routers that were connected to the internet through a tunnel</li></ul><p><br></p><p>OSPF operates by abstracting the collection of actual networks, routers, and links into a directed graph in which each arc is assigned a weight (distance, delay, etc.). This graph then looks like this:</p><p><img src="https://i.imgur.com/SrmvfDP.png" width="390"></p><p>As you can see, some arcs have an arc returning and some don't. There is no returning arc when there are only hosts in the network. OSPF divides an <strong>AS </strong>(Autonomous System) into numbered areas, which don't overlap. In that area are internal routers. Area 0 is called the <strong>backbone area</strong>, in which the <strong>boundary router </strong>is the endpoint for outside traffic. The backbone contains <strong>area routers</strong>, which connect multiple areas. <strong>Stub areas</strong> only allow routes internal to the area. Each router in an area keeps the same state and new routers coming online get information from a <strong>designated router. </strong>The messages sent between the routers are the following:</p><ul><li><strong>Hello</strong>: used to discover who the neighbors are</li><li><strong>Link state update</strong>: providers the sender's cost to its neighbors</li><li><strong>Link state ACK:</strong> acknowledges link state update</li><li><strong>Database description: </strong>announces which updates the sender has</li><li><strong>Link state request</strong>: requests information from the partner</li></ul><p><br></p><p>In the following image you can see you can build a large hierarchy to internally manage large networks:</p><p><br></p><p><img src="https://i.imgur.com/HyuawGC.png" width="454"></p><h2 id="bgp"><span>BGP</span></h2><p>Between ASes, the <strong>Border Gateway Protocol (BGP) </strong>is used. Where OSPF didn't have to, BGP has to worry about politics. A few political constraints could be:</p><ul><li>&nbsp;Never send traffic from the Pentagon on a route through Iraq</li><li>Use TeliaSonera instead of Verizon because it is cheaper</li></ul><p><br></p><p>ISPs can pay other ISPs to transmit packets over their network, called <strong>transit service. </strong>To make it work, the provider should advertise routes to all destinations on the Internet to the customer over the link that connects them.&nbsp;An example of a transit service is visible in the following image:</p><p><img src="https://i.imgur.com/tGNYCSY.png" width="474"></p><p>Here, four ASes are connected, often by a link at an <strong>IXP </strong>(<strong>Internet eXchange Point</strong>). <span class="ql-formula" data-value="AS1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">AS1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="mord">1</span></span></span></span></span>﻿</span> sells transit service to the other ASes. If some networks are connected already and send a lot of data to traffic other, they can also directly send traffic to each other, called <strong>peering. </strong></p><p><br></p><p>BGP is a form of distance vector protocol. Though instead of maintaining just the cost of the route to each destination, each BGP router keeps track of the path used. This approach is called a <strong>path vector protocol</strong>.&nbsp;BGP routers communicate with each other by setting up TCP connections. Because it works well, it is also used internally by ISPs to propagate routes from one side to the other, called <strong>iBGP. </strong></p><p><br></p><p>BGP routers choose which route to use for a destination in one of the following ways:</p><ol><li>Routes via peered networks are chosen in preference to routes via transit providers (money concern)</li><li>Shorter paths -&gt; better</li><li>Choose the lowest cost within the ISP (called <strong>early exit / hot-potato routing</strong>)</li></ol><p><br></p><h2 id="internet-multicasting"><span>Internet multicasting</span></h2><p>Some addresses in the IPv4 space are reserved for multicasting. Examples of these are:</p><ul><li><span class="ql-formula" data-value="224.0.0.1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>224.0.0.1</mn></mrow><annotation encoding="application/x-tex">224.0.0.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span></span></span></span></span>﻿</span>: all systems on a LAN</li><li><span class="ql-formula" data-value="224.0.0.2">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>224.0.0.2</mn></mrow><annotation encoding="application/x-tex">224.0.0.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span></span></span></span></span>﻿</span>: all routers on a LAN</li><li><span class="ql-formula" data-value="224.0.0.5">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>224.0.0.5</mn></mrow><annotation encoding="application/x-tex">224.0.0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span></span>﻿</span>: all OSPF routers on a LAN</li><li><span class="ql-formula" data-value="224.0.0.251">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>224.0.0.251</mn></mrow><annotation encoding="application/x-tex">224.0.0.251</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord">1</span></span></span></span></span>﻿</span>: all DNS servers on a LAN</li></ul><p><br></p><p>Other multicast addresses may have members on different networks. For that, the multicast routers need to know which device is on which group. About once a minute, the router sends a query packet to all the hosts on its LAN to ask to which group they belong. This is described by the <strong>IGMP (Internet Group Management Protocol).</strong></p><p><br></p><h2 id="mobile-ip"><span>Mobile IP</span></h2><p>In order to assign IP addresses to mobile devices, the major goals were set up:</p><ol><li>Each mobile host must be able to use its home IP address anywhere. </li><li>Software changes to the fixed hosts were not permitted. </li><li>Changes to the router software and tables were not permitted. </li><li>Most packets for mobile hosts should not make detours on the way. </li><li>No overhead should be incurred when a mobile host is at home (home being the site to which the device is connected)</li></ol><p><br></p><p>When the mobile host arrives at a new site, it gets a new IP address and tells its home its new care-of address. Now if we were to send packets to an IP address of a mobile device and that device is suddenly at another place, the packets would go to home. What now?</p><ol><li>We keep the same IP address but use a more specific subnet. Then the distant site advertises that address and thus the packet will arrive in the right place again. This would mean that every router keeps track of every change in global IP addresses, which is unmanageable.</li><li>Change the IP address of the mobile, this will stop the delivery until all programs etc are informed of the change, but this handles the mobility on a higher layer. Changing these addresses can be done using DHCP. ARPs can be used to locate the site to which the device is connected to now.</li></ol>