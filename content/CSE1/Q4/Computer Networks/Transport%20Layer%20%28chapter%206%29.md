+++
title = "Transport Layer (chapter 6)"
date = 2019-06-27
+++
<p><span style="background-color: transparent;">The goal of the transport layer is to provide efficient, reliable, and cost-effective data. The transport layer sends segments to the network layer (which turns it into packets, which in turn will be transformed into frames by the data link layer).</span></p><p><br></p><p><span style="background-color: transparent;">The transport and network layer are very similar, but the transport layer only runs on the user’s machine and is thus way more easy to customize. It gives the users full control over the connection. </span></p><p><br></p><h1 id="the-transport-service"><span>The transport service</span></h1><p><span>The transport service has a lot in common with the network layer's services. They both have three phases: establishment, data transfer and release. The transport layer aims to solve this by providing reliable (100% in the case of connection-oriented) connections.</span></p><p><br></p><p><span>The existence of the transport layer makes it possible for programmers to write programs that work on a wide variety of networks. The transport service does this by providing primitives to use. If the network layer was faultless these primitives wouldn't be necessary. However the real world works differently. For this reason there is often made a distinction between layers 1 through 4 and the others. </span></p><p><br></p><p><span>The bottom four can be seen as the </span><strong>transport service providers</strong><span> and the upper layers can be seen as the </span><strong>transport service user.</strong></p><p><br></p><h2 id="transport-service-primitives"><span>Transport service primitives</span></h2><p><span>Some example primitives for a simple transport service:</span></p><ol><li><strong>Listen</strong><span>: wait for another process to contact us (blocks until some process tries to connect)</span></li><li><strong>Connect</strong><span>: actively try to connect to a process that is listening</span></li><li><strong>Send</strong><span>: send data over the established connection</span></li><li><strong>Receive</strong><span>: receive data over the established connection (blocks until a data packet arrives)</span></li><li><strong>Disconnect</strong><span>: release the connection</span></li></ol><p><br></p><p><span>We use the term </span><strong>Transport Protocol Data Unit (TPDU) </strong><span>to describe messages sent from transport entity to transport entity.</span></p><p><br></p><h2 id="berkeley-sockets"><span>Berkeley sockets</span></h2><p><span>The primitives for Berkely sockets extend on the transport service primitives (these are used by TCP):</span></p><ol><li><strong>Socket</strong><span>: create a new communication endpoint</span></li><li><strong>Bind: </strong><span>assign a local address to the socket</span></li><li><span>Listen</span></li><li><strong>Accept: </strong><span>passively accept an incoming connection request</span></li><li><span>Connect</span></li><li><span>Send</span></li><li><span>Receive</span></li><li><span>Close</span></li></ol><p><br></p><p><span>The first four primitives here are executed by a server socket in that order: </span></p><ul><li><span>The SOCKET call returns a file descriptor to write on in later system calls</span></li><li><span>Using BIND a socket file descriptor gets an address to listen on</span></li><li><span>The LISTEN call allocates a large enough space to queue incoming requests</span></li><li><span>ACCEPT waits for incoming connections, and when one does it creates a new socket file descriptor similar to the original one. Now the program can fork off to handle this new connection and start waiting with another ACCEPT call</span></li></ul><p><br></p><p><span>The client side does something similar in a slightly different order:</span></p><ul><li><span>First a SOCKET call is done to create one</span></li><li><span>Now CONNECT is used, which blocks the caller until a connection is established with a server (timeouts can be used here)</span></li><li><span>Once a connection is established, both sides can use SEND and RECEIVE</span></li></ul><p><br></p><p><span>A connection is only released once both parties, server and client, have executed CLOSE.</span></p><p><br></p><h1 id="elements-of-transport-protocols"><span>Elements of transport protocols</span></h1><h3 id="similarities-and-differences-with-the-data-link-layer"><strong>Similarities and differences with the data link layer</strong></h3><ul><li><strong>Similar: </strong><span>both have to deal with error control, sequencing, and flow control.&nbsp;</span></li><li><strong>Different:</strong></li><li class="ql-indent-1"><span>The environment is different, we need addressing and we need to set up connections</span></li><li class="ql-indent-1"><span>There is also storage capacity on the network, packets may arrive out of order, or packets may be duplicated</span></li><li class="ql-indent-1"><span>The final problem with the transport layer is that buffers and the fact that bandwidth may fluctuate wildly</span></li></ul><p><br></p><h2 id="addressing"><span style="background-color: transparent;">Addressing</span></h2><p><span style="background-color: transparent;">Packets don’t just need a destination computer, they also need a destination </span><strong style="background-color: transparent;">port</strong><span style="background-color: transparent;">, for which program is the packet intended? </span></p><p><br></p><p><span style="background-color: transparent;">An IP Address is a NSAP (</span><strong style="background-color: transparent;">Network Service Access Point</strong><span style="background-color: transparent;">), because it’s all the identification the network needs. In some networks, a NSAP may be shared between multiple computers.</span></p><p><span style="background-color: transparent;">A port is a TSAP (</span><strong style="background-color: transparent;">Transport Service Access Point</strong><span style="background-color: transparent;">), it runs over a NSAP and allows two TSAP interfaces to communicate (a local and a remote one).</span></p><p><br></p><p><span>It is not very efficient to let all servers listening to a port all day long, therefore the </span><strong>initial connection protocol </strong><span>is used. A proxy server, </span><strong>process server, </strong><span>receives the requests and spawns a new server if needed. But, this is only applicable when servers can be created on demand (i.e. there needs to be a known mapping between a port and an application).</span></p><p><br></p><h2 id="connection-establishment"><span style="background-color: transparent;">Connection establishment</span></h2><p><strong style="background-color: transparent;">Problem</strong><span style="background-color: transparent;">: What if a packet for a connection establishment times out, is resend, and then still arrives, thus gets duplicated?</span></p><p><strong style="background-color: transparent;">Solution</strong><span style="background-color: transparent;">: Guarantee a maximum TTL for packets (120s in Ethernet) using a hop counter, and give each packet a unique identifier which may not be repeated until the TTL expires. </span></p><p><br></p><p><strong>Why use sequence numbers?</strong></p><ul><li><span>Detect data loss, missing sequence number -&gt; lost data</span></li><li><span>Re-order data, sequence numbers not in ascending order -&gt; change order</span></li><li><span>Detecting duplicates, two segments with same sequence number -&gt; discard one of them</span></li></ul><p><br></p><p><strong>Forbidden region</strong></p><p><span style="background-color: transparent;">The forbidden region is the set of identifiers that may currently be chosen as an initial sequence number, and is thus forbidden from use. There are two ways we could enter this region:</span></p><ul><li><span style="background-color: transparent;">We send too much data, in which case we’ll hit the forbidden region from the right. To fix this, send at most 1 segment per clock tick. Though this is very unlikely anyway</span></li><li><span style="background-color: transparent;">We can send too little data, in which case we’ll hit the forbidden region from the left. This limits how long a connection can last (max 4 hours).</span></li></ul><p><br></p><p><span style="background-color: transparent;">Say data remains in the network at most <span class="ql-formula" data-value="T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span> seconds. Then we should not send a segment with a sequence number that can be an initial sequence numbers within the next </span><span><span class="ql-formula" data-value="T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span> seconds, otherwise we might get duplicates.</span></p><p><br></p><p><strong>Increasing sequence numbers</strong></p><p><span style="background-color: transparent;">We increase the sequence numbers based on the segment size. It should be related to the size because:</span></p><ul><li><span style="background-color: transparent;">a part of a segment might be dropped</span></li><li><span style="background-color: transparent;">fragmentation</span></li></ul><p><br></p><p><span style="background-color: transparent;">When sequence numbers get close to the forbidden region, we can choose a new sequence number. </span></p><p><br></p><p><strong>Choosing a sequence number</strong></p><p><span style="background-color: transparent;">Depending on the time of day we choose this sequence number, so if the host crashes it still works! If we crash we choose a new sequence number based on the time of day and our predefined rules.</span></p><p><span><img src="https://i.imgur.com/26JmITl.png" width="390"></span></p><p><br></p><h3 id="the-3-way-handshake"><strong style="background-color: transparent;">The 3-way handshake</strong></h3><ul><li><span style="background-color: transparent;">First, host 1 sends a connection request to host 2 with host 1’s sequence number (</span><strong style="background-color: transparent;">SYN</strong><span style="background-color: transparent;">chronize)</span></li><li><span style="background-color: transparent;">Then host 2 sends an ACK repeating this sequence number, and including its own sequence number (</span><strong>SYN</strong><span>chronize-</span><strong>ACK</strong><span>nowledgement). We have 2 sequence numbers on a connection, one per endpoint. Here we agree on the initial sequence numbers.</span></li><li><span style="background-color: transparent;">Finally, host 1 can now send data using this new connection (</span><strong>ACK</strong><span>nowledge). Usually, only after this first data we increase the sequence number.</span></li></ul><p><br></p><p><span style="background-color: transparent;">If the initial request is now repeated (for example, if the ACK gets lost), host 2 just repeats its ACK with the number, but host 1 sends a reject. So, this handshake can handle duplicates. The first connection will still work!</span></p><p><span><img src="https://i.imgur.com/K3GfShm.png" width="426"></span></p><h2 id="connection-release"><span style="background-color: transparent;">Connection release</span></h2><p><span style="background-color: transparent;">There are 2 styles of releasing connections</span></p><ul><li><span style="background-color: transparent;">Asymmetric (one party just stops the connection, informing the other person but not waiting for an ACK, it may result in data loss)</span></li><li><span style="background-color: transparent;">Symmetric (both parties must agree before ending the connection)</span></li></ul><p><br></p><p><span style="background-color: transparent;">The </span><strong style="background-color: transparent;">two army problem</strong><span style="background-color: transparent;"> comes into play for symmetric connections, as we are never sure if the other party got the last message. This problem is unsolvable, so we just add an extra condition that if the other party hasn’t communicated for a while after a disconnection, to exit the connection. The initiating party will retry <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> times and then release the connection.</span></p><p><span><img src="https://i.imgur.com/VPNfIBH.png" width="352"></span></p><h2 id="error-control-&amp;-flow-control"><span style="background-color: transparent;">Error control &amp; flow control</span></h2><p><span style="background-color: transparent;">We want to make sure that the packet got through the entire network correctly, as a final check. Packets may get corrupted by broken routers, and there is no error control to catch this. Sequence numbers don't tell you this. For error control, we run a known method (CRC, hamming etc.).</span></p><p><br></p><p><span>If the receiver of packets don't have the capability to receive all the packets sent (but the network has), the transport layer of the receiver can tell the sender to slow down. This is </span><strong>flow control</strong><span>. On the transport layer, we have a higher delay than in the data link layer. We still use sliding windows, but since sliding windows may be huge (because we have a large </span><strong>bandwidth-delay product</strong><span>), we want to use dynamic buffers, shared by multiple connections. </span></p><p><br></p><h2 id="multiplexing"><span style="background-color: transparent;">Multiplexing</span></h2><p><span style="background-color: transparent;">There are multiple processes sharing a single network connection (eg. same IP address), this is called </span><strong style="background-color: transparent;">multiplexing</strong><span style="background-color: transparent;">. </span></p><p><span style="background-color: transparent;">A single process using multiple network connections (to increase bandwidth or reliability) is called </span><strong style="background-color: transparent;">inverse multiplexing</strong><span style="background-color: transparent;">.</span></p><p><span><img src="https://i.imgur.com/noXcfDg.png" width="396"></span></p><p><br></p><h2 id="crash-recovery"><span style="background-color: transparent;">Crash recovery</span></h2><p><span style="background-color: transparent;">The hard problem is recovering from host crashes. We don’t know whether we passed on the data to the next layer yet. If we first send an ACK and then pass on the data, we might have sent an ACK but not passed on the data. The other way around has the same problem. This problem is not solvable on a certain layer <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> without using layer <span class="ql-formula" data-value="k+1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>. The transport layer can propagate problems to the application layer.</span></p><p><span><img src="https://i.imgur.com/0luGGpY.png" width="405"></span></p><p><br></p><h1 id="congestion-control"><span style="background-color: transparent;">Congestion control</span></h1><p><span style="background-color: transparent;">The network layer already does a lot of congestion control, but at some point the best way to fix congestion issues is to just send fewer packets into the network. This is the responsibility of the transport layer. Congestion control is used when the network can't handle the amount of packets sent over the network (whereas with flow control the receiver couldn't handle the load).</span></p><p><br></p><p><strong style="background-color: transparent;">Power:</strong><span style="background-color: transparent;"> used bandwidth (load) / Delay</span></p><p><br></p><h2 id="fair-bandwidth-allocation"><span>Fair bandwidth allocation</span></h2><p><span>If we have a total bandwidth of <span class="ql-formula" data-value="B">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span></span></span>﻿</span> with <span class="ql-formula" data-value="N">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">N</span></span></span></span></span>﻿</span> machines, each machine should get <span class="ql-formula" data-value="\frac{B}{N}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>B</mi><mi>N</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{B}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.217331em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.6550000000000002em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right: 0.10903em;" class="mord mathdefault mtight">N</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right: 0.05017em;" class="mord mathdefault mtight">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>﻿</span> bandwidth. Unfortunately this does not always work.</span></p><p><br></p><p><span>It could be that the total bandwidth <span class="ql-formula" data-value="B=2">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">B=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span>﻿</span>, with <span class="ql-formula" data-value="N=3">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">N=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">N</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span></span></span></span></span>﻿</span>. This means each machine gets <span class="ql-formula" data-value="\frac{2}{3}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>2</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.190108em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.845108em;"><span class="" style="top: -2.6550000000000002em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>﻿</span> bandwidth. But this will not work if 2 machines are wired to 1 router, then you get over the bandwidth over that one router!</span></p><p><br></p><p><span>Even if you were trying to fairly divide bandwidth, it is hard to decide how many machines there are and decide how much bandwidth each machine gets. Besides, the path of the packet of a machine depends on the destination, thus the amount of network congestion also depends on that. So we have a few unknowns;</span></p><ul><li><span>Available bandwidth</span></li><li><span>Network topology</span></li><li><span>Other clients</span></li></ul><p><br></p><h2 id="max-min-fairness"><strong style="background-color: transparent;">Max-min fairness</strong></h2><p><strong style="background-color: transparent;">Max-min fairness </strong><span style="background-color: transparent;">is a technique that is frequently used. This maximizes minimum bandwidth, then uses excess bandwidth where possible. A link is max-min fair if we can’t increase the flow of a link any further without decreasing the flow of a link with smaller flow. A disadvantage of this is that we might not use total bandwidth.</span></p><p><span><img src="https://i.imgur.com/YoZfokQ.png" width="349"></span></p><p><span style="background-color: transparent;">How do we choose what to base the fairness on? </span></p><ul><li><span style="background-color: transparent;">Per computers: Busy servers get the same bandwidth as a mobile phone</span></li><li><span style="background-color: transparent;">Per connection: Encourages opening more connections</span></li></ul><p><br></p><p><span style="background-color: transparent;">The algorithm must also converge quickly, as bandwidth will change rapidly.</span></p><p><br></p><h2 id="dynamic-bandwidth"><span style="background-color: transparent;">Dynamic bandwidth</span></h2><p><span>We can just trial and error to dynamically adjust the bandwidth. We keep trying to increase the bandwidth usage and slow down when we receive a congestion signal. </span></p><p><br></p><p><span>We can detect this congestion by:</span></p><ol><li><span>Explicit feedback from routers (not very common, the routers are stupid)</span></li><li><span>Loss, if we lose packets we decrease bandwidth</span></li><li><span>Latency, if delays between ACKs are bigger than the delays between sending segments</span></li></ol><p><br></p><h2 id="regulating-the-sending-rate"><span style="background-color: transparent;">Regulating the sending rate</span></h2><p><span style="background-color: transparent;">We must find some way to have a host know how much it may send. Find the optimal point.</span></p><p><span><img src="https://i.imgur.com/dsRObLS.png" width="284"></span></p><p><span style="background-color: transparent;">The best way turns out to be:</span></p><ul><li><strong style="background-color: transparent;">Additive increase</strong><span style="background-color: transparent;">: Try to add a constant amount to the speed each time. If fine, do again, otherwise decrease</span></li><li><strong style="background-color: transparent;">Multiplicative decrease</strong><span style="background-color: transparent;">: Try to multiply by a constant. If fine, do again, otherwise divide</span></li><li><strong style="background-color: transparent;">Combination of additive increase and multiplicative decrease: </strong><span style="background-color: transparent;">This makes the line regress to the fairness line.</span></li></ul><p><br></p><h2 id="wireless-issues"><span style="background-color: transparent;">Wireless issues</span></h2><p><span style="background-color: transparent;">Wireless networks are unreliable, and lose packets all the time. To not make the transport layer completely useless, we hide a lot of packet losses from the transport layer, and we only send the packet loss to the transport layer if the packet gets lost after multiple retries.</span></p><p><br></p><h1 id="udp-(user-datagram-protocol)"><span style="background-color: transparent;">UDP (user datagram protocol)</span></h1><p><span style="background-color: transparent;">Connectionless protocol, doing almost nothing except sending packets to applications.</span></p><p><br></p><p><span style="background-color: transparent;">UDP does do:</span></p><ul><li><span style="background-color: transparent;">End to end error detection (Optional)</span></li><li><span style="background-color: transparent;">Demultiplexing</span></li></ul><p><br></p><p><span style="background-color: transparent;">UDP does </span><strong style="background-color: transparent;">not</strong><span style="background-color: transparent;"> do:</span></p><ul><li><span style="background-color: transparent;">Flow control</span></li><li><span style="background-color: transparent;">Congestion control</span></li><li><span style="background-color: transparent;">Retransmissions</span></li></ul><p><br></p><h2 id="header"><span>Header</span></h2><p><span style="background-color: transparent;">It has a 8 byte header:</span></p><p><span><img src="https://i.imgur.com/SgCZ6Aw.png" width="411"></span></p><p><strong style="background-color: transparent;">Source port:</strong><span style="background-color: transparent;"> The port where the source application sent the data from</span></p><p><strong style="background-color: transparent;">Destination port:</strong><span style="background-color: transparent;"> The port where the target application is located at</span></p><p><strong style="background-color: transparent;">UDP Length:</strong><span style="background-color: transparent;"> The amount of bytes of the UDP header and body together, the minimum is 8 (because of the header size) and the maximum is the maximum size of an IP packet.</span></p><p><strong style="background-color: transparent;">Checksum:</strong><span style="background-color: transparent;"> Add up all the 16 bit words using XOR, the result should be 0 (optional)</span></p><p><br></p><h2 id="application"><span style="background-color: transparent;">Application</span></h2><p><span>UDP is used in applications where losing a few frames isn't too bad and speed is more important. This could be video streaming, realtime games etc. This does mean that the application layer needs to correct for this. </span></p><p><br></p><h1 id="tcp-(transmission-control-protocol)"><span style="background-color: transparent;">TCP (transmission control protocol)</span></h1><p><span style="background-color: transparent;">TCP is a very reliable but slow protocol. It provides a reliable end-to-end byte stream over an unreliable network.</span></p><p><br></p><p><span>Some properties:</span></p><ul><li><span style="background-color: transparent;">In TCP, both the sender and the receiver create endpoints called </span><strong style="background-color: transparent;">sockets</strong><span style="background-color: transparent;">. Each socket is identified by an IP address and a port. All TCP connections are full duplex and point-to-point</span></li><li><span style="background-color: transparent;">TCP is a byte stream, not a message stream. So if you send <span class="ql-formula" data-value="4\times512">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>×</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">4\times512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span></span>﻿</span> bytes, this may be received as <span class="ql-formula" data-value="1\times2048">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>2048</mn></mrow><annotation encoding="application/x-tex">1\times2048</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span></span></span></span></span>﻿</span> bytes by the receiver. TCP may also buffer data until it received enough to send in a single packet</span></li><li><span style="background-color: transparent;">The TCP protocol uses path discovery to find the </span><strong style="background-color: transparent;">maximum transfer unit (MTU)</strong><span style="background-color: transparent;"> which it may send. In practice, the MTU is often 1500 bytes (max ethernet packet size)</span></li><li><span style="background-color: transparent;">TCP is much, much more complex than UDP</span></li></ul><p><br></p><h2 id="header"><span style="background-color: transparent;">Header</span></h2><p><span><img src="https://i.imgur.com/A6ME3Om.png" width="360"></span></p><p><strong style="background-color: transparent;">Source &amp; Destination port: </strong><span style="background-color: transparent;">Identify local endpoints of the connection.</span></p><p><strong style="background-color: transparent;">Sequence number: </strong><span style="background-color: transparent;">Specifies current segment byte id (specified more later)</span></p><p><strong style="background-color: transparent;">Acknowledgement number: </strong><span style="background-color: transparent;">Specifies the next byte id it expects</span></p><p><strong style="background-color: transparent;">Header length: </strong><span style="background-color: transparent;">Amount of 32-bit words in the header</span></p><p><br></p><p><strong style="background-color: transparent;">CWR and ECE: </strong><span style="background-color: transparent;">Signals congestion, CWR says the sender has slowed down, ECE says the receiver must slow down</span></p><p><strong style="background-color: transparent;">URG:</strong><span style="background-color: transparent;"> Urgent packet</span></p><p><strong style="background-color: transparent;">ACK:</strong><span style="background-color: transparent;"> Set to 1 if acknowledgement number is valid, set to 0 if acknowledgement number should be ignored because it’s not used</span></p><p><strong style="background-color: transparent;">PSH: </strong><span style="background-color: transparent;">This data must be sent to the application layer ASAP, and must not be buffered</span></p><p><strong style="background-color: transparent;">RST: </strong><span style="background-color: transparent;">Reset this connection, because of a problem (like a host crash)</span></p><p><strong style="background-color: transparent;">SYN: </strong><span style="background-color: transparent;">Used to establish connections, the connection request has <span class="ql-formula" data-value="\text{SYN}=1,\text{ACK}=0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>SYN</mtext><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mtext>ACK</mtext><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{SYN}=1,\text{ACK}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord text"><span class="mord">SYN</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.8777699999999999em; vertical-align: -0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord text"><span class="mord">ACK</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span>, and the reply has </span><span><span class="ql-formula" data-value="\text{SYN}=1,\text{ACK}=1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>SYN</mtext><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mtext>ACK</mtext><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{SYN}=1,\text{ACK}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord text"><span class="mord">SYN</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.8777699999999999em; vertical-align: -0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord text"><span class="mord">ACK</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span></span></p><p><strong style="background-color: transparent;">FIN: </strong><span style="background-color: transparent;">Used to release a connection</span></p><p><br></p><p><strong style="background-color: transparent;">Window size:</strong><span style="background-color: transparent;"> How many more bytes may be sent, starting at the last byte that was acknowledged (used for flow control)</span></p><p><strong style="background-color: transparent;">Checksum: </strong><span style="background-color: transparent;">A 16-bit XOR of the header and the data</span></p><p><strong style="background-color: transparent;">Options: </strong><span style="background-color: transparent;">May be used to provide extra facilities that are not provided by the regular header</span></p><h2 id=""><br></h2><h2 id="tcp-conversations"><span style="background-color: transparent;">TCP conversations</span></h2><h3 id="connection-establishment"><span style="background-color: transparent;">Connection establishment</span></h3><p><span style="background-color: transparent;">Uses the 3-way handshake described earlier. One side waits for a connection, the other initiates it. It also works perfectly if both parties initiate a connection at the same time, since both will acknowledge with the correct sequence number, thus making only one connection.</span></p><p><br></p><p><span style="background-color: transparent;">An interesting attack is </span><strong style="background-color: transparent;">SYN flooding, </strong><span style="background-color: transparent;">where we send a large amount of connection requests to a host, and the host has to remember all connections. This can be solved by not remembering the initial connections, but rather generating the sequence number from the IP, port, and a local secret.</span></p><p><br></p><h3 id="connection-release"><span style="background-color: transparent;">Connection release</span></h3><p><span style="background-color: transparent;">We can stop a connection, once both sides have sent a packet with the </span><strong style="background-color: transparent;">FIN </strong><span style="background-color: transparent;">bit. When that bit is set, the connection is stopped in one direction for new data. If there is no acknowledgement to a </span><strong style="background-color: transparent;">FIN </strong><span style="background-color: transparent;">within 2 packet lifetimes, the connection is dropped.</span></p><h3 id=""><br></h3><h3 id="buffer-management"><span>Buffer management</span></h3><p><span style="background-color: transparent;">TCP separates the issues of correctly receiving segments (using ACK field) and buffer management (using WIN field). This is a valid TCP conversation:</span></p><h3 id=""><span><img src="https://i.imgur.com/jLzQENj.png" width="354"></span></h3><p><br></p><p><span>In TCP, received packets are buffered by the receiver. The length of the buffers available is sent back to the sender (piggybacked on other messages). On this way, the sender knows when to send how much, in a way the buffer of the receiver never gets too full. If it's full, it could mean data is lost.</span></p><p><br></p><h3 id="sequence-numbers"><span>Sequence numbers</span></h3><ul><li><span style="background-color: transparent;">In TCP, every data byte has its own sequence number</span></li><li><span style="background-color: transparent;">SYN and FIN also increase sequence/ack numbers</span></li><li><span style="background-color: transparent;">In a TCP segment sent from </span><span><span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span> to <span class="ql-formula" data-value="R">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span></span></span></span></span>﻿</span>:</span></li><li class="ql-indent-1"><span>Sequence number: bytes <span class="ql-formula" data-value="R">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span></span></span></span></span>﻿</span> should have received before this segment + initial sequence number of <span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span> </span></li><li class="ql-indent-1"><span>Acknowledgement number: bytes received from <span class="ql-formula" data-value="R">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span></span></span></span></span>﻿</span> + initial sequence number of <span class="ql-formula" data-value="R">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span></span></span></span></span>﻿</span></span></li><li><span style="background-color: transparent;">The initial sequence number is clock based but with additional randomness (for security purposes, to avoid an impersonation attack)</span></li><li><span style="background-color: transparent;">The sequence numbers always notates the start of the data, not the end.</span></li></ul><p><br></p><h3 id="flow-control"><span>Flow control</span></h3><p><span style="background-color: transparent;">When the window is 0, no packets may be sent by the sender, except:</span></p><ul><li><span style="background-color: transparent;">Urgent data, for example ending the connection</span></li><li><span style="background-color: transparent;">A 1-byte packet forcing the receiver to re-announce the next byte excepted and the window size, called a </span><strong style="background-color: transparent;">window probe</strong><span style="background-color: transparent;">. This is useful for if a window update ever gets lost.</span></li></ul><p><br></p><p><span style="background-color: transparent;">Another problem is the </span><strong style="background-color: transparent;">silly window problem</strong><span style="background-color: transparent;">, where the sender sends data in large blocks, but the receiver reads 1 byte at a time, thus sending a lot of window updates. The solution to this is to have the receiver only send window updates once a decent amount of new space is available. Specifically, the receiver should only advertise new space until the buffer is half full, or it has freed another maximum segment size.</span></p><p><br></p><h3 id="retransmissions"><span>Retransmissions</span></h3><p><span>We retransmit segments after a timer expires. We also retransmit a segment if we received an acknowledgement of the next segment (called </span><strong>fast retransmission</strong><span>). This has the risk that a segment might be sent twice. </span><span style="background-color: transparent;">It may also use the time between ACKs, this is called an </span><strong style="background-color: transparent;">ACK clock</strong></p><p><br></p><h3 id="acks"><span>ACKs</span></h3><p><span style="background-color: transparent;">Senders are not required to send information as soon as it comes in, and receivers are not required to acknowledge instantly. We can use this to optimize performance. In TCP, we wait up to 500ms before sending the acknowledgement, in the hope to get a free ride with some data (piggybacked ACK, then the ACK field is <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span> but we increase the ACK number). </span></p><p><br></p><p><span style="background-color: transparent;">If we have nothing to send back, we send an ACK directly (with only the TCP header), with the ACK field set to <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>.</span></p><p><br></p><h3 id="examples"><span>Examples</span></h3><p><span>A few examples of conversations:</span></p><p><span><img src="https://i.imgur.com/CRcaqq1.png" width="604"></span></p><p><span><img src="https://i.imgur.com/UJ0GCiw.png" width="603"></span></p><p><br></p><h2 id="congestion-control"><span style="background-color: transparent;">Congestion control</span></h2><p><span style="background-color: transparent;">TCP maintains a </span><strong style="background-color: transparent;">congestion window</strong><span style="background-color: transparent;">, whose size is the amount of bytes that the sender may have on the network at any time. The window size is adjusted according to the AIMD rule (additive increase, multiplicative decrease). Thus there are two different windows in TCP, you never send more than the minimum of either of the two windows.</span></p><p><br></p><h3 id="slow-start"><strong style="background-color: transparent;">Slow start</strong></h3><p><span style="background-color: transparent;">AIMD will take a long time to reach a high speed on fast networks. Instead, we use slow start, which grows exponentially at first. To keep this algorithm from going out of control, we will cap it off at a threshold, which at first is set to infinity. In TCP Tahoe slow start was implemented first.</span></p><p><br></p><p><span style="background-color: transparent;">Slow start:</span></p><ul><li><span style="background-color: transparent;">Start by sending out at most 4 segments</span></li><li><span style="background-color: transparent;">For each segment that is acknowledged, send out another 2 segments</span></li><li><span style="background-color: transparent;">When the threshold is hit, switch to additive increase</span></li><li><span style="background-color: transparent;">When a packet is lost, set the threshold to half of the congestion window, and the entire process is restarted.</span></li></ul><p><span><img src="https://i.imgur.com/aoMsVHN.png" width="397"></span></p><p><span style="background-color: transparent;">To improve the algorithm, we can use </span><strong style="background-color: transparent;">fast recovery: </strong><span style="background-color: transparent;">instead of dropping all the way to 0, we can drop to the threshold directly. TCP Tahoe with fast recovery is used in TCP Reno</span></p><p><br></p><p><span><img src="https://i.imgur.com/tAmfpMh.png" width="448"></span></p><p><span style="background-color: transparent;">Newer TCP versions all use different variations of the same idea of decreasing congestion window and threshold. </span></p><p><br></p><p><span style="background-color: transparent;">Even more minor improvements have been made:</span></p><ul><li><span style="background-color: transparent;">We now have selective acknowledgements, which means we can acknowledge a range of bytes and thus have a better knowledge of what segments were lost.</span></li><li><span style="background-color: transparent;">We can now use explicit congestion notifications (we explicitly say the network is congested), in addition to packet losses. We can get these signals from the IP layer.</span></li><li><span style="background-color: transparent;">Some TCP protocols use precise congestion signals, telling them exactly at what bandwidth they can send</span></li></ul><p><br></p>