+++
title = "Security Testing"
date = 2019-05-17
+++
<h1 id="security-testing">Security testing</h1><p>In security testing, we actively look for any vulnerabilities that could compromise the security of our application. You should test for security as there is a lot of surface to attack, in which there only has to be one exploit which can break the entire security of a system. This security testing should be done in every part of the SDLC:</p><ol><li><strong>Planning</strong>: risk assessment &amp; abuse cases</li><li><strong>Analysis</strong>: threat modelling</li><li><strong>Design</strong>: design for security (use correct libraries)</li><li><strong>Implementation</strong>: security implementation</li><li><strong>Testing &amp; integration</strong>: security testing &amp; code reviews</li><li><strong>Maintenance</strong>: patching &amp; upgrading</li></ol><p><br></p><h2 id="security-vulnerabilities-in-java">Security vulnerabilities in Java</h2><p>Java vulnerabilities are crucial to solve, as many devices use Java. The following are some resources where security vulnerabilities can be found:</p><p><br></p><h3 id="owasp-top-ten-project">OWASP Top Ten project</h3><ul><li>Awareness document</li><li>Web application security</li></ul><h3 id=""><br></h3><h3 id="nist-national-vulnerability-database">NIST National Vulnerability Database</h3><ul><li>US government repository</li><li>Contains general security flaws</li><li>This also contains information about Java vulnerability</li></ul><p><br></p><h3 id="types-of-vulnerabilities">Types of vulnerabilities</h3><ul><li><strong>Code injection</strong>: execute injected code</li><li><strong>Arbitrary code execution</strong></li><li class="ql-indent-1">Type confusion, can bypass the Java Security Manager</li><li class="ql-indent-1">XStream, an XML deserializer with vulnerabilities</li><li><strong>Remote code execution</strong></li><li><strong>Examples</strong></li><li class="ql-indent-1">Slammer worm, exploited a buffer overflow in MSQL, drastically slowed-down internet traffic</li><li class="ql-indent-1">Stuxnet, Iranian nuclear program set back by malware</li><li class="ql-indent-1">Conficker worm, overloads a server by setting up a botnet </li></ul><p><br></p><h1 id="classes-of-security-testing">Classes of security testing</h1><h2 id="manual-testing">Manual testing</h2><ul><li>Code reviews</li><li><em>Pro:</em> efficient use of human expertise</li><li><em>Con:</em> labor intensive</li></ul><p><br></p><p><strong>Black box testing: </strong>Unknown internal structure and try to figure out if it's behaving correctly. This is a generic technique, but it requires an end-to-end system and may miss components (as these are not known)</p><p><strong>White box testing</strong>: Known internal structure which is analysed. Here, the GUI is not necessary required and gives a possibility of extensive testing and debugging but it is very time consuming.</p><p><br></p><h2 id="automated-testing">Automated testing</h2><ul><li>Automated code checking</li><li><em>Pro:</em> can check many lines of code in seconds</li><li><em>Con: </em>incomparable to human expertise</li></ul><p><br></p><h3 id="static-application-security-testing-(sast)">Static application security testing (SAST)</h3><p><em>For more on static testing, see </em><a href="https://cshub.nl/post/212038359#static-analysis-by-tools" target="_blank"><em>this link</em></a></p><p><br></p><p><strong>Reverse engineering (system level): </strong>disassemble application to extract the internal structure of the application. You convert the black box to white box, which is useful to gain information. This can also be used to convert legacy code into modern code.</p><p><strong>Risk-based testing (business level): </strong>you model the worst case scenarios and check the risks</p><p><strong>Static code checker (unit level): </strong>tools check for rule violations via code structure. Identifies bad code practice, potential security issues etc</p><p><br></p><h3 id="dynamic-application-security-testing-(dast)">Dynamic application security testing (DAST)</h3><p>In the next part this will be expanded upon.</p><p><br></p><p><strong>Taint analysis: </strong>tracking variable values controllable by users. You should never trust inputs by the user, treat all inputs as untrusted.</p><p><strong>Fuzzing: </strong>bombard the application with garble data to cause crashes</p><p><strong>Dynamic validation: </strong>functional testing based on requirements (unit tests)</p><p><strong>Penetration testing: </strong>end-to-end black box testing</p><p><br></p><h1 id="dynamic-security-testing">Dynamic security testing</h1><p>Executes code and observes behavior and checks functional code paths only. This gives a more advanced analysis but is more difficult to set up</p><p><br></p><h2 id="overflows">Overflows</h2><h3 id="integer-overflow">Integer overflow</h3><p>If we add two integers together, it is possible that the result is larger than the size of an integer. This gives an overflow, which for example could lead to negative numbers.</p><p><br></p><h3 id="buffer-overflow">Buffer overflow</h3><p>If we put something in a buffer (array) that is out of bounds of the buffer, things can go wrong. Most buffer overflows happen on the stack. This can lead to code injection and is often a vulnerability in programs. </p><p><br></p><p>The solution to this could be checking array bounds at runtime, which is done by Java, Python and more language. For efficiency, some languages don't do this.</p><p><br></p><h2 id="security-testing">Security testing</h2><p>Security testing involves looking for incorrect behavior for weird inputs. This can be done by fuzzing, where you test inputs at random until the system crashes. Which inputs to choose is pretty hard though, as there are many possible inputs and you can't test them all.</p><p><br></p><p>There are two types of fuzzing:</p><ul><li><strong>Black box: </strong>just picking random inputs won't help, there are a few techniques you can use:</li><li class="ql-indent-1">Generate random permutations from example files (<strong>mutation-based fuzzing</strong>). This is an easy way to find many real-world bugs.</li><li class="ql-indent-1">Fuzz only values but keep in line with the specification (<strong>protocol fuzzing).</strong></li><li><strong>White box: </strong>using code coverage you can also find what to fuzz. You look at which branches are covered by your inputs and which aren't, and change your inputs based on that. This should be done using different heuristics, to test more possibilities.</li></ul><p><br></p>