+++
title = "Self testing"
date = 2019-06-30
+++
<p>Besides exercising and observing, the system will also use self checks. In this way we can:</p><ul><li>test the system in daily use </li><li>the operations team observes what happens</li></ul><p><br></p><h2 id="assert">Assert</h2><p>An assertion is a Boolean expression at a specific point in a program which will be true, unless there is a bug in the program. So if true, it doesn't do anything. If false, it throws some kind of error (depending on the language).</p><p><br></p><p>In Java, they are disabled by default, but will be enabled by IDEs while running tests for example. But, assertions in the code don't replace tests, they only increase the fault sensitivity (as assertions can't fail!). Though, the assertions should be an inspiration for writing tests, they might for example contain boundaries which should be tested. </p><p><br></p><p>Some testing tools view assert statements as actual statements which can be true or false. Thus in order to get high coverage, assertions will have to be true/false as well.</p><p><br></p><h2 id="pre/post-conditions">Pre/post conditions</h2><p>At any execution of <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span>:</p><ul><li>starting in a state where <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span> holds (preconditions)</li><li>will terminate in a state where <span class="ql-formula" data-value="Q">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8777699999999999em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></span>﻿</span> holds (postconditions)</li></ul><p><br></p><p>Removing some preconditions is called <strong>weakening the preconditions.</strong> You could do this when you actually want to change the responsibility from the caller to the callee. But, this does mean you will have to do checking in the method itself! The method is guaranteed to succeed as long as the caller meets the preconditions.</p><p><br></p><h2 id="invariant">Invariant</h2><p>An invariant is a condition that holds throughout the lifetime of a system, an object or a data-structure.</p><p><br></p><p>A possible implementation of this invariant is a checker method which for example checks the entire data-structure. This would traverse the structure and asserts as much as possible. You could also return a boolean representing the correctness of the data structure.</p><p><br></p><p>An assertion <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span> is a class invariant for class <span class="ql-formula" data-value="C">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>﻿</span> if all public methods and constructors of <span class="ql-formula" data-value="C">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>﻿</span> when applied to arguments satisfying the methods precondition yield a state satisfying <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span>. Some preconditions from some method can be moved to <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span>.</p><p><br></p><h2 id="interfaces-as-contracts">Interfaces as contracts</h2><p>A client and a server are bound by a contract. An interface is a contract, which ensures certain effects will happen provided assumptions are true. So for example: the server promises to do its job (defined by the postconditions) as long as the client sticks to the rules (defined by the preconditions). </p><p><br></p><p>If the interface defines a postcondition, the implementation (subcontract) of that might even be "stronger"  than the definition in the interface. It should <strong>ensure no less, </strong>but it can ensure more.</p><p>If the interface defines a precondition, the implementation of that might even be "weaker"  than the definition in the interface. It should <strong>require no more</strong>, but it can require less.</p><p>If the interface defines an invariant, the implementation of that should also hold, but might even be "stronger" than the definition in the interface.</p><p><br></p><h3 id="liskov-substitution-principle">Liskov substitution principle</h3><p>If you use class <span class="ql-formula" data-value="T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span>, you should be allowed to substitute <span class="ql-formula" data-value="T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span> for any subclass <span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span> of <span class="ql-formula" data-value="T">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span>. This is because the contract is guaranteed to hold across subclasses.</p><p><br></p><h3 id="parallel-test-hierarchy">Parallel test hierarchy</h3><p>Using these interfaces and implementations, we create a general test for the interface which is executed for each implementation. Each implementation also has its own, specific tests.</p><p><br></p><h2 id="property-based-testing">Property-based testing</h2><p>Think of properties that should hold for functions. A generator will produce a series of random input values for a function. For each random input, it'll check whether the properties (assertions) still hold. If not, failing test!</p><p><br></p><p>In JUnit, you can use the @Property annotation to annotate a property. Then, JUnit will generate random values as inputs. The mode for this is called QuickCheck. You can also write your own data generators and constrain the data generated by JUnit.</p>