+++
title = "Mutation Testing"
date = 2020-01-14
+++
<h1 id="mutation-testing">Mutation testing</h1><p><strong>Mutation testing </strong>is used to design new software tests and evaluate the quality of existing software tests.&nbsp;</p><p><br></p><p>We judge how good the tests are based on <strong>adequacy</strong>, which measure how thoroughly our test suite exercises the program under analysis. Common criteria for white-box testing include path and branch coverage. </p><p><br></p><p>But, coverage doesn't tell the entire story. For example you can get 100% coverage without any assertions (but then tests are useless). Having good <strong>input parameters</strong> and <strong>oracles </strong>(assertions) makes tests of higher quality.</p><p><br></p><p>So, the idea of mutation testing is that you insert artificial defects (<strong>mutants</strong>) in the production code to assess the quality of the test code. A test suite is <strong>effective </strong>if at least one of its test cases fails when executing the test suite against the mutants. Mutation testing is like testing the tests.</p><p><br></p><p>A mutant is defined as follows: given a program <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span>, a mutant <span class="ql-formula" data-value="P'">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">P&amp;#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> is obtained by introducing a <strong>simple syntactic</strong> <strong>change </strong>to <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span>. </p><ul><li>A <strong>syntactic change</strong> is a small change that makes the mutated code valid, so it can still be compiled</li><li>A <strong>change </strong>is an alteration to the production code that mimics typical human mistakes</li></ul><p><br></p><h1 id="mutation-operators">Mutation operators</h1><p>How do we decide which mutants to use? We use 2 hypotheses to decide this.</p><p><br></p><h3 id="the-competent-programmer-hypothesis">The Competent Programmer Hypothesis</h3><p>Given a specification, a programmer develops a program that is either correct or differs from the correct programs by a combination of simple errors. So, there won't be any big errors in a program if it works properly</p><p><br></p><h3 id="coupling-effect">Coupling effect</h3><p>Test cases that detect simple types of faults can also discover more complex forms of faults.</p><p><br></p><p>So, by the coupling effect, our mutations should be small, as we can detect smaller faults then. These smaller faults lead to the discovery of more complex forms of faults.</p><p><br></p><h2 id="generating-mutants">Generating mutants</h2><p>We define <strong>mutation operators </strong>as rules to apply syntactic changes to the code under test. There are two types of operators:</p><ul><li><strong>Real fault based operators: </strong>operators that apply changes very similar to defects seen in the past for the same code</li><li><strong>Language-specific operators: </strong>mutations for the inheritance in Java, mutations for pointers in C etc.</li></ul><p><br></p><h3 id="basic-operators">Basic operators</h3><p>Here are a few basic operators:</p><ul><li>Arithmetic Operator Replacement (<strong>AOR</strong>): (e.g. replacing <span class="ql-formula" data-value="+">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">+</span></span></span></span></span>﻿</span> by <span class="ql-formula" data-value="\times">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">×</span></span></span></span></span>﻿</span>. We could also skip the operation and just use one of the operands as the result (e.g. replacing <span class="ql-formula" data-value="\frac{a}{b}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.040392em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.6550000000000002em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>﻿</span> by <span class="ql-formula" data-value="a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span>)</li><li>Relational Operator Replacement (<strong>ROR</strong>): e.g. replacing <span class="ql-formula" data-value="==">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">==</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span></span></span></span></span>﻿</span> by <span class="ql-formula" data-value="<">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&amp;lt;</mo></mrow><annotation encoding="application/x-tex">&amp;lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span></span></span></span></span>﻿</span></li><li>Conditional Operator Replacement (<strong>COR</strong>): e.g. replacing <span class="ql-formula" data-value="\mid\mid">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mrel">∣</span></span></span></span></span>﻿</span> by <span class="ql-formula" data-value="\&amp;\&amp;">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&amp;amp;</mi><mi mathvariant="normal">&amp;amp;</mi></mrow><annotation encoding="application/x-tex">\&amp;amp;\&amp;amp;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">&amp;</span><span class="mord">&amp;</span></span></span></span></span>﻿</span> </li><li>Assignment Operator Replacement (<strong>AOR</strong>): e.g. replacing <span class="ql-formula" data-value="=">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span></span></span></span></span>﻿</span> by <span class="ql-formula" data-value="+=">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">+=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">+</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span></span>﻿</span></li><li>Scalar Variable Replacement (<strong>SVR</strong>): each variable is replaced with another variable reference of the same type that is already declared in the code</li></ul><p><br></p><h1 id="mutation-score">Mutation score</h1><p>If a test suite fails when a mutant is used even though it succeeds without mutant, we kill the mutant (thus our test is adequate for this mutant). When a mutant isn't killed (thus in both cases, the tests succeed), the test is bad.</p><p><br></p><p>Measuring this is done using a <strong>mutation score. </strong>This score is defined as the number of killed mutants divided by the number of mutants. Some more terminology</p><ul><li><strong>Mutation analysis: </strong>assessing the quality of the test suite by computing the mutation score</li><li><strong>Mutation testing: </strong>improving the quality of the test suite using mutants (i.e. adding or changing test cases)</li></ul><p><br></p><p>Though, this score doesn't tell the entire story. If we have a mutant <span class="ql-formula" data-value="M">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span></span></span></span></span>﻿</span> that is <strong>equivalent, </strong>it means that it's functionally equivalent to the original program <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span>. Them being equivalent means that they produce the same outputs if they receive the same input for all possible inputs. So, in our mutation score becomes the following:</p><div style="white-space: normal;" class="markdown-body"><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Mutation&nbsp;score</mtext><mo>=</mo><mfrac><mrow><mi mathvariant="normal">#</mi><mtext>Killed&nbsp;mutants</mtext></mrow><mrow><mi mathvariant="normal">#</mi><mtext>Non-Equiv.&nbsp;Mutants</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{Mutation score}=\frac{\#\text{Killed mutants}}{\#\text{Non-Equiv. Mutants}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Mutation&nbsp;score</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4133239999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">#</span><span class="mord text mtight"><span class="mord mtight">Non-Equiv.&nbsp;Mutants</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">#</span><span class="mord text mtight"><span class="mord mtight">Killed&nbsp;mutants</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
</div><p>But, mutation testing costs a lot of performance. There are a few optimization techniques:</p><ul><li><strong>Observation 1: </strong>a mutant cannot be killed if the test suite does not cover the statement where the syntactic change is injected (<strong>reachability condition</strong>)</li><li class="ql-indent-1"><strong>Heuristic 1: </strong>we only run test cases that cover the target mutant</li><li class="ql-indent-1"><strong>Heuristic 2: </strong>if a mutant is already killed, we don't need to execute the remaining test</li><li><strong>Observation 2: </strong>mutants generated by the same operator and injected in the same location are likely coupled to the same real faults</li><li class="ql-indent-1"><strong>Heuristic 3: </strong>consider only a subset of the generated mutants. The most straightforward way is random sampling</li></ul><p><br></p><h1 id="genetic-testing">Genetic testing</h1><p>In order to generate tests, we need to generate values for constructors and methods and check the result of that automatically. This requires a <strong>genetic algorithm</strong>: a search algorithm inspired by evolution theory. Such an algorithm works with natural evolution:</p><ol><li><strong>Natural selection</strong>: individuals that best fit the natural environment survive (worst die)</li><li><strong>Reproduction: </strong>survived individuals generate offspring</li><li><strong>Mutation: </strong>offspring inherits properties of its parents (with some mutations)</li><li><strong>Iteration: </strong>generation by generation the new offspring fits the environment better than its ancestor</li></ol><p><br></p><h2 id="control-flow-graph">Control flow graph</h2><p>A control flow graph illustrates where decisions are made and thus the execution of the program can go in multiple ways:</p><p><img src="https://i.imgur.com/mtkxg2D.png" width="463"></p><p><em>Image taken from slides by Annibale Panichella</em></p><h3 id=""><br></h3><h2 id="fitness-function">Fitness function</h2><p>We want to know how well our randomly generated tests test the code we want to test. A very simple heuristic (or <strong>fitness function</strong>) would be: <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> if it does test what we want, <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span> if it doesn't. Logically, this is quite bad, it doesn't provide any guidance as to what we need to change in order to get our <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span> to a <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> (<strong>flag problem</strong>).</p><p><br></p><div style="white-space: normal;" class="markdown-body"><p>For statement (or branch) coverage, given a specific coverage target <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>, a widely used fitness function is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>approach_level</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mtext>branch_distance</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)=\text{approach\_level}(P(x), t) + \text{branch\_distance}(P(x), t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">approach_level</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">branch_distance</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></p>
</div><h3 id="approach-level">Approach level</h3><p>In order to get guidance as to how well our fitness function performs, we can use the approach level.</p><p><br></p><p>Given the execution trace obtained by running program <span class="ql-formula" data-value="P">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">P</span></span></span></span></span>﻿</span> with test case <span class="ql-formula" data-value="x">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>﻿</span>, the approach level is the minimum number of control nodes between an executed statement and the coverage target <span class="ql-formula" data-value="t">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">t</span></span></span></span></span>﻿</span>.</p><p><br></p><p>So: how many control nodes would have had to be different in order to reach a certain statement or the amount of branches leading to the target that the test didn't take..</p><p><br></p><h3 id="branch-distance">Branch distance</h3><p>Given the first control node where the execution diverges from the target t, the predicate at such node is converted to a distance (from taking the desired branch), normalized between <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>. Such a distance measures how far the test case is from taking the desired branch. </p><p><br></p><p>In the appendix you can see how to calculate this for different types of statements.</p><p><br></p><p>We can normalize this branch distance by executing <span class="ql-formula" data-value="\frac{d}{d+1}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{d}{d+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.283439em; vertical-align: -0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801079999999999em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.403331em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>﻿</span>, where <span class="ql-formula" data-value="d">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">d</span></span></span></span></span>﻿</span> is calculated using the techniques in the appendix.</p><p><br></p><h2 id="algorithm">Algorithm</h2><p>Using genetic algorithms we want to automatically generate test cases to achieve maximum statement coverage. This is done in stages:</p><p><br></p><h3 id="initial-population"><strong>Initial population</strong></h3><p>The initial population is a set of randomly generated test cases. We can apply the same procedure used in random testing for the initial population (generating inputs for classes and methods).</p><p><br></p><h3 id="selection">Selection</h3><p>We can use <strong>tournament selection:</strong></p><ol><li>Randomly choose pairs of test cases (solutions)</li><li>Select the fittest (better) individuals from each pair</li></ol><p><br></p><h3 id="crossover">Crossover</h3><p>It takes two parents and cuts their chromosome strings at some randomly chosen position and the produced substrings are then swapped to produce two new full-length chromosomes</p><p><br></p><p>The one-point crossover probability indicates the number of test cases that will be included in the mutation. At this point, you take the pairs of parents and you randomly choose a cut-point for each of the pair. Now you only have to create two offsprings for each of the parents taking into account the cut-point.</p><p><br></p><h3 id="mutation">Mutation</h3><p>Mutation: randomly changes some genes (elements within each chromosome).</p><p><br></p><p>Mutation probability: <span class="ql-formula" data-value="\frac{1}{n}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.190108em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.845108em;"><span class="" style="top: -2.6550000000000002em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>﻿</span> where <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> is the chromosome length.</p><p><br></p><h1 id="appendix">Appendix</h1><h2 id="branch-distance">Branch distance</h2><p>For boolean and numerical variables <span class="ql-formula" data-value="a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span>, <span class="ql-formula" data-value="b">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>﻿</span>:</p><p><img src="https://i.imgur.com/6CfOwgq.png" width="364"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>For string variables <span class="ql-formula" data-value="a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span>, <span class="ql-formula" data-value="b">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>﻿</span>:</p><p><img src="https://i.imgur.com/rfnOpdd.png" width="382"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>For composite predicates:</p><p><img src="https://i.imgur.com/6btZpQm.png" width="383"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p>