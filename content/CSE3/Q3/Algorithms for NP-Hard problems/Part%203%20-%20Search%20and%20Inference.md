+++
title = "Part 3 - Search and Inference"
date = 2021-03-23
+++
<h1 id="exhaustive-search-(lecture-1)">Exhaustive search (lecture 1)</h1><p>An algorithm that explores every possible combination, either explicitly or implicitly can be considered <strong>exhaustive search</strong>.</p><p>Besides exhaustive search, you can use <strong>inference </strong>to... infer information before you run a search algorithm.</p><p><br></p><ul><li><strong>Pros: </strong>exhaustive search is the ideal algorithm because it searches everything</li><li><strong>Cons: </strong>it is not scalable. Algorithms for NP-hard problems are essentially sophisticated brute force approaches which will yield exponential time in the worst cases</li></ul><p><br></p><p>It depends on the problem and the implementation how expensive doing exhaustive search is.</p><p><br></p><h3 id="generating-binary-strings">Generating binary strings</h3><p><strong>Problem: </strong>generate all binary strings of length <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> </p><p><strong>Solution:</strong></p><ol><li>For each element <span class="ql-formula" data-value="0..n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0..</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">0..n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span>, add a <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span></li><li>For each element <span class="ql-formula" data-value="0..n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0..</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">0..n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span>, add a <span class="ql-formula" data-value="1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> </li><li>Merge these two</li></ol><p><br></p><h3 id="possible-combinations">Possible combinations</h3><p><strong>Problem: </strong>generate all <strong>combinations </strong>(ordering is not important) without repetition of size <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> </p><p><strong>Solution 1:</strong></p><ol><li>Represent each combination as a binary string: e.g. <span class="ql-formula" data-value="00110\to\left\{c,d\right\}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>00110</mn><mo>→</mo><mrow><mo fence="true">{</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">00110\to\left\{c,d\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">{</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose delimcenter" style="top: 0em;">}</span></span></span></span></span></span>﻿</span> </li><li>Generate all binary strings of length <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span>, keep only the ones with exactly <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> bits set to one</li></ol><p><br></p><p><strong>Solution 2:</strong></p><ol><li>Define an ordering <span class="ql-formula" data-value="a<b<c<d<e">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&amp;lt;</mo><mi>b</mi><mo>&amp;lt;</mo><mi>c</mi><mo>&amp;lt;</mo><mi>d</mi><mo>&amp;lt;</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a&amp;lt;b&amp;lt;c&amp;lt;d&amp;lt;e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">e</span></span></span></span></span>﻿</span> </li><li>Start a subset of size <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span>  </li><li>Promote each element to a higher letter until you can no longer promote any</li></ol><p><br></p><h3 id="possible-permutations">Possible permutations</h3><p><strong>Problem: </strong>generate all <strong>permutations </strong>(ordering is important) without repetition of size <span class="ql-formula" data-value="k">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span>﻿</span> </p><p><strong>Solution:</strong></p><ol><li>Consider <span class="ql-formula" data-value="a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span></li><li>Consider all permutations of the remaining elements</li><li>For each such permutation, add <span class="ql-formula" data-value="a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span> to the start</li><li>Continue for all other elements</li></ol><p><br></p><h1 id="constraints-(lecture-2)">Constraints (lecture 2)</h1><p>If there are constraints, you can be lazy and just generate all possible options and filter those:</p><ul><li><strong>Pro: </strong>easy to implement and to add constraints</li><li><strong>Con: </strong>may be very slow</li><li><strong>When to use: </strong>if the constraints are weak, i.e. not many options are filtered</li></ul><p><br></p><p>Another option is creating a specialized algorithm:</p><ul><li><strong>Pro: </strong>can be optimal for the problem</li><li><strong>Con: </strong>many problems may require similar but not exact the same solutions</li></ul><p><br></p><h2 id="backtracking">Backtracking</h2><p>Therefore we want to generate an algorithm that we can reduce other problems to: <strong>backtracking with pruning:</strong></p><ol><li>We have a problem with variables (slots). For each variable we have to place some value from a domain.</li><li>When we place a value into a variable, we check the constraints. If they are fine: continue, else: stop</li></ol><p><br></p><p>A <strong>partial</strong> <strong>solution</strong> is an assignment of values to a subset of the variables.</p><p>A <strong>full solution</strong> is an assignment of values to all variables.</p><p><br></p><p>A partial/full solution is <strong>infeasible</strong> if at least one constraint is violated.</p><p><br></p><h3 id="example">Example</h3><p>For example, we may have 4 variables: <span class="ql-formula" data-value="\left[V1\right]\ \left[V2\right]\ \left[V3\right]\ \left[V4\right]">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mi>V</mi><mn>1</mn><mo fence="true">]</mo></mrow><mtext>&nbsp;</mtext><mrow><mo fence="true">[</mo><mi>V</mi><mn>2</mn><mo fence="true">]</mo></mrow><mtext>&nbsp;</mtext><mrow><mo fence="true">[</mo><mi>V</mi><mn>3</mn><mo fence="true">]</mo></mrow><mtext>&nbsp;</mtext><mrow><mo fence="true">[</mo><mi>V</mi><mn>4</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[V1\right]\ \left[V2\right]\ \left[V3\right]\ \left[V4\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="mord">1</span><span class="mclose delimcenter" style="top: 0em;">]</span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="mord">2</span><span class="mclose delimcenter" style="top: 0em;">]</span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="mord">3</span><span class="mclose delimcenter" style="top: 0em;">]</span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="mord">4</span><span class="mclose delimcenter" style="top: 0em;">]</span></span></span></span></span></span>﻿</span> with certain constraints.</p><p><br></p><p>We do the following:</p><ol><li>Remove values from domains based on the constraints (propagation / inference / deduction / pruning)</li><li>If there are any variables with empty domains (e.g. the domain of <span class="ql-formula" data-value="\left[V2\right]=\left\{\right\}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mi>V</mi><mn>2</mn><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">{</mo><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\left[V2\right]=\left\{\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="mord">2</span><span class="mclose delimcenter" style="top: 0em;">]</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">{</span><span class="mclose delimcenter" style="top: 0em;">}</span></span></span></span></span></span>﻿</span>)</li><li class="ql-indent-1">If yes, backtrack. If this is not possible, the problem is infeasible.</li><li class="ql-indent-1">If no, proceed.</li><li>Pick a variable</li><li>Pick a value from its domain and assign it</li><li>Check if we have a full solution</li><li class="ql-indent-1">If yes, we are done</li><li class="ql-indent-1">If no, repeat recursively from the beginning (step 1)</li></ol><p><br></p><p>Backtracking with pruning is at the heart of modern optimization approach,</p><p><br></p><h1 id="combinatorial-search-(lecture-3)">Combinatorial search (lecture 3)</h1><p>In <strong>combinatorial search</strong>, you represent (model) a problem and efficiently find a solution in a large search space. </p><p><br></p><p>To solve it, we have two main components:</p><ul><li><strong>A model: </strong>If you model the problem well, it can help you find solutions and capture difficult constraints easier.</li><li><strong>An algorithm to find solutions: </strong>e.g. backtracking with pruning</li></ul><p><br></p><p>There are a few issues with such models:</p><ul><li>If the main components are connected, it is difficult to reason about them independently</li><li>There are many equivalent ways to model the same problems which may yield different results</li><li>There's not a lot of theory to guide you: it's mostly experience &amp; trial-and-error</li><li>Symmetries are almost always a problem</li></ul><p><br></p><h3 id="symmetries">Symmetries</h3><p>Given a problem representation, define an <strong>equivalence class</strong> over solutions:</p><ul><li>Many different solutions may be fundamentally the same. We want to avoid these symmetric solutions, since they make our search space a lot larger.</li><li>Equivalence class has a <strong>representative solution</strong>, and the others are considered infeasible. This reduces the amount of options by a lot.</li><li>Equivalence solutions may be easily derived based on the representative</li></ul><p><br></p><p>Equivalence-avoidance is enforced with symmetry breaking constraints. It may be easy to define these equivalence classes but this is definitely not always the case: sometimes removing symmetries costs a lot of performance (more constraints to check).</p><p><br></p><h1 id="look-ahead-(lecture-4)">Look-Ahead (lecture 4)</h1><p>In backtracking algorithms, <strong>look ahead</strong> is the generic term for a subprocedure that attempts to foresee the effects of choosing a branching variable to evaluate one of its values. The two main aims of look-ahead are to choose a variable to evaluate next and the order of values to assign to it.</p><p><br></p><p>Given a partial solution and a candidate assignment to evaluate, search for another unassigned variable (i.e. a domain of larger than 1) which can take a consistent value.</p><p><br></p><p>We can improve upon this by using <strong>arc consistency</strong>: given is a constraint and a pair of variables. For each value of the first variable:</p><ul><li>Check if there exists a feasible assignment of the second variable</li><li>If no assignment exists, then remove the value from the first variable</li><li>Repeat by swapping the roles of the first and second variable</li></ul><p><br></p><p>For look-ahead, this comes down to: for each variable and value</p><ul><li>Make the assignment</li><li>Propagate</li><li>Record information about (parts) of the resulting state space. This can be for example that if you assign <span class="ql-formula" data-value="x=1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span>, based on constraints <span class="ql-formula" data-value="y">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">y</span></span></span></span></span>﻿</span> must be <span class="ql-formula" data-value="0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="z">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span style="margin-right: 0.04398em;" class="mord mathdefault">z</span></span></span></span></span>﻿</span> can now only be <span class="ql-formula" data-value="\left\{0,2\right\}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left\{0,2\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose delimcenter" style="top: 0em;">}</span></span></span></span></span></span>﻿</span></li><li>Undo the assignment</li><li>Infer more information based on the collected information</li></ul><p><br></p><p>This prunes the search space a lot but can be expensive to compute.</p><p><br></p><h2 id="relaxations">Relaxations</h2><p>We can also simplify the problem or constraint and infer based on that. If such an easier constraint is violated, so is the more complicated. This can save a lot of computation time. </p><p><br></p><p>The following problems illustrate relaxations.</p><p><br></p><p><strong>Linear inequalities where variables take integer values</strong></p><ul><li>Relax integer values to continuous values</li><li>If problem is not satisfiable, then the integer version is not satisfiable</li></ul><p><br></p><p><strong>All-different</strong></p><ul><li>Relax to the number of unique domain values must be at least the number of variables</li><li>If the relaxed version is not satisfiable, then all-difference is not</li></ul><p><br></p><p><strong>Shortest path with additional constraints</strong></p><ul><li>Relax to the standard shortest path problem (without constraints)</li><li>If the relaxed version is not satisfiable, then the constrained version is not satisfiable</li></ul>