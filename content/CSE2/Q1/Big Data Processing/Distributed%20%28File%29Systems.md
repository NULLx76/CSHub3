+++
title = "Distributed (File)Systems"
date = 2019-09-15
+++
<h2 id="parallel-vs-distributed-vs-hpc">Parallel vs distributed vs HPC</h2><p>In <strong>parallel computing</strong>, we have a shared memory architecture, where all CPUs can access the entire memory using an interconnect.</p><p><br></p><p>In <strong>distributed</strong> <strong>computing, </strong>there are no shared components. The different computers are connected through a network. The challenge of this approach in comparison to parallel computing is that every computer is individual. The computers send messages to each other to communicate that a job needs to be run. We move compute to where the data is, as it's very costly to move data around.</p><p><br></p><p>In <strong>high performance computers, </strong>we have a single computer with many CPUs which all have their own memory. Here we move data to where the compute is.</p><p><br></p><h1 id="distributed-systems-problems">Distributed systems problems</h1><p>Some fallacies of distributed systems:</p><ul><li>Network is reliable</li><li>Latency is zero</li><li>Bandwidth is infinite</li><li>The network is secure</li><li>Topology does not change</li><li>Transport cost is zero</li><li>The network is homogeneous</li></ul><p><br></p><p>Unfortunately, this is not true for networks. There are some main problems when it comes to distributed systems:</p><p><br></p><h2 id="networks-are-unreliable"><strong>Networks are unreliable</strong></h2><p>Distributed systems need to share data over unreliable networks. We need to know if a message arrives at a receiver, but a few problems can occur:</p><ul><li>Request / response message can be lost</li><li>Recipient / sender can crash</li></ul><p><br></p><p>As networks are asynchronous we need to set a timeout in order to mark a message as "lost"</p><p><br></p><h3 id="byzantine-agreement"><strong>Byzantine agreement</strong></h3><ul><li>Take the two armies problem (see CN), if there are <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> armies with its own general</li><li>The generals have to exchange the strength of their troops</li><li>The communication links are <strong>reliable</strong></li><li><strong>Traitors </strong>may lie about their strengths</li><li>The generals <strong>have to agree </strong>on he vector of troop strength</li></ul><p><br></p><p>Lies can be detected by traitors giving different information to different generals. This can be solved by creating a vector of all the received troop strengths and compare them to the vectors of other armies. If there is a discrepancy, there has been a lie. In distributed systems, we are talking about systems failing or returning invalid data (which may not be deliberate). Despite this imperfect information the machines still have to agree on a strategy.</p><p><br></p><h2 id="unreliable-time"><strong>Unreliable time</strong></h2><p>Distributed systems need time to determine order, but then we have to make sure that their times are synced</p><p><br></p><p>It is possible that you send 2 requests, but the first request arrives later than the second request. This can give a lot of problems. We could guarantee use FIFO, but this is only good enough for a single sender. </p><p><br></p><p>If we have a low message rate, we can use timestamps to guarantee order (<strong>total order</strong>). But otherwise, we need to rely on <em>happens before </em>relationships (<strong>casual order</strong>).</p><p><br></p><p>The way to deal with this is by having each computer keep track of its own time, and synchronizing with a time server (using NTP) every now and then. But, this can still have an offset of a few milliseconds, which is too much.</p><p><br></p><h3 id="lampert-timestamps"><strong>Lampert Timestamps</strong></h3><p>In order to fix this, we can use Lampert Timestamps:</p><ul><li>Each individual process <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span> maintains a counter <span class="ql-formula" data-value="LT\left(p\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>p</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">LT\left(p\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">p</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span></li><li>When a process <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span> performs an action (whenever an event happens), it increments <span class="ql-formula" data-value="LT\left(p\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>p</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">LT\left(p\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">p</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> </li><li>When a process <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span> sends a message, it includes <span class="ql-formula" data-value="LT\left(p\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>p</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">LT\left(p\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">p</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> in the message</li><li>When a process <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span> receives a message from a process <span class="ql-formula" data-value="q">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">q</span></span></span></span></span>﻿</span> (which includes the value of <span class="ql-formula" data-value="LT\left(q\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">LT\left(q\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span style="margin-right: 0.03588em;" class="mord mathdefault">q</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>). Then <span class="ql-formula" data-value="p">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>﻿</span> updates its <span class="ql-formula" data-value="LT\left(p\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>p</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">LT\left(p\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">p</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> to <span class="ql-formula" data-value="\max\left(LT\left(p\right),\ LT\left(q\right)\right)+1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>p</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\max\left(LT\left(p\right),\ LT\left(q\right)\right)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">max</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">p</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span style="margin-right: 0.03588em;" class="mord mathdefault">q</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span></li><li>Now we know that if <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span> happened before <span class="ql-formula" data-value="B">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span></span></span>﻿</span> (<span class="ql-formula" data-value="A\to B">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span></span></span>﻿</span>), <span class="ql-formula" data-value="LT\left(a\right)<LT\left(b\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>a</mi><mo fence="true">)</mo></mrow><mo>&amp;lt;</mo><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>b</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">LT\left(a\right)&amp;lt;LT\left(b\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">a</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">b</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span></li></ul><p><br></p><p>But, Lampert Timestamps are not enough to conclude causality, as seen in an <a href="https://cshub.nl/post/207968564" target="_blank">example</a>. So <span class="ql-formula" data-value="A\to B\Rightarrow LT\left(a\right)<LT\left(b\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>⇒</mo><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>a</mi><mo fence="true">)</mo></mrow><mo>&amp;lt;</mo><mi>L</mi><mi>T</mi><mrow><mo fence="true">(</mo><mi>b</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">A\to B\Rightarrow LT\left(a\right)&amp;lt;LT\left(b\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">a</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">L</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">b</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>, which is not a bi-implication!</p><p><br></p><h3 id="vector-clocks"><strong>Vector clocks</strong></h3><p>Using vector clocks we can maintain <strong>total causal order</strong>. On a system with <span class="ql-formula" data-value="N">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">N</span></span></span></span></span>﻿</span> nodes, each node <span class="ql-formula" data-value="i">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>﻿</span> maintains a vector <span class="ql-formula" data-value="V_i">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.31166399999999994em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> of size <span class="ql-formula" data-value="N">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">N</span></span></span></span></span>﻿</span>:</p><ul><li><span class="ql-formula" data-value="V_i\left[i\right]">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mrow><mo fence="true">[</mo><mi>i</mi><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">V_i\left[i\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.31166399999999994em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord mathdefault">i</span><span class="mclose delimcenter" style="top: 0em;">]</span></span></span></span></span></span>﻿</span> is the number of events that occurred at node <span class="ql-formula" data-value="i">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>﻿</span> </li><li><span class="ql-formula" data-value="V_i\left[j\right]">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mrow><mo fence="true">[</mo><mi>j</mi><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">V_i\left[j\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.31166399999999994em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span style="margin-right: 0.05724em;" class="mord mathdefault">j</span><span class="mclose delimcenter" style="top: 0em;">]</span></span></span></span></span></span>﻿</span> is the number of events that node <span class="ql-formula" data-value="i">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>﻿</span> knows occurred at node <span class="ql-formula" data-value="j">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05724em;" class="mord mathdefault">j</span></span></span></span></span>﻿</span></li></ul><p><br></p><p>These numbers are updated as follows:</p><ul><li>Local events increment <span class="ql-formula" data-value="V_i\left[i\right]">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mrow><mo fence="true">[</mo><mi>i</mi><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">V_i\left[i\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.31166399999999994em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord mathdefault">i</span><span class="mclose delimcenter" style="top: 0em;">]</span></span></span></span></span></span>﻿</span> </li><li>When <span class="ql-formula" data-value="i">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>﻿</span> sends a message to <span class="ql-formula" data-value="j">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05724em;" class="mord mathdefault">j</span></span></span></span></span>﻿</span>, it includes <span class="ql-formula" data-value="V_i">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.31166399999999994em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> </li><li>When <span class="ql-formula" data-value="j">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05724em;" class="mord mathdefault">j</span></span></span></span></span>﻿</span> receives <span class="ql-formula" data-value="V_i">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.31166399999999994em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span>, it updates all elements of <span class="ql-formula" data-value="V_j">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.969438em; vertical-align: -0.286108em;"></span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span style="margin-right: 0.05724em;" class="mord mathdefault mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>﻿</span> to <span class="ql-formula" data-value="V_j\left[a\right]=\max\left(V_i\left[a\right],\ V_j\left[a\right]\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>j</mi></msub><mrow><mo fence="true">[</mo><mi>a</mi><mo fence="true">]</mo></mrow><mo>=</mo><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msub><mi>V</mi><mi>i</mi></msub><mrow><mo fence="true">[</mo><mi>a</mi><mo fence="true">]</mo></mrow><mo separator="true">,</mo><mtext>&nbsp;</mtext><msub><mi>V</mi><mi>j</mi></msub><mrow><mo fence="true">[</mo><mi>a</mi><mo fence="true">]</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">V_j\left[a\right]=\max\left(V_i\left[a\right],\ V_j\left[a\right]\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.036108em; vertical-align: -0.286108em;"></span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span style="margin-right: 0.05724em;" class="mord mathdefault mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord mathdefault">a</span><span class="mclose delimcenter" style="top: 0em;">]</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1.036108em; vertical-align: -0.286108em;"></span><span class="mop">max</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.31166399999999994em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord mathdefault">a</span><span class="mclose delimcenter" style="top: 0em;">]</span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="mord"><span style="margin-right: 0.22222em;" class="mord mathdefault">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span style="margin-right: 0.05724em;" class="mord mathdefault mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord mathdefault">a</span><span class="mclose delimcenter" style="top: 0em;">]</span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> (updating with respect to the vectors it received)</li></ul><p><br></p><p>This is better than Lampert Timestamps, but very expensive. The more machines, the larger the vector will become on every machine.</p><h3 id=""><br></h3><h2 id="a-single-source-of-truth"><strong>A single source of truth</strong></h2><p>Distributed systems need to agree on their response (they often need a majority in order for a response to be sent). A correct consensus protocol fulfills the criteria:</p><ul><li><strong>Termination </strong>- every correct process decides some value</li><li><strong>Integrity </strong>- if all the correct processes proposed the same value <span class="ql-formula" data-value="v">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">v</span></span></span></span></span>﻿</span>, then any correct process must decide <span class="ql-formula" data-value="v">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">v</span></span></span></span></span>﻿</span> </li><li><strong>Agreement </strong>- every correct process must agree on the same value</li></ul><p><br></p><p>There is an <strong>upper bound</strong> of how many "traitors" there can be in a distributed systems. We need a majority machines agreeing with each other, otherwise there is no truth.</p><p><br></p><p>The easiest way to maintain a single source of truth is by having a leader. When this leader goes down, we need to elect a new one. We can do that using the raft consensus algorithm, which offers a way to distribute state changes over a cluster of machines.</p><p><br></p><p><strong>Raft</strong></p><ul><li><strong>Safety: </strong>never returns an incorrect result in the presence of non-Byzantine conditions</li><li><strong>Availability: </strong>is able to provide an answer if the majority of the servers are operational</li><li><strong>No clocks: </strong>doesn't depend on RTCs to work</li><li><strong>Immune to stragglers: </strong>if a server votes late (is slow but not offline, a straggler), it will still work</li></ul><p><br></p><p>Note that Raft is not Byzantine fault tolerant as the nodes trust the elected leader.</p><p><br></p><p>To detect staleness, messages are exchanged. When the leader goes down, we have elections, but during these elections we won't have a leader.</p><p><br></p><h2 id="different-opinions"><strong>Different opinions</strong></h2><p>Distributed systems need to provide guarantees that their response is consistent. We can have:</p><ul><li><strong>Strong consistency</strong>: at any time, concurrent reads from any node return the same values</li><li><strong>Eventual consistency</strong>: if writes stop, all reads will return the same value after a while</li></ul><p><br></p><p>See <a href="https://cshub.nl/post/432387753" target="_blank">DHTs</a> and the CAP theorem.</p><p><br></p><h1 id="distributed-file-systems">Distributed file systems</h1><h2 id="databases">Databases</h2><p>A lot of this has been covered in IDM already, so that won't be duplicated here.</p><p><br></p><h3 id="replication">Replication</h3><p>We use replication to:</p><ul><li>Allow the system to work even if parts are down</li><li>Have the data (geographically) close to data clients</li><li>Increase read throughput, by allowing more machines to serve read-only requests</li></ul><p><br></p><p>The bad part of replication:</p><ul><li>If we take the CAP theorem into account we get lower performance</li><li>Bandwidth may cost more than re-computation</li><li>Storage could run out</li></ul><p><br></p><p>In replication we have two types of roles:</p><ul><li><strong>Leaders</strong>: nodes that accept writes</li><li><strong>Slaves / replicas</strong>: nodes that provide read-only access to data</li></ul><p><br></p><p>This gives us the following schemes:</p><ul><li><strong>Master-slave</strong>: master accepts writes, which are distributed to slaves</li><li><strong>Master-master</strong>: multiple master accept writes, keep themselves in sync and then update slaves</li><li><strong>Leaderless replication</strong>: all nodes are peers</li></ul><p><br></p><p>There are two types of replication:</p><ul><li><strong>Synchronously</strong>: writes need to be confirmed by a configurable number of slaves before the master reports success</li><li><strong>Asynchronously</strong>: the master reports success immediately after a write was commit to its own disk; slaves apply changes in their own pace</li></ul><p><br></p><h3 id="partitioning">Partitioning</h3><p>Partitioning spreads data over different partitions. There are three ways of dividing data:</p><ol><li>List partitioning: grouping data based on membership of a certain group</li><li>Range partitioning: grouping data based on a certain range of a property</li><li>Hash partitioning: grouping data based on hashcode</li></ol><p><br></p><h3 id="achieving-serializability">Achieving serializability</h3><p>For more on serializability, see IDM.</p><p><br></p><p>We can achieve serializability by:</p><ul><li>Only execututing on a <strong>single core</strong></li><li>Using <strong>2 phase locking</strong>, all database objects have a shared lock an an exclusive lock. An object has to be locked before it can participate in a transaction in a growing phase, and when a transaction unlocks one object it cannot lock any more objects.</li><li>Using <strong>multi-version concurrency control</strong> and copy-on-write data structures. Allow every transaction to work on their own version of the data and then resolve the merge conflicts afterwards.</li></ul><p><br></p><h3 id="distributed-transactions">Distributed Transactions</h3><p>In a distributed database, a transaction spanning multiple nodes must either succeed on all nodes or fail. All nodes must agree on whether a transaction has been successfully committed. If one node drops out during the transaction, the transaction fails.</p><p><br></p><h3 id="2pc">2PC</h3><p><strong>Voting phase:</strong></p><ul><li>Coordinator sends VOTE_REQ to all workers</li><li>Workers send VOTE_COMMIT or VOTE_ABORT</li><li>All workers need to send VOTE_COMMIT in order for a transaction to be committed</li></ul><p><br></p><p><strong>Completion phase</strong></p><ul><li>If all votes were VOTE_COMMIT, send GLOBAL_COMMIT to all workers, else send GLOBAL_ABORT</li><li>Workers commit or abort the transaction</li></ul><p><br></p><h2 id="file-systems">File systems</h2><h3 id="properties-of-file-systems">Properties of file systems</h3><ul><li>Files are organized in directories, directories themselves are files and contain a name and a pointer to file header table</li><li>Only an OS can modify a directory to ensure integrity of the mapping, but applications can read a directory</li></ul><p><br></p><h3 id="properties-of-directories">Properties of directories</h3><ul><li>Generalization of two-level directory</li><li>Every file is reachable from the root via a unique path name</li><li>In a directory we can have files or subdirectory</li><li>We distinguish between absolute and relative path names</li><li>Every process always has a "current directory"</li></ul><p><br></p><h2 id="gfs">GFS</h2><p>Google File System is used by many Google applications. It has a few clients and a central master, which points to all the blocks which are involved in files. All the data nodes just use the Linux file system.</p><p><br></p><p>There were a few design considerations which are optimized for scalability:</p><ol><li>Component failures are the norm (on a large scale we expect a lot of failures)</li><li>Files are huge by traditional standards (there are fast growing datasets with billions of objects)</li><li>Random writes within a files are practically non-existent (files are written once and read sequentially)</li><li>Sustained bandwidth more important than latency (data is processed in bulk at a high rate)</li></ol><p><br></p><p>The master provides the location of the data, but the data is never read/written through the master, but are directly handled by the Linux based servers.</p><p><br></p><p><strong>Chunks: </strong>In GFS, large, 64 MB chunks are used. Each chunk has a 64-bit GUID which has 3-way replication. Each replica is stored as a plain file on a Linux chunk server. All the chunk information obtained from the master is cached by the client.</p><p><strong>Metadata: </strong>Metadata is stored by the master. A lot is stored in in-memory data structures so master operations are fast. This enables quick background scans of the master state. On startup, the master polls the dynamic chunk servers</p><p><strong>Consistency Model: </strong>concurrent changes are consistent but undefined, clients see the same data but it may not reflect what any mutation has written. Each modification is applied in the same order to all replicas</p><p><br></p><p>Here is an image which illustrates the control and data flow of GFS:</p><p><img src="https://i.imgur.com/Bz3XvFZ.png" width="381"></p><p><strong>Master operations:</strong></p><ul><li>Locking: one read and write per path in filename tree. A read lock prevents a directory to be deleted, renamed or shapshotted </li><li>Replica placement: maximize data reliability and availability so spread replicas across machines and racks</li><li>Garbage collection: deleted files are renamed to hidden files and are removed after 3 days</li></ul>