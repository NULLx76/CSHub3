+++
title = "Introduction to Computer Graphics"
date = 2019-11-01
+++
<h1 id="producing-an-image">Producing an image</h1><p>The challenge we face when creating images is deciding which pixels to "use" in order to create the image we are looking for.</p><p><br></p><h2 id="mapping-a-3d-environment-onto-a-2d-image">Mapping a 3d environment onto a 2d image</h2><ul><li>Take a pixel on the image in the virtual world</li><li>Compute ray through pixel and camera center</li><li>Draw the pixel the same color as the first object the ray hits.</li></ul><p><br></p><h2 id="finding-the-intersection-">Finding the intersection </h2><p><img src="https://i.imgur.com/S80qyhC.png" width="452"></p><p>The intersection point between your current viewpoint and each part of the model can be calculated by <span class="ql-formula" data-value="R+tD=a+\beta\left(b-a\right)+\gamma\left(c-a\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>+</mo><mi>t</mi><mi>D</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>β</mi><mrow><mo fence="true">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo fence="true">)</mo></mrow><mo>+</mo><mi>γ</mi><mrow><mo fence="true">(</mo><mi>c</mi><mo>−</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">R+tD=a+\beta\left(b-a\right)+\gamma\left(c-a\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">t</span><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.05278em;" class="mord mathdefault">β</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.05556em;" class="mord mathdefault">γ</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> </p><p><br></p><p>Where:</p><ul><li><span class="ql-formula" data-value="R">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span></span></span></span></span>﻿</span> is the position of the eye</li><li><span class="ql-formula" data-value="D">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span></span></span></span></span>﻿</span> is the distance from the screen to the eye.</li><li><span class="ql-formula" data-value="t">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">t</span></span></span></span></span>﻿</span> is a multiplier of <span class="ql-formula" data-value="D">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span></span></span></span></span>﻿</span> </li><li><span class="ql-formula" data-value="a">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span>﻿</span>, <span class="ql-formula" data-value="b">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>﻿</span>  and <span class="ql-formula" data-value="c">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span>﻿</span> are the vertices of the triangle</li><li><span class="ql-formula" data-value="\beta">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05278em;" class="mord mathdefault">β</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="\gamma">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05556em;" class="mord mathdefault">γ</span></span></span></span></span>﻿</span>  allow you to move in the intersection point around the plane of the triangle</li></ul><p><br></p><p>This formula finds the points that lie on the line but also on the plane. We want to solve for <span class="ql-formula" data-value="t">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">t</span></span></span></span></span>﻿</span>, <span class="ql-formula" data-value="\beta">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05278em;" class="mord mathdefault">β</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="\gamma">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.05556em;" class="mord mathdefault">γ</span></span></span></span></span>﻿</span>, by solving the 3 equations obtained by calculating this for the <span class="ql-formula" data-value="x">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>﻿</span>, <span class="ql-formula" data-value="y">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">y</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="z">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span style="margin-right: 0.04398em;" class="mord mathdefault">z</span></span></span></span></span>﻿</span> axis</p><p>For example for <span class="ql-formula" data-value="x">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>﻿</span> you'd get <span class="ql-formula" data-value="R_x+tD_x=a_x+\beta\left(b_x-a_x\right)+\gamma\left(c_x-a_x\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>x</mi></msub><mo>+</mo><mi>t</mi><msub><mi>D</mi><mi>x</mi></msub><mo>=</mo><msub><mi>a</mi><mi>x</mi></msub><mo>+</mo><mi>β</mi><mrow><mo fence="true">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo>−</mo><msub><mi>a</mi><mi>x</mi></msub><mo fence="true">)</mo></mrow><mo>+</mo><mi>γ</mi><mrow><mo fence="true">(</mo><msub><mi>c</mi><mi>x</mi></msub><mo>−</mo><msub><mi>a</mi><mi>x</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">R_x+tD_x=a_x+\beta\left(b_x-a_x\right)+\gamma\left(c_x-a_x\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.00773em;" class="mord mathdefault">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.00773em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord mathdefault">t</span><span class="mord"><span style="margin-right: 0.02778em;" class="mord mathdefault">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.73333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.05278em;" class="mord mathdefault">β</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.05556em;" class="mord mathdefault">γ</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.5500000000000003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span></p><p><br></p><p>There could be multiple intersections (multiple objects in the current line), but then we choose the closest one (as the one in the back isn't supposed to be shown)</p><p><br></p><h2 id="color">Color</h2><p>Humans have three types of cones in our eyes, the S-cone, M-cone and L-cone. Each of them is sensitive to different wavelengths: blue, green and red respectively. </p><p><br></p><p>This is mimicked in computer graphics, we assume that each pixel on the screen contains only 3 colors, which can be combined to create (almost) all colors</p><p><br></p><h2 id="reflection">Reflection</h2><ul><li><strong>Diffuse</strong>: when a light hits a surface the light will be reflected in all directions</li><li><strong>Mirror</strong>: when a light hits a surface it will be reflected in the opposite direction</li></ul><p><br></p><p>In reality, these 2 extremes will never happen</p><p><br></p><h2 id="rendering">Rendering</h2><p>In appendix A you can find pseudocode for raytracing. But, this implementation is very bad, as the two loops are a big performance killer. A performance improvement is by grouping the triangles together, and if the rays don't hit the group, it won't hit any of the triangles inside of the group. This can be seen as binary sorting, where half of the options are eliminated each time (so instead of <span class="ql-formula" data-value="O\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> it will become <span class="ql-formula" data-value="O\left(\log n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(\log n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>). This technique can be called "building a structure", but this is still really slow. But, in the future this (probably) will be what is used.</p><p><br></p><p>The technique that is currently used is called rasterization. For each vertex it calculates where it would be on the screen, flattening the 3d model. A problem is multiple triangles which would be rendered in the same position. So: we need to find the closest triangle to the screen. Plainly sorting is very expensive, so we use a <strong>depth test. </strong>Besides storing the color, we also store the depth of each pixel. For each "duplicate" pixel, compare the saved depth to the new depth. If closer to the pixel, overwrite.</p><p><br></p><p>The cost of rasterization is much lower than ray tracing. In a simple approximation, ray tracing is about <span class="ql-formula" data-value="50">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></span>﻿</span> times more expensive compared to rasterization. But, as there are increasingly more triangles, raytracing will become more efficient than rasterization (in theory).</p><p><br></p><h3 id="non-local-problems">Non-Local problems</h3><ul><li><strong>Shadows</strong>, where to cast which shadow?</li><li><strong>Transmittance</strong>, how much light goes through the body?</li><li><strong>Refraction/translucency</strong>, how is the background portrayed?</li><li><strong>Collision detection</strong>, e.g. how do we handle collisions with water?</li><li><strong>Global illumination, </strong>how do we handle reflected (indirect) light?</li></ul><p><br></p><h1 id="images">Images</h1><p>Images are 2D-arrays of values. The sizes of the arrays is defined by the resolution of the image. The values of the array elements exist of 8-bit values of the red, green and blue colors. In total, this gives <span class="ql-formula" data-value="2^{8^3}=16777216">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msup><mn>8</mn><mn>3</mn></msup></msup><mo>=</mo><mn>16777216</mn></mrow><annotation encoding="application/x-tex">2^{8^3}=16777216</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.9869199999999999em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.9869199999999999em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8913142857142857em;"><span class="" style="top: -2.931em; margin-right: 0.07142857142857144em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">7</span><span class="mord">7</span><span class="mord">7</span><span class="mord">2</span><span class="mord">1</span><span class="mord">6</span></span></span></span></span>﻿</span> colors (which is the most common way of representing color).</p><p><br></p><p>In memory, these 2D-arrays will be represented by a 1D-array with all the rows concatenated. Obtaining a pixel in this 1D-array, we need to know the width of the image. Then we can get pixel <span class="ql-formula" data-value="i,j">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.05724em;" class="mord mathdefault">j</span></span></span></span></span>﻿</span> by calculating <span class="ql-formula" data-value="3\cdot\left(j\cdot width+i\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>⋅</mo><mrow><mo fence="true">(</mo><mi>j</mi><mo>⋅</mo><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo>+</mo><mi>i</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">3\cdot\left(j\cdot width+i\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span style="margin-right: 0.05724em;" class="mord mathdefault">j</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>. We multiply by 3 as we have 3 color channels.</p><p><br></p><h2 id="box-filter">Box Filter</h2><p>A box filter is a type of blur, which works as follows:</p><ul><li>For each pixel and color channel, calculate the box filter</li><li>The value of the pixel becomes the average value of the neighbors</li></ul><p><br></p><p>An application of this is bloom, a kind of glow effect. This is made by applying this effect to the brightest pixels and putting the result over the original image.</p><p><br></p><h2 id="ppm">PPM</h2><div style="white-space: normal;" class="markdown-body"><p>PPM is a lossless image format. Each PPM image consists of the following:</p>
<ul>
<li>A "magic number", for an RGB image this is <code>P6</code></li>
<li><code>ImageWidth ImageHeight</code></li>
<li>Maximum color value between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>65536</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,65536]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></li>
<li>Data in binary</li>
</ul>
</div><p><br></p><p>This is a very easy format, but also storage inefficient.</p><p><br></p><h2 id="jpg">JPG</h2><p>JPEG is a lossy image format, it can be compressed but quality will be reduced. The compression ratio 1:10 is still of very high quality, almost indiscernible from the original.</p><p><br></p><p>The algorithm works as follows:</p><ul><li>Take the RGB colors</li><li>Transform these into a new color space, which better represent our receptors in our eyes (luminance and chrominance) and reduce the amount of information in less important areas.</li><li>As our eyes can't see certain frequencies, we will remove those pixels</li><li>After obtaining a matrix with coefficients, we simplify it, and thus remove many values</li><li>Our matrix will contain a lot of 0's, use run-length encoding in order to save space</li></ul><p><br></p><p>See <a href="https://www.youtube.com/watch?v=Ba89cI9eIg8" target="_blank">this video</a> for a great explanation</p><p><br></p><h1 id="appendix">Appendix</h1><h2 id="a">A</h2><div style="white-space: normal;" class="markdown-body"><pre data-lang="python"><code>for each pixel P and color channel
	Distance = MAX
	Color = 0
	R = computeRay(P)
	For each polygon P
		(CurrColor, CurrDistance)=testIntersection(R,T)
		If CurrDistance &lt; Distance
			Distance = CurrDistance
			Color = CurrColor
</code></pre>
</div><p><br></p>