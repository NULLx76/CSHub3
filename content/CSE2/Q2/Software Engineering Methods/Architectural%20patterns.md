+++
title = "Architectural patterns"
date = 2019-12-28
+++
<h2 id="software-architecture">Software architecture</h2><p>Software architecture is how the components of a software system are organized and assembled, how they communicate with each other and the constraints that rule the whole system. It is divided into 3 parts:</p><ul><li><strong>Architectural patterns</strong> - how components are organized</li><li><strong>Messages + API</strong> - how components interacts with one another</li><li><strong>Quality attributes</strong> - contraints + non-functional requirements</li></ul><p><br></p><h2 id="architectural-patterns">Architectural patterns</h2><p>An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context.</p><p><br></p><p><img src="https://i.imgur.com/yVpAqhz.png" width="588"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>An architectural pattern is on a higher-level concerning about the relations between components.</p><p><br></p><h3 id="main-program-&amp;-subroutines">Main program &amp; subroutines</h3><p>Main Program and Subroutine is fundamentally focused on functions. It decomposes the overall functionality of the system in main program and a number of subroutines.</p><p><br></p><p>In this pattern, the structure of the code is hierarchical and can be modeled as a directed graph.</p><p><br></p><p>Here:</p><ul><li><strong>Components </strong>are the main program and subroutines</li><li><strong>Topology: </strong>static hierarchical organization of components</li></ul><p><br></p><p>This pattern is good as it promotes modularity and reuse, but subroutines may be affected by data changes made by another subroutine and it is hard to scale.</p><p><br></p><h3 id="client---server">Client - server</h3><p>In the Client Server Architecture, the server hosts, delivers and manages most of the resources and services to be consumed by the client. This type of architecture has one or more client computers connected to a central server over a network or internet connection.</p><p><br></p><p>The client &amp; server use a well-defined interface, through which they are accessible.</p><p><br></p><h3 id="layered-architecture">Layered architecture</h3><p>This pattern is used for systems that can be decomposed into groups of layers, each of which is at a particular level of abstraction. Each layer provides services to the next higher layer and consumes services from the lower layer (least knowledge principle).</p><p><br></p><p>So each component exposes an interface to be used by the layer above (using a facade or proxy pattern) and each component sees the layer below as a single layer. The network stack uses this architecture.</p><p><br></p><p>Many layered architectures use three layers to seperate concerns: presentation, business and storage layer.</p><p><br></p><h3 id="model-view-controller">Model-view-controller</h3><p>Model-View-Controller is an architectural patterns that divides the application into three main layers: Model, View, Controller. It is often used in web development. Here (often), the GUI is the view, the controller is the services that handles the request and the model is the database.</p><p><br></p><h3 id="multi-tier-pattern">Multi-tier pattern</h3><p>In the multi-tier pattern, runtime structures are organized into logical groups (tier). These logical groups are allocated to specific physical components, such as a server of cloud computing.</p><p><br></p><p>They are physically seperate units, each of which can have layers. An example of this could be that you have a tier which does static file hosting, a webserver tier and a database tier.</p><p><br></p><h3 id="ports-and-adapters-pattern">Ports and adapters pattern</h3><p>Ports and Adapters Pattern isolates core business logic from the services it uses. This allows different services to be "plugged in", and it allows the application to be run without these services.</p><p><br></p><p>Here, a <strong>port </strong>describes the API of the application and an <strong>adapter </strong>is the code that interacts with external data sources or other components that layer <em>can </em>use to gain access to data and events</p><p><br></p><p>This was initially described as the hexagonal archiecture. The adapters may satisfy constraints of one or more ports and theses services are not essential.</p><p><br></p><h3 id="pipe-and-filter-pattern">Pipe-and-filter pattern</h3><p>The Pipe-Filter pattern provides a structure for systems that produce a stream of data. Each processing step is encapsulated in a filter component while data is passed through pipes.</p><p><br></p><p>Here, a <strong>pipe </strong>is a connector which transports data from one filter to the next, preserving order and a <strong>filter </strong>reads, transforms and returns the transformed data.</p><p><br></p><p>The filters must defined an expected input and produced output and have a single input and output. The unix shell also uses this pattern.</p><p><br></p><h3 id="service-oriented-pattern">Service-oriented pattern</h3><p>In a service-oriented architecture (SOA), independent components are implemented as independent services, each providing a specific functionality. Services are combined at runtime to define the systemâ€™s behavior.</p><p><br></p><p>Here, a <strong>service </strong>is an independently deployable unit, which provides functionality behind a well-defined interface. A <strong>registry </strong>is a list of all available services, used by a service to discover other services and a <strong>message system </strong>are messages exchanged between services.</p><p><br></p><p>The services have no knowledge about the implementation details of other services. Because the communication between the services can be XML, it is susceptible to XML bombs. </p><p><br></p><h3 id="microservices">Microservices</h3><p>Microservices are a variant of SOA that re-arrange an application as a collections of loosely coupled services. Each microservice can be implemented in different programming languages, database, hardware and software environment, etc.</p><p><br></p><p>A few properties:</p><ul><li>A change to a small part of the application only requires rebuilding and redeploying only one or a small number of services</li><li>Adheres to principles such as fine-grained interfaces</li></ul><p><br></p><h3 id="publish-and-subscribe-pattern">Publish and subscribe pattern</h3><p>In the publish-subscribe pattern, producers and consumers exist independently and unaware of one another. Numerous consumers subscribe to events published by various producers.</p><p><br></p><p>Here, <strong>publishers </strong>are components that publish a (documented) event. A <strong>subscriber </strong>is a component that subscribes to an event which is delivered through an <strong>event bus</strong>, which is responsible for registering subscriptions and delivering published events.</p><p><br></p><p>This could be seen as the architectural version of the observer pattern, with the difference that in this publish-subscribe pattern the publisher and subscriber don't know about each other.</p><p><br></p><h3 id="event-driven-pattern">Event-driven pattern</h3><p>The event-driven architecture (EDA) consists of <strong>event emitters</strong> (or <strong>agents</strong>), event <strong>consumers</strong> (or <strong>sinks</strong>), and event channels. <strong>Events </strong>are inputs to the EDA and trigger transitions from one state to another state in the system. </p><p><br></p><p>Emitters have the responsibility of detecting, gathering and transferring events to the respective services.</p><p><br></p><p><img src="https://i.imgur.com/XdhcyeP.png" width="324"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p>