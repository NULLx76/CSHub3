+++
title = "Behavioral design patterns"
date = 2019-12-28
+++
<h2 id="behavioral-patterns">Behavioral patterns</h2><p>Behavioral design patterns are design patterns that identify common communication patterns among objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication. </p><p><br></p><p>So: Identify the aspects of your application that vary and separate them from what stays the same. So: create abstractions where needed.</p><p><br></p><p><img src="https://i.imgur.com/BLrInuY.png" width="474"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><h3 id="strategy-patterns">Strategy patterns</h3><p>The strategy pattern is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use.</p><p><br></p><p>So: create interfaces which can be implemented completely differently, depending on the context.</p><p><br></p><p>You use this pattern when:</p><ul><li>You have many related classes that differ only in behavior</li><li>You need different variants of an algorithm</li></ul><p><br></p><p>Note that the client/context needs to be aware of the different strategies and this pattern might give some overhead.</p><p><br></p><h3 id="observer-pattern">Observer pattern</h3><p>The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and updated automatically.</p><p><br></p><p>Here, you implement an observer interface and add the class that implements this to a list of classes that implement this interface. Now you know which classes to "notify" (where to call which methods) in order to update all the observers:</p><p><img src="https://i.imgur.com/Fd6qgY3.png" width="403"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when:</p><ul><li>A change to one object requires changing others and you don’t know how many objects need to be changed.</li><li>An object should be able to notify other objects without making assumptions about who these objects are.</li></ul><p><br></p><p>Note that a seemingly innocuous operation on the subject may cause a cascade of updates to observers and their dependent objects.</p><p><br></p><h3 id="iterator-pattern">Iterator pattern</h3><p>The Iterator Pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p><p><br></p><p>So instead of exposing a list with all elements, you enable the creation of a generic iterator, which then has the methods <em>hasNext() </em>- is there a next item - and <em>next() </em>- get the next item.</p><p><br></p><p>You use this pattern when:</p><ul><li>You want to access an aggregate object's contents without exposing its internal representation</li><li>You want to support multiple traversals of aggregate objects</li><li>You want to provide a uniform interface for traversing different aggregate structures (that is, to support polymorphic iteration).</li></ul><p><br></p><h3 id="command-pattern">Command pattern</h3><p>The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations..</p><p><br></p><p>A command is an object which is used to encapsulate all information needed to perform an action or trigger an event at a later time. In order to do use you just make a new implementation of the command interface.</p><p><br></p><p>We use the terms</p><ul><li>command - the code to be executed</li><li>receiver - the target object</li><li>invoker - the place where the commands are executed</li><li>client - the place where concrete instances of a command are made and are passed to the invoker</li></ul><p><br></p><p>You use this pattern when:</p><ul><li>You want to parameterize objects by an action to perform</li><li>You want to specify, queue, and execute requests at different times</li><li>You want to support undo and redo</li></ul><p><br></p><p>You can also assemble commands into a single composite command, which are an instance of the <strong>composite pattern.</strong></p><p><br></p><h3 id="template-method">Template method</h3><p>The Template Method defines the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p><p><br></p><p>You can use the template method when you have multiple alternative implementations which for example extend an abstract class. Note that this is different to the strategy pattern as here we put all the boilerplate in the parent class, whereas in strategy we would make interchangeable implementations.</p><p><br></p><p><img src="https://i.imgur.com/Qzi4Dlb.png" width="405"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when:</p><ul><li>You want to implement the invariant parts of an algorithm once and leave it up to subclasses to implement the behavior that can vary.</li><li>Common behavior among subclasses should be factored and localized in a common class to avoid code duplication.</li></ul><p><br></p><h3 id="chain-of-responsibility">Chain of responsibility</h3><p>The Chain of Responsibility avoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p><p><br></p><p>This could be useful in a webserver, where multiple filters need to be applied to a given request. Instead of keeping a list of filters the filters keep track of each other, thus reducing coupling between the caller of the filters and the filters itself.</p><p><br></p><p><img src="https://i.imgur.com/DFr4M5k.png" width="426"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when:</p><ul><li>You want to issue a request to one of several objects without specifying the receiver explicitly</li><li>The set of objects that can handle a request should be specified dynamically.</li></ul><p><br></p><p>Note that the sender and receiver don't have explicit knowledge of other in this approach.</p><p><br></p><h3 id="state-pattern">State pattern</h3><p>The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.</p><p><br></p><p>This is done by having a state interface and a method which switches between the different states in the context object. This is pretty similar to the strategy method, but whatever.</p><p><br></p><p><img src="https://i.imgur.com/ddFaf4O.png" width="445"></p><p><em>Image taken from slides by Annibale Panichella</em></p><p><br></p><p>You use this pattern when an object’s behavior depends on its state and it must change its behavior at run-time depending on that state.</p>