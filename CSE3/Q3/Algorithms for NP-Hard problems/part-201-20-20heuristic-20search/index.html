<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h1 id="heuristic-search-">Heuristic search </h1><p>Heuristic search refers to a search strategy that attempts to optimize a problem by iteratively improving the solution based on a given heuristic function or a cost measure.</p><p><br></p><p>This can be useful in for example solving the <strong>15 puzzle</strong>: trying to sort a frame of tiles with one tile missing.</p><p><img src="https://i.imgur.com/p1NG702.png" width="203"></p><p><br></p><h2 id="search-trees">Search trees</h2><p>A heuristic method can accomplish its task by using search trees. There are a few terms we need to define:</p><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>agent</strong>: an entity that perceives its environment and acts upon that environment</li>
</ul>
</div><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>state</strong>: a configuration of the agent and its environment (e.g. the image above)</li>
</ul>
</div><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>initial state</strong>: the state in which the agent begins</li>
</ul>
</div><p><br></p><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>actions</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>ACTIONS</mtext><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{ACTIONS}(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">ACTIONS</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> returns the set of actions that can be executed in state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></li>
</ul>
</div><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>transition model</strong>: a description of what state results from performing any applicable action in any state. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RESULT</mtext><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{RESULT}(s, a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">RESULT</span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> returns the state resulting from performing action <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> in state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>. For the 15 puzzle, the result function would look as such:</li>
</ul>
</div><p><img src="https://i.imgur.com/OIXfXI1.png" width="545"></p><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>state space</strong>: the set of all states reachable from the initial state by any sequence of actions. This can be seen as a graph, where each state is a node and each edge is a possible action</li>
</ul>
</div><p><br></p><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>goal test</strong>: a way to determine whether a given state is a goal state. Some problems may have 1 goal, and some may have multiple.</li>
</ul>
</div><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>path cost</strong>: a numerical cost associated with a given path. There may be shorter paths that yield the same goal, so we want to minimize the path cost.</li>
</ul>
</div><p><br></p><div style="white-space: normal;" class="markdown-body"><ul>
<li><strong>solution</strong>: a sequence of actions that leads from the initial state to the goal state</li>
<li><strong>optimal solution</strong>: a solution that has the lowest path cost among all possible solutions. There can be multiple.</li>
<li><strong>frontier</strong>: all the states that can be reached from the current state</li>
</ul>
</div><p><br></p><h3 id="node">Node</h3><p>We want to represent our states using <strong>nodes,</strong> data structures that keep track of:</p><ul><li>Its state</li><li>A parent (the node that generated this node)</li><li>An action (action applied to the parent to get this node)</li><li>A path cost (from initial state to node)</li></ul><p><br></p><h1 id="solving-the-problem">Solving the problem</h1><h2 id="naive">Naive</h2><ol><li>We start with a frontier that contains the initial state</li><li><em>Repeat:</em></li><li class="ql-indent-1">If the frontier is<strong> empty</strong>: there is no solution (no other options &amp; no solutions yet)</li><li class="ql-indent-1">Remove a node from the frontier</li><li class="ql-indent-2">If this node contains a goal state, return the solution (done!)</li><li class="ql-indent-2">Expand the node: add the neighbors of that node <strong>that you haven't seen before </strong>(using for example a set) to the frontier</li></ol><p><br></p><p>We can use a <strong>stack (LIFO)</strong> to represent our frontier if we want DFS and a <strong>queue (FIFO)</strong> if we want BFS</p><p><br></p><h2 id="greedy-best-first-search">Greedy Best-First Search</h2><p>The idea behind greedy best-first search is simple: always explore a best node in the frontier next.</p><p><br></p><p>We measure this "best" node using an estimate <span class="ql-formula" data-value="h\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">h\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> of how close node <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> is to the goal. </p><p>In the context of a search problem we can view this as the question which next brings us closest to the goal.</p><p><br></p><p>This is often a good thing, but it is not guaranteed to work faster / better than the naive solution.</p><p><br></p><h2 id="a*">A*</h2><p>A* is a small improvement to Dijkstra that improves it using an additional heuristic for each node: how far do we still need to go? A simple distance heuristic <span class="ql-formula" data-value="h\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">h\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> is Euclidean distance.</p><p><br></p><p>The change is that we don't just use the tentative distance to order the unvisited nodes, but the tentative distance <span class="ql-formula" data-value="g\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">g\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">g</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> + the heuristic cost between this node and the destination <span class="ql-formula" data-value="h\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">h\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>. </p><p>This means we prioritize nodes that are in the right direction, i.e. have lowest <span class="ql-formula" data-value="f\left(n\right)=g\left(n\right)+h\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>g</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow><mo>+</mo><mi>h</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f\left(n\right)=g\left(n\right)+h\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.10764em;" class="mord mathdefault">f</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.03588em;" class="mord mathdefault">g</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>.</p><p><br></p><p>A* terminates when we dequeue the goal, i.e. we need to have actually visited the goal.</p><p><br></p><h3 id="optimality">Optimality</h3><p>Whether A* is optimal, completely depends on the heuristic. There are two properties of A*:</p><ul><li><strong>Admissible </strong>(necessary):<strong> </strong>the heuristic never over-estimates the true cost. </li><li class="ql-indent-1"><span class="ql-formula" data-value="0\le h\left(n\right)\le h^{\ast}\left(n\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>h</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow><mo>≤</mo><msup><mi>h</mi><mo>∗</mo></msup><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">0\le h\left(n\right)\le h^{\ast}\left(n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.78041em; vertical-align: -0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>: the heuristic cost is always <span class="ql-formula" data-value="\le">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7719400000000001em; vertical-align: -0.13597em;"></span><span class="mrel">≤</span></span></span></span></span>﻿</span> than the true value</li><li><strong>Consistent </strong>(sufficient, not necessary): it never over-estimates the growth of the path cost</li><li class="ql-indent-1"><span class="ql-formula" data-value="h\left(n\right)\le h\left(n'\right)+c\left(n,\ n'\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo fence="true">)</mo></mrow><mo>≤</mo><mi>h</mi><mrow><mo fence="true">(</mo><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup><mo fence="true">)</mo></mrow><mo>+</mo><mi>c</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><msup><mi>n</mi><mo mathvariant="normal">′</mo></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">h\left(n\right)\le h\left(n&amp;#x27;\right)+c\left(n,\ n&amp;#x27;\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 1.001892em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 1.001892em; vertical-align: -0.25em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span>: the heuristic value is <span class="ql-formula" data-value="\le">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7719400000000001em; vertical-align: -0.13597em;"></span><span class="mrel">≤</span></span></span></span></span>﻿</span> to the heuristic cost of another node and the cost between these two nodes</li><li class="ql-indent-1">Consistent <span class="ql-formula" data-value="\Rightarrow">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">⇒</span></span></span></span></span>﻿</span> admissible</li><li class="ql-indent-1">Most natural admissible heuristics tend to be consistent</li></ul><p><br></p><p>Now, it also depends on the use case:</p><ul><li>Tree search:</li><li class="ql-indent-1">A* is optimal if the heuristic is admissible</li><li class="ql-indent-1">UCS (Dijkstra) is a special case (<span class="ql-formula" data-value="h=0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span>)</li><li>Graph search:</li><li class="ql-indent-1">A* is optimal if the heuristic is consistent</li><li class="ql-indent-1">UCS is optimal (<span class="ql-formula" data-value="h=0">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>﻿</span> is consistent)</li></ul><p><br></p><h3 id="admissible-heuristic">Admissible heuristic</h3><p>The hardest part is finding an admissible heuristic. These admissible heuristics are often solutions to <strong>relaxed </strong>problems, where you simplify the problem a bit. </p><p>You could for example use the Euclidean distance instead of the road.</p><p><br></p><p>Such a relaxed solution always has a smaller heuristic cost, since you've removed constraints.</p><p><br></p><p>Actually, inadmissible heuristic might also still be useful, even though they may not always give an optimal solution.</p><p><br></p><p>See the examples tab for an example on admissible heuristics.</p>
  </section>

    </section>
  </div>
</body>

</html>