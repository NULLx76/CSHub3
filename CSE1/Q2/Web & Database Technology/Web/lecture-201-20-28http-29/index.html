<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h1>Lecture 1</h1><p><a href="https://github.com/chauff/Web-Teaching/blob/master/Lecture-1.md" target="_blank"><em>This is a list of things copied from the transcripts that seem most important to me</em></a></p><p><br></p><h2>WWW vs Internet</h2><ol><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong>World Wide Web</strong>: a global system of interconnected hypertext documents available via the Internet </li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong>Internet</strong>: interconnected computer networks that span the globe; communicating through a common standard (TCP/IP)</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><span style="color: rgb(36, 41, 46);">The Internet Engineering Task Force (</span><strong style="color: rgb(36, 41, 46);">IETF</strong><span style="color: rgb(36, 41, 46);">) leads the development of the Internet.</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>The World Wide Web Consortium (<strong style="color: rgb(36, 41, 46);">W3C</strong><span style="color: rgb(36, 41, 46);">) leads the development of the web.</span></li></ol><p><br></p><h2><span style="color: rgb(36, 41, 46);">HTTP</span></h2><p>You have HTTP/1.1 and HTTP/2 but for some reason we will talk about HTTP/1.1 as you shouldn't learn new stuff at uni</p><p><br></p><p>How does communication work:</p><ol><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>The client initiates the communication, sending an HTTP request to the server</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>The server sends an HTTP response</li></ol><p><br></p><p><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">HTTP is </span><strong style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">reliable, </strong><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">this means, that the data appears </span><strong style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">in order </strong><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">and </span><strong style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">undamaged</strong><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">!</span></p><p><br></p><p><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">HTTP is a </span><strong style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">plain text protocol </strong><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">and </span><strong style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">line-oriented. </strong>The response to a request is then structured into <strong>response header</strong> fields in the <em>name:value</em> format, and the <strong>response body</strong> which contains the actual content. </p><p><br></p><p><span style="background-color: transparent; color: rgb(0, 0, 0);">From the lecture: The main problem of HTTP’s plain text format is that it’s prone to parsing errors. </span></p><p><br></p><h2><strong>Headers</strong></h2><table><tbody><tr><td data-row="1"><strong style="color: rgb(36, 41, 46); background-color: rgb(255, 255, 255);">Header field</strong></td><td data-row="1"><strong style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">Description</strong></td></tr><tr><td data-row="2"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Content-Type</span></td><td data-row="2"><span style="background-color: rgba(0, 0, 0, 0); color: rgb(36, 41, 46);">Entity type (aka MIME-type: </span><em style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">Multipurpose Internet Mail Extensions</em><span style="background-color: rgba(0, 0, 0, 0); color: rgb(36, 41, 46);">), to </span><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">determine how the client reacts. The pattern is always the same: each MIME type has a </span><strong style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">primary object type </strong><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">and a </span><strong style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">subtype</strong><span style="background-color: rgb(255, 255, 255); color: rgb(36, 41, 46);">. E.g. image/jpeg</span></td></tr><tr><td data-row="3"><span style="background-color: rgba(0, 0, 0, 0); color: rgb(36, 41, 46);">Content-Length</span></td><td data-row="3"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Length/size of the message. To indicate whether the entire message was received and for </span><strong style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">persistent connections</strong><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);"> (so we know when a message ends and a new one starts)</span></td></tr><tr><td data-row="4"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Content-Language</span></td><td data-row="4"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Language of the entity sent</span></td></tr><tr><td data-row="5"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Content-Encoding</span></td><td data-row="5">To show how data is decoded, e.g. with <em>gzip. </em>Client tells the server how they would like to receive it using Accept-Encoding. Compression takes more time but you have a smaller bandwidth; trade-off</td></tr><tr><td data-row="6"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Content-Location</span></td><td data-row="6"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Alternative location of the entity</span></td></tr><tr><td data-row="7"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Content-Range</span></td><td data-row="7"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">For partial entities, range defines the pieces sent</span></td></tr><tr><td data-row="8"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Content-MD5</span></td><td data-row="8"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Sender generates a checksum of the content to detect unintended modifications</span></td></tr><tr><td data-row="9"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Last-Modified</span></td><td data-row="9"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Date on which this entity was created/modified</span></td></tr><tr><td data-row="10"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Expires</span></td><td data-row="10">Web caches cache often used resources, this header is there to indicate when a resource is stale and needs to be refetched. Another header is <em>Cache-Control</em>, which uses an amount of seconds until it's stale instead of an exact date.</td></tr><tr><td data-row="11"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Allow</span></td><td data-row="11"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Lists the legal request methods for the entity</span></td></tr><tr><td data-row="12"><span style="color: rgb(36, 41, 46); background-color: rgba(0, 0, 0, 0);">Connection &amp; Upgrade</span></td><td data-row="12">Used to switch to a new protocol. If you needed realtime updating data you could use: polling (continuously sending HTTP requests) or long polling (sending one request and only returning a result on new data). But you can also switch to websockets using these headers / switch from HTTP/1 to HTTP/2</td></tr></tbody></table><p><br></p><p><strong>Status codes:</strong></p><p><span style="background-color: transparent; color: rgb(0, 0, 0);">1xx Informational</span></p><p><span style="background-color: transparent; color: rgb(0, 0, 0);">2xx Succes</span></p><p><span style="background-color: transparent; color: rgb(0, 0, 0);">3xx Redirected</span></p><p><span style="background-color: transparent; color: rgb(0, 0, 0);">4xx Client error</span></p><p><span style="background-color: transparent; color: rgb(0, 0, 0);">5xx Server error</span></p><p><br></p><p><strong style="background-color: transparent; color: rgb(0, 0, 0);">HTTP methods:</strong></p><p><span style="color: rgb(36, 41, 46);">The following are the most common HTTP methods:</span></p><ol><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong style="color: rgb(36, 41, 46);">GET</strong><span style="color: rgb(36, 41, 46);">: gets a document from the web server</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong style="color: rgb(36, 41, 46);">HEAD: </strong><span style="color: rgb(36, 41, 46);">returns the header of a HTTP response only (not the content)</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong style="color: rgb(36, 41, 46);">POST: </strong><span style="color: rgb(36, 41, 46);">sends data from the client to the server for processing</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong style="color: rgb(36, 41, 46);">PUT:</strong><span style="color: rgb(36, 41, 46);"> saves the body of the request on the server</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong style="color: rgb(36, 41, 46);">TRACE: </strong><span style="color: rgb(36, 41, 46);">can be used to trace where a message passes through before arriving at the server</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong style="color: rgb(36, 41, 46);">OPTIONS: </strong><span style="color: rgb(36, 41, 46);">is helpful to determine what kind of methods a server supports</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><strong style="color: rgb(36, 41, 46);">DELETE: </strong><span style="color: rgb(36, 41, 46);">can be used to remove documents from a web server</span></li></ol><p><br></p><p><strong style="color: rgb(36, 41, 46);">DNS:</strong><span style="color: rgb(36, 41, 46);"> to resolve an IP-address coming from a domain name, we use a DNS. Using a DNS (hosted by for example Google of Cloudflare) you get the IP-address to which you need to go. There are </span><span class="ql-formula" data-value="2^{32}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> IPV4 addresses (of which Apple owns 16777216, for some reason (https://en.wikipedia.org/wiki/List_of_assigned_/8_IPv4_address_blocks)</p><p><br></p><p><strong>HTTPS: </strong>All data sent to and by the server will be encrypted using certificates (public private key encryption, with Diffie Hellman). Client and server negotiate which protocol to use and then the most secure one that both support will be chosen. This encryption is (in modern times) done using TLS (not SSL, as the Github states) </p><p><br></p><h2>URL</h2><p>Uniform resource locators offer a standardised way to point to any resource on the Internet. <span style="color: rgb(36, 41, 46);">In general, a URL consists of up to 9 parts:</span></p><div class="markdown-body" style="white-space: normal;"><pre><code class="language-uri">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;
</code></pre>
</div><p><span style="color: rgb(36, 41, 46);">From back to front:</span></p><ol><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><code style="color: rgb(36, 41, 46); background-color: rgba(27, 31, 35, 0.05);">&lt;frag&gt;</code><span style="color: rgb(36, 41, 46);">: The name of a piece of a resource. Only used by the client - the fragment is not transmitted to the server.</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><code style="color: rgb(36, 41, 46); background-color: rgba(27, 31, 35, 0.05);">&lt;query&gt;</code><span style="color: rgb(36, 41, 46);">: Parameters passed to gateway resources, i.e. applications [identified by the path] such as search engines.</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><code style="color: rgb(36, 41, 46); background-color: rgba(27, 31, 35, 0.05);">&lt;params&gt;</code><span style="color: rgb(36, 41, 46);">: Additional input parameters applications may require to access a resource on the server correctly. Can be set per path segment.</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><code style="color: rgb(36, 41, 46); background-color: rgba(27, 31, 35, 0.05);">&lt;path&gt;</code><span style="color: rgb(36, 41, 46);">: the local path to the resource</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><code style="color: rgb(36, 41, 46); background-color: rgba(27, 31, 35, 0.05);">&lt;port&gt;</code><span style="color: rgb(36, 41, 46);">: the port on which the server is expecting requests for the resource (ports enable multiplexing: multiple services are available on one location)</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><code style="color: rgb(36, 41, 46); background-color: rgba(27, 31, 35, 0.05);">&lt;host&gt;</code><span style="color: rgb(36, 41, 46);">: domain name (host name) or numeric IP address of the server</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><code style="color: rgb(36, 41, 46); background-color: rgba(27, 31, 35, 0.05);">&lt;user&gt;:&lt;password&gt;</code><span style="color: rgb(36, 41, 46);">: the username/password (may be necessary to access a resource)</span></li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span><code style="color: rgb(36, 41, 46); background-color: rgba(27, 31, 35, 0.05);">&lt;scheme&gt;</code><span style="color: rgb(36, 41, 46);">: determines the protocol to use when connecting to the server.</span></li></ol><p><br></p><p><strong style="color: rgb(36, 41, 46);">Relative vs absolute: </strong><span style="color: rgb(36, 41, 46);">An absolute URL can be </span><span style="color: rgb(36, 41, 46); background-color: rgb(255, 255, 255);">to retrieve a web resource without requiring any additional information. Relative URLs require a </span><strong style="color: rgb(36, 41, 46); background-color: rgb(255, 255, 255);">base URL </strong><span style="color: rgb(36, 41, 46); background-color: rgb(255, 255, 255);">to enable their conversion into absolute URLs</span></p><p><br></p><p><strong style="color: rgb(36, 41, 46); background-color: rgb(255, 255, 255);">Restrictions: </strong><span style="color: rgb(36, 41, 46); background-color: rgb(255, 255, 255);">URLs should be portable across protocols and should be human readable (so no invisible characters). Character encoding for for example spaces is used, whitespace = %20. You could also use Russian characters, but by </span><a href="https://en.wikipedia.org/wiki/Punycode" target="_blank" style="color: rgb(0, 102, 204); background-color: rgb(255, 255, 255);">Punycode</a> these will be transformed into other characters to avoid fraud.</p><p><br></p><h2><a href="https://github.com/chauff/Web-Teaching/blob/master/Lecture-1.md#authentication" target="_blank">Authentication</a></h2><p>Now some authentication (Authentication is any process by which a system verifies the identity of a user who wishes to access it) which you don't want to use. In lecture 7 ways are shown which you would actually want to use.</p><p><br></p><p><strong>HTTP Headers: </strong>There are headers which can be used to send information from the client to the server. Exists of the following headers</p><ol><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>From: e-mail field, mostly used by web crawlers</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>User-Agent: browser field, for device customization</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>Referer: previous page, for user interests</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>Client-IP: ip-address</li><li data-list="bullet"><span class="ql-ui" contenteditable="false"></span>Authorization: username &amp; password</li></ol><p><br></p><p><strong>Client-IP tracking: </strong>can be used, but it would mean that everyone in the household is seen as the same user. Also IPs are dynamically assigned, users may use proxies and users may access using VPNs.</p><p><br></p><p><strong>Fat URLs: </strong>track users through the generation of unique URL which is generated on first visit. But they are ugly, cannot be shared, break caching, and it is not persistent across multiple visits (they also talk about extra server loads through HTML rewrites but that is only if you do SSR, with PHP for example. Modern frameworks don't have this quirk)</p><p><br></p><p><strong>Basic authentication: </strong>explicitly ask for username and password before each request will be returned, so you can't even GET the site if you don't provide the right password. This password is sent in headers (which are encrypted if you use HTTPS). These passwords are base64 encoded.</p>
  </section>

    </section>
  </div>
</body>

</html>