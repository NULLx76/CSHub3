<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h1>Neo4J</h1><h2>Some information</h2><ul><li>Open source database</li><li>Made in Java</li><li>Schemaless and typeless</li><li>Declarative query language</li><li>No sharding</li><li>ACID properties</li></ul><p><br></p><h2>Graph databases</h2><p><strong>Pros and cons</strong></p><ul><li>Breaks data into even smaller units than RDBMs</li><li>Not suitable for distribution, but ACID properties can be guaranteed</li><li>Suitable for complex, semi-structured, highly connected data</li></ul><p><br></p><p><strong>Graph vs relational databases</strong></p><ul><li>RDBMs and NoSQL DBs lack relationships</li><li class="ql-indent-1">JOIN and aggregates are sub-optimal solutions</li><li class="ql-indent-1">Relationships are not reflective</li><li>Graph databases embrace relationships, traversal operations are highly efficient</li><li>In a depth two (friend-of-friend), Neo4J and RDBMs are fine, but when we increase the depth RDBMs can't keep up</li></ul><p><br></p><h2><strong>Data model</strong></h2><p>Neo4J uses a labeled property <a href="https://cshub.nl/post/354679074" target="_blank">graph</a> as its internal model:</p><ul><li><strong>Nodes (vertices) </strong>have <em>labels </em>(types)</li><li><strong>Nodes </strong>can have properties (name-value pairs)</li><li><strong>Edges </strong>have a start node, end node and direction</li><li><strong>Edges </strong>can also have <em>name </em>and <em>properties</em></li></ul><p><br></p><p><strong>Nodes (vertices)</strong></p><ul><li>Represent <strong>entities </strong>with a unique conceptual identity</li><li class="ql-indent-1">Have unique (internal) identifier</li><li class="ql-indent-1">Can have <strong>types</strong>, defined by one or more <strong>labels</strong></li></ul><p><br></p><ul><li><strong>Labels</strong></li><li class="ql-indent-1">Nodes having the same label belong to the same set</li><li class="ql-indent-1">Can be added and removed at runtime</li><li class="ql-indent-1">Naming convention: camel case</li></ul><p><br></p><ul><li><strong>Properties</strong></li><li class="ql-indent-1"><strong>name:value </strong>pairs (no lists or arrays)</li><li class="ql-indent-1"><strong>name </strong>is a string</li><li class="ql-indent-1">Standard data types (ints, floats, strings, booleans, spatial points, datetime)</li><li class="ql-indent-1">Lower camel case, beginning with a lower-case character</li></ul><p><br></p><p>Thus, a label might be <em>Employee</em> and a property might be <em>firstName: "name"</em></p><p><br></p><p><strong>Relationships (edges)</strong></p><ul><li>Connecting <em>source node</em> and <em>target node</em></li><li class="ql-indent-1">Directions are <strong>not </strong>binding at query time</li><li class="ql-indent-1">Loops are allowed</li></ul><p><br></p><ul><li>Relationship <strong>Type</strong></li><li class="ql-indent-1">The name of the relationship</li><li class="ql-indent-1">Upper case, using underscore to separate words</li></ul><p><br></p><ul><li><strong>Properties</strong></li><li class="ql-indent-1"><strong>name:value </strong>pairs</li></ul><p><br></p><ul><li>Built in "referential integrity"</li><li class="ql-indent-1">An existing relationship never points to a non-existing node</li><li class="ql-indent-1">You cannot delete a node without deleting its associated relationships</li></ul><p><br></p><p>Thus, a relationship type might be <em>Works </em>and a property might be <em>start_date: 2018-09-01</em></p>
  </section>

    </section>
  </div>
</body>

</html>