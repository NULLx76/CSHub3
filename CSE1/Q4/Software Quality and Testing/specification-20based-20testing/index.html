<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h1 id="partition-testing"><span>Partition testing</span></h1><p><strong>Equivalence partitions </strong><span>are representative classes of a program, which guide the tester through the testing phase. It divides a set of test conditions into groups that are considered the same.</span></p><p><br></p><p><span>A test condition is "something that can be tested". Or: the specification that a tester must follow for testing an application, something that you need to verify.</span></p><p><br></p><h3 id="partitions-based-on-the-requirements"><span>Partitions based on the requirements</span></h3><ul><li><span>Identify representative classes: divide the possible inputs into a few distinct </span><strong>partitions</strong></li><li><span>Choose representative values: choose values which represent the chosen </span><strong>partitions</strong><span>, any element should be fine as they should all yield the same result</span></li><li><span>Exploit the knowledge to identify trouble-prone regions of the input space</span></li></ul><p><br></p><h3 id="the-category-partitions-for-generating-tests"><span>The category-partitions for generating tests</span></h3><ul><li><span>Identify the parameters</span></li><li><span>The characteristics of each parameter</span></li><li class="ql-indent-1"><span>From the specs</span></li><li class="ql-indent-1"><span>Not from the specs</span></li><li><span>Add constraints (minimize)</span></li><li class="ql-indent-1"><span>Remove invalid combinations</span></li><li class="ql-indent-1"><span>Reduce number of exceptional behaviors</span></li><li><span>Generate combinations</span></li></ul><p><span>  </span></p><h3 id="large-systems"><span>Large systems</span></h3><p><span>In large systems: </span></p><ul><li><span>Functional specifications can be large and complex. Partition the specifications into features that can be tested separately. </span></li><li><span>An ITF is a feature that can be tested independently of other functionalities of the software. </span></li><li><span>Given an ITF, apply partition testing. </span></li><li><span>Instantiate (concrete and executable) test cases.</span></li></ul><p><br></p><h1 id="boundary-testing"><span>Boundary testing</span></h1><p><span>Structural testing, based on source code. Boundaries are just edge cases which can lead to a lot of bugs. In JUnit, it is possible to use a parameterized test in order to test those boundary cases.</span></p><p><br></p><h3 id="points"><span>Points</span></h3><p><span>Using boundary analysis we can figure out what happens when values are near to a boundary.</span></p><p><br></p><p><span>For the following examples, say we have the condition <span class="ql-formula" data-value="x\ge100">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≥</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">x\ge100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7719400000000001em; vertical-align: -0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span>﻿</span> with integers</span></p><ul><li><strong>On point</strong><span>: the number that is exactly on the boundary (what happens if <span class="ql-formula" data-value="x=100">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">x=100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span>﻿</span>?)</span></li><li><strong>In points</strong><span>: make the condition true (<span class="ql-formula" data-value="x\ge100">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≥</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">x\ge100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.7719400000000001em; vertical-align: -0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span>﻿</span>)</span></li><li><strong>Out points</strong><span>: make the condition false (<span class="ql-formula" data-value="x<100">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&amp;lt;</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">x&amp;lt;100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span>﻿</span>)</span></li><li><strong>Off point</strong><span>: the closest number to the on-point which flips the condition (so <span class="ql-formula" data-value="x=99">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>99</mn></mrow><annotation encoding="application/x-tex">x=99</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">9</span><span class="mord">9</span></span></span></span></span>﻿</span> is the off-point)</span></li></ul><p><span>  </span></p><h3 id="simplified-domain-testing-strategy"><span>Simplified domain-testing strategy</span></h3><p><span>If you want to test </span><strong>all</strong><span> possibilities, the amount of options (boundaries) will increase exponentially (<span class="ql-formula" data-value="2^n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>﻿</span>). So testing all boundaries will quickly get very difficult (if not impossible)</span></p><p><br></p><p><span>We should do the following:</span></p><ul><li><span>Handle boundaries independently</span></li><li><span>For each boundary, pick </span><strong>on</strong><span> and </span><strong>off</strong><span> point</span></li><li><span>While testing, using varying </span><strong>in </strong><span>points</span></li><li><span>Use domain matrix to see what is happening:</span></li></ul><p><span><img src="https://lh3.googleusercontent.com/Ha1IMjMmJ4BooH8QTSwGsHXRHqlAmAS3wxSm2hmn8f3u1i0n8PxLyGOiPjobE4oCyvwZw-9ZhMvamcPiru6KR6ThydPrBsVOay40oOuiOOAJ6PMQWOY4t-pjy2h72IDVrbGZ8ZnpWhz0tonUQQ" width="418"></span></p><p><em>Image taken from slides by Mauricio Aniche</em></p><p><br></p><p><span>What we do: for every boundary condition, we take values for the on and off points, and a typical in point to test other conditions. These are the test cases we will be using.</span></p><p><br></p><h3 id="the-correct-way"><span>The CORRECT way</span></h3><p><strong>C</strong><span>onformance, many data elements must conform to a specific format. Test when your input is not in conformance with what is expected</span></p><p><strong>O</strong><span>rdering, the order of data might influence input. Test for different orderings than expected.</span></p><p><strong>R</strong><span>ange, inputs should usually be within a certain range. Test for input outside of this range.</span></p><p><strong>R</strong><span>eference, when testing a method, consider:</span></p><ul><li><span>what it references outside its scope</span></li><li><span>what external dependencies is has</span></li><li><span>whether it depends on the object being in a certain state</span></li><li><span>any other conditions that must exist</span></li></ul><p><strong>E</strong><span>xistence, test what happens if an object doesn't exist where you expect it to exist</span></p><p><strong>C</strong><span>ardinality, test for off-by-one-errors</span></p><p><strong>T</strong><span>ime, test for ordering in time, timeouts, UTC/GMT etc.</span></p><p><br></p><h1 id="random-testing"><span>Random testing</span></h1><p><span>It could be better to simply test random inputs:</span></p><ul><li><strong>Pre-random testing</strong><span>: If generating random inputs is cheap then even with a small budget (e.g., 1 day), we’d generate millions of tests. A human would only generate a few.</span></li><li><strong>Anti-random testing</strong><span>: Random testing is an ineffective way to find singularities in the large input space.</span></li></ul><p><br></p><ul><li><strong>Pre-partition testing: </strong><span>Test designers usually exploit some knowledge of application semantics to choose samples that are more likely to include "special" or trouble-prone regions of the input space.</span></li><li><strong>Anti-partition testing: </strong><span>Partition testing is more expensive than random testing.</span></li></ul><p><br></p><p><span>Given a fixed budget, the optimum may not lie in only partition testing or only random testing, but in some combination that makes use of available knowledge.</span></p><p><br></p><h1 id="models"><span>Models</span></h1><p><span>A model is:</span></p><ul><li><span>Simpler than the artifact</span></li><li><span>Preserves certain key attributes</span></li><li><span>Support analysis by the domain experts or developers</span></li></ul><p><br></p><p><span>Models can be made using for example UML. For testing, we are most interested in the dynamic models.</span></p><p><br></p><p><span>Models can be obtained from requirements:</span></p><ul><li><span>they are meaningful to a domain expert</span></li><li><span>they are used to obtain test cases that systematically exercise required behavior</span></li></ul><p><br></p><p><span>Or they can be obtained from code:</span></p><ul><li><span>they are meaningful to the developer</span></li><li><span>they are used to obtain test cases that systematically exercise implemented behavior</span></li></ul><p><br></p><h1 id="decision-tables"><span>Decision tables</span></h1><p><span>A decision table models how combinations of conditions lead to given actions (or outputs). The resulting table can be verified and can be used to systematic test cases. Decision tables can have many conditions, in general, <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> conditions give <span class="ql-formula" data-value="2^n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> variants. We can also have don't care values. Decision tables are good ways of dealing with combinations of things (e.g. inputs). An example of a decision table:</span></p><p><span><img src="https://i.imgur.com/GNHQIdA.png" width="414"></span></p><p><em>Image taken from slides by Mauricio Aniche</em></p><h3 id=""><br></h3><p><span>Using a decision table we decide which subset of cases to test and which we don't test (as it's often infeasible to test every case). There are a couple of decision table testing strategies:</span></p><ul><li><strong>All explicit variants</strong><span>: test all cases (in this example you would test <span class="ql-formula" data-value="6">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">6</span></span></span></span></span>﻿</span>)</span></li><li><strong>All possible variants: </strong><span>test all cases, also the unspecified ones. In this case you would test <span class="ql-formula" data-value="2^3=8">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8141079999999999em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141079999999999em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">8</span></span></span></span></span>﻿</span> </span></li><li><strong>All decisions: </strong><span>every unique outcome is tested, this yields fewer tests than all explicit variants. In this case you would test <span class="ql-formula" data-value="4">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span>﻿</span> </span></li><li><strong>Each condition T/F: </strong><span>Just check <span class="ql-formula" data-value="TT\dots TT">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>T</mi><mo>…</mo><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">TT\dots TT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span><span style="margin-right: 0.13889em;" class="mord mathdefault">T</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="FF\dots FF">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>F</mi><mo>…</mo><mi>F</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">FF\dots FF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span></span></span></span></span>﻿</span> </span></li><li><strong>MCDC: </strong><span>each condition and all decisions</span></li></ul><p><br></p><h3 id="modified-condition-/-decision-coverage-(mcdc)"><strong>Modified Condition / Decision Coverage (MCDC)</strong></h3><ul><li><strong>Conditions: </strong><span>each condition should be once true, once false</span></li><li><strong>Decisions: </strong><span>each action should be taken at least once</span></li><li><strong>Modified: </strong><span>each condition should individually determine the outcome</span></li><li><span>For each condition MCDC requires two test cases that only differ in outcome and that condition</span></li></ul><p><br></p><p><strong>Finding a MCDC cover</strong></p><ul><li><span>Expand decision table (expand don't cares)</span></li><li><span>Start with one variable (e.g. <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span>), and for all combinations of the other variables (<span class="ql-formula" data-value="B">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05017em;" class="mord mathdefault">B</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="C">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>﻿</span>), check if the outcome changes if <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span> changes.</span></li><li><span>In this case, in the <span class="ql-formula" data-value="\left\{1,5\right\}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left\{1,5\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose delimcenter" style="top: 0em;">}</span></span></span></span></span></span>﻿</span> combination, the outcome changes as <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span> changes. In <span class="ql-formula" data-value="\left\{4,8\right\}">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left\{4,8\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">{</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose delimcenter" style="top: 0em;">}</span></span></span></span></span></span>﻿</span>, the outcome stays <span class="ql-formula" data-value="F">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.13889em;" class="mord mathdefault">F</span></span></span></span></span>﻿</span>, so this test is not interesting for <span class="ql-formula" data-value="A">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>﻿</span> </span></li><li><span>In the end, pick test cases that represent all variables. In the end, you'll have <span class="ql-formula" data-value="n+1">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>﻿</span> tests, where <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> is the amount of variables</span></li></ul><p><span><img src="https://i.imgur.com/qwgkXa1.png" width="386"></span></p><p><em>Image taken from slides by Mauricio Aniche</em></p><p><br></p><p><strong>Observability and controllability: </strong><span>The result of a decision table might not always be a value and the input might not always be an easy condition either. Sometimes this depends on the application itself. To still test the code we need to test, we can use mocking:</span></p><ul><li><span>Mock condition classes to set inputs</span></li><li><span>Mock action classes to observe effects</span></li></ul><p><br></p><p><strong>Cucumber scenario (Behaviour-Driven Design): </strong><span>Decision tables are also useful for functional testing, using plain text we define a few scenarios which have some parameters using a when then structure.</span></p><p><br></p><p><strong>Decision table vs branch coverage: </strong><span>Decision tables can also be read by domain experts. Besides, some parts of the decision table could be implemented in other places than in the code, so branch coverage wouldn't say everything</span></p><p><br></p><p><strong>Non-binary decision table: </strong><span>decision tables can be generalized to non-Boolean conditions, most testing strategies remain possible. </span></p><p><br></p><p><strong>Designing a condition table:</strong></p><ul><li><span>Keep conditions independent</span></li><li><span>Use DC values to reduce number of variants</span></li><li><span>Avoid overlap between DC values</span></li><li><span>Try to add a default column</span></li><li><span>If conditions are mutually exclusive, consider using non-binary logic</span></li><li><span>If most conditions are non-binary, consider combinatoric testing</span></li></ul><p><br></p><h1 id="state-transition"><span>State transition</span></h1><p><span>State machines model the state of a software system and what actions can lead to a change in that </span><strong>state</strong><span>. These actions can be modeled using a state diagram. A state reflects as much of a system's history as needed to determine current allowed behavior. A state machine imposes constraints on ordering of events.</span></p><p><br></p><h3 id="state-diagram"><strong>State diagram</strong></h3><p><span>The UML state diagram connects different states by arrows with the respective action needed to change state. </span></p><p><br></p><p><span>The default state is marked by an arrow attached by a dot pointing to the state. States can have self-loops and have conditions (denoted by <span class="ql-formula" data-value="\left[condition\right]">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[condition\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top: 0em;">]</span></span></span></span></span></span>﻿</span>) and actions (denoted by <span class="ql-formula" data-value="/action">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">/action</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">/</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span>).</span></p><p><br></p><p><span>A super state can group multiple states together. A group state surrounds the states to be grouped. A super state also has a default state, which is triggered when the super state is triggered. This super state can be collapsed into a smaller state, used to modularize and combine multiple state machines.</span></p><p><br></p><p><span>State machines can also be combined by orthogonal regions, two independent parts separated with a dashed line. </span></p><p><br></p><h3 id="state-based-testing"><span>State-based testing</span></h3><p><span>In a testing model, a state model prescribes an abstract test suite. This test suite describes the implemented test suite, which exercises the system under test. This system should be tested using a fault model:</span></p><ul><li><span>Does an event lead to the correct state?</span></li><li><span>Does an event trigger with the right conditions?</span></li><li><span>Etc</span></li></ul><p><br></p><p><span>A test suite answering such questions should be derived from a state diagram.</span></p><p><br></p><p><span>But when is a test adequate? There are a few ways of looking at it</span></p><ul><li><strong>State coverage</strong><span>: reach every state</span></li><li><strong>Transition coverage</strong><span>: exercise every transition</span></li><li><strong>Path coverage</strong><span>: exercise a sequence of transitions</span></li></ul><p><br></p><h3 id="state-paths"><strong>State paths</strong></h3><p><span>A full test case which test a sequence of transitions, a path through a </span><strong>transition tree, </strong><span>which spans the state diagram using breadth-first traversal. Each path from the root to a leaf is a test case, this covers multiple transitions. You should make sure loops are only unrolled once.</span></p><p><br></p><p><span>We should also test paths that shouldn't be possible (called </span><strong>sneak paths)</strong><span>. To test for these, we make a transition table, with the events as columns and rows as states:</span></p><p><span><img src="https://i.imgur.com/uqjv60b.png" width="548"></span></p><p><em>Image taken from slides by Mauricio Aniche</em></p><p><br></p><p><span>The empty cells are unspecified, there should be a decision on what to do with them (can be ignoring the event or raising an exception for example). During testing, you should test whether this happens and the rest of the state doesn't change by invoking an event marked by an empty cell.</span></p><p><br></p><h3 id="implementing-a-state-machine"><span>Implementing a state machine</span></h3><p><span>You can look at a class as a state machine. This class contains </span><strong>inspection methods, </strong><span>which view the current state, and </span><strong>trigger methods</strong><span>, which transition to the next state. A test scenario is a sequence of triggers and inspections.</span></p><p><br></p><p><span>To test a web application, it is recommended to use state objects, which give an API to influence and therefore test the application, while hiding the HTML details. State objects also supply state inspection, self checking and state transition.</span></p>
  </section>

    </section>
  </div>
</body>

</html>