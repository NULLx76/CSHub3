<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h2>Memory</h2><ul><li><strong>Direct Memory Access (DMA)</strong>: Eliminating the need for the CPU to spend precious time on transferring from outside sources to memory (e.g. disk, but also network: <a href="about:blank" target="_blank">RDMA</a>)</li><li class="ql-indent-1">DMA controller: independent entity to transfer blocks of data from / to memory</li><li class="ql-indent-2">Cycle stealing:  CPU has priority on the bus, so sometimes it steals a bus cycle from the DMA controller</li><li class="ql-indent-2">Burst mode: CPU has to wait until the DMA controller burst is done</li><li class="ql-indent-2">DMA controller is accessed as a normal IO device, signals DONE and/or by interrupt but will act as bus master when transferring data</li></ul><p><br></p><ul><li><strong>Memory Organization</strong></li><li class="ql-indent-1">Types of RAM:</li><li class="ql-indent-2">SRAM (Static Random Access Memory): consumes little power and contains state, but is expensive and large, not efficient for consumer</li><li class="ql-indent-2">DRAM (Dynamic Random Access Memory): uses a single capacitor but only contains state for a few milliseconds, must then be refreshed</li></ul><p><br></p><ul><li class="ql-indent-1">Organized in rows of words (works very efficient): </li><li class="ql-indent-2"><strong>16x8 </strong>means 16 rows of 8 bit words. Thus needs <span class="ql-formula" data-value="2^4">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8141079999999999em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141079999999999em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> -&gt; 4 bits to address. You then get 8 bits back</li><li class="ql-indent-2">A decoder is used to decode the incoming row address to select the correct row in the memory array</li><li class="ql-indent-2">If the "internal organization" is different than the amount of words needed, a MUX will be needed to select the right amount of bits:</li><li class="ql-indent-3"><strong>256x8 </strong>memory organization</li><li class="ql-indent-3">Internal: <strong>64x32</strong>, so we get back 32 bits by selecting the row</li><li class="ql-indent-3">To go from 32 to 8, we multiplex: we also pass the column address</li><li class="ql-indent-2">You also have <strong>chip select</strong> and <strong>Read/Write</strong> pins, and <strong>ground </strong>+ <strong>power </strong>pins</li></ul><p><br></p><ul><li class="ql-indent-1">Multiple memory units (interleaved memory): A few bits are used to select the bank, so which memory chip, and then the rest is the address inside of that chip</li></ul><p><br></p><ul><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Virtual memory</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: pretend that there is more memory than actually is in the system</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Divides address in chunks</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Stores most chunks on disk</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">When chunk is needed, move to main memory</span></li></ul><p><br></p><ul><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Pretty similar to caching:</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Blocks → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">pages</strong></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Cache miss → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">page fault</strong></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Tag field → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">page number</strong></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Byte/word field → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">page offset</strong></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Mapping function → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">page table</strong></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Memory Management Unit</strong><span style="background-color: transparent; color: rgb(0, 0, 0);"> (MMU)</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Mapping of pages in memory</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Access control</span></li></ul><p><br></p><ul><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Operating System</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Set up translation</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Handle page faults</span></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Demand paging</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: Going from virtual address in page table to physical address</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">CPU contains special register that stores the stating location of the page table as there are multiple tables, for each program</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Order:</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">Logical address covers complete address space</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">Page table stored in main memory (OS), translates page number into actual addresses</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">Combining page frame and offset (in register) gives the complete physical memory address, which will be put in the cache</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Control bits in the table: avoid writing back to disk if not necessary</span></li></ul><p><br></p><ul><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Size of page table:</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Large address space → large page table</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Page table does not fit in cache</span></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Translation Lookaside Buffer</strong><span style="background-color: transparent; color: rgb(0, 0, 0);"> (</span><strong style="background-color: transparent; color: rgb(0, 0, 0);">TLB</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">): Special cache for small part of the page table to look up virtual page number to find page frame</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">“Fully-associative” mapping</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">If page from not found in TLB → regular cache miss</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">If page from not found in page table → page fault</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">MMU issues a trap (software interrupt)</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">CPU aborts the instruction &amp; switches to kernel mode</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">OS </span></li><li class="ql-indent-5"><span style="background-color: transparent; color: rgb(0, 0, 0);">Searches for a free page frame</span></li><li class="ql-indent-5"><span style="background-color: transparent; color: rgb(0, 0, 0);">Loads the requested page from disk into memory (context switch)</span></li><li class="ql-indent-5"><span style="background-color: transparent; color: rgb(0, 0, 0);">Updates the page table</span></li><li class="ql-indent-5"><span style="background-color: transparent; color: rgb(0, 0, 0);">Restarts the aborted instruction</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">DMA to move from disk to memory</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Protect memory using page table</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">Page table for each process</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">You don’t want the page table of one program to overwrite memory of another program</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">OS kills the program if that happens</span></li></ul><h2><br></h2><ul><li><strong>Direct Memory Access (DMA)</strong>: Eliminating the need for the CPU to spend precious time on transferring from outside sources to memory (e.g. disk, but also network: <a href="about:blank" target="_blank">RDMA</a>)</li><li class="ql-indent-1">DMA controller: independent entity to transfer blocks of data from / to memory</li><li class="ql-indent-2">Cycle stealing:  CPU has priority on the bus, so sometimes it steals a bus cycle from the DMA controller</li><li class="ql-indent-2">Burst mode: CPU has to wait until the DMA controller burst is done</li><li class="ql-indent-2">DMA controller is accessed as a normal IO device, signals DONE and/or by interrupt but will act as bus master when transferring data</li></ul><p><br></p><ul><li><strong>Memory Organization</strong></li><li class="ql-indent-1">Types of RAM:</li><li class="ql-indent-2">SRAM (Static Random Access Memory): consumes little power and contains state, but is expensive and large, not efficient for consumer</li><li class="ql-indent-2">DRAM (Dynamic Random Access Memory): uses a single capacitor but only contains state for a few milliseconds, must then be refreshed</li></ul><p><br></p><ul><li class="ql-indent-1">Organized in rows of words (works very efficient): </li><li class="ql-indent-2"><strong>16x8 </strong>means 16 rows of 8 bit words. Thus needs <span class="ql-formula" data-value="2^4">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8141079999999999em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141079999999999em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> -&gt; 4 bits to address. You then get 8 bits back</li><li class="ql-indent-2">A decoder is used to decode the incoming row address to select the correct row in the memory array</li><li class="ql-indent-2">If the "internal organization" is different than the amount of words needed, a MUX will be needed to select the right amount of bits:</li><li class="ql-indent-3"><strong>256x8 </strong>memory organization</li><li class="ql-indent-3">Internal: <strong>64x32</strong>, so we get back 32 bits by selecting the row</li><li class="ql-indent-3">To go from 32 to 8, we multiplex: we also pass the column address</li><li class="ql-indent-2">You also have <strong>chip select</strong> and <strong>Read/Write</strong> pins, and <strong>ground </strong>+ <strong>power </strong>pins</li></ul><p><br></p><ul><li class="ql-indent-1">Multiple memory units (interleaved memory): A few bits are used to select the bank, so which memory chip, and then the rest is the address inside of that chip</li></ul><p><br></p><ul><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Virtual memory</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: pretend that there is more memory than actually is in the system</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Divides address in chunks</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Stores most chunks on disk</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">When chunk is needed, move to main memory</span></li></ul><p><br></p><ul><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Pretty similar to caching:</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Blocks → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">pages</strong></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Cache miss → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">page fault</strong></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Tag field → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">page number</strong></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Byte/word field → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">page offset</strong></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Mapping function → </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">page table</strong></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Memory Management Unit</strong><span style="background-color: transparent; color: rgb(0, 0, 0);"> (MMU)</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Mapping of pages in memory</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Access control</span></li></ul><p><br></p><ul><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Operating System</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Set up translation</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Handle page faults</span></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Demand paging</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: Going from virtual address in page table to physical address</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">CPU contains special register that stores the stating location of the page table as there are multiple tables, for each program</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Order:</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">Logical address covers complete address space</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">Page table stored in main memory (OS), translates page number into actual addresses</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">Combining page frame and offset (in register) gives the complete physical memory address, which will be put in the cache</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Control bits in the table: avoid writing back to disk if not necessary</span></li></ul><p><br></p><ul><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Size of page table:</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Large address space → large page table</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Page table does not fit in cache</span></li></ul><p><br></p><ul><li class="ql-indent-2"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Translation Lookaside Buffer</strong><span style="background-color: transparent; color: rgb(0, 0, 0);"> (</span><strong style="background-color: transparent; color: rgb(0, 0, 0);">TLB</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">): Special cache for small part of the page table to look up virtual page number to find page frame</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">“Fully-associative” mapping</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">If page from not found in TLB → regular cache miss</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">If page from not found in page table → page fault</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">MMU issues a trap (software interrupt)</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">CPU aborts the instruction &amp; switches to kernel mode</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">OS </span></li><li class="ql-indent-5"><span style="background-color: transparent; color: rgb(0, 0, 0);">Searches for a free page frame</span></li><li class="ql-indent-5"><span style="background-color: transparent; color: rgb(0, 0, 0);">Loads the requested page from disk into memory (context switch)</span></li><li class="ql-indent-5"><span style="background-color: transparent; color: rgb(0, 0, 0);">Updates the page table</span></li><li class="ql-indent-5"><span style="background-color: transparent; color: rgb(0, 0, 0);">Restarts the aborted instruction</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">DMA to move from disk to memory</span></li></ul><p><br></p><ul><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Protect memory using page table</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">Page table for each process</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">You don’t want the page table of one program to overwrite memory of another program</span></li><li class="ql-indent-4"><span style="background-color: transparent; color: rgb(0, 0, 0);">OS kills the program if that happens</span></li><li class="ql-indent-2"><br></li></ul>
  </section>

    </section>
  </div>
</body>

</html>