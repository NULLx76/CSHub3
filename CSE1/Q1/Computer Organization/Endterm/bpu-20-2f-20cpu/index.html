<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h2>BPU / CPU</h2><ul><li><strong style="background-color: transparent; color: rgb(0, 0, 0);">RISC (see figure 5.8 in the textbook)</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">:</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Phases:</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Fetch instruction from memory</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Decode instruction and read registers</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Execute ALU (arithmetic logic unit) operation</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Memory access (if needed)</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Writeback to register (if needed)</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">These phases can run independently from each other, it is possible to fetch next instruction during the decoding of instructions (pipelining)</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Why is ALU involved with load/store instructions: we might have to compute the address we might need to fetch</span></li></ul><p><br></p><ul><li><strong style="background-color: transparent; color: rgb(0, 0, 0);">CISC (see picture on slide 26 of lecture 9):</strong></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">When writing data to memory, the memory address is moved to the: </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">MAR </strong><span style="background-color: transparent; color: rgb(0, 0, 0);">register and the </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">MDR </strong><span style="background-color: transparent; color: rgb(0, 0, 0);">register is used for the data</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Interacting with memory: it sends a </span><strong style="background-color: transparent; color: rgb(0, 0, 0);">MFC </strong><span style="background-color: transparent; color: rgb(0, 0, 0);">(memory function complete) when memory operation is done (reading / writing)</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">How to access the bus? One at a time. Other components can write to buffers though (for example Z) in the drawing</span></li></ul><p><br></p><ul><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Tri-state gates</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: Disconnect I/O electronically, if enable is 0 data won’t flow through</span></li></ul><p><br></p><ul><li class="ql-indent-1"><strong style="background-color: transparent; color: rgb(0, 0, 0);">Register file</strong><span style="background-color: transparent; color: rgb(0, 0, 0);">: 2 connections for reading and writing to registers</span></li></ul><p><br></p><ul><li><span style="background-color: transparent; color: rgb(0, 0, 0);">Improving performance:</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Duplicate components</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Pipeline parts of instructions</span></li></ul><p><br></p><ul><li><span style="background-color: transparent; color: rgb(0, 0, 0);">How does the control circuitry execute instruction stages?</span></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Signal table to look up all instruction stages</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Fixed format per opcode (RISC) and addressing mode (CISC)</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">To step through the table we use a step counter (it creates ticks / stages, e.g. T5, the write stage)</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Control signals depend on</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Instruction code (the kind of instruction are we using)</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Control step counter (the stage of the instruction are we currently in)</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Flags &amp; external signals (signals that change program behaviour)</span></li></ul><p><br></p><ul><li><strong style="background-color: transparent; color: rgb(0, 0, 0);">Hardwired control</strong></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Logic to generate control signals which decide what to execute</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">For example: writing to register file: </span><em style="background-color: transparent; color: rgb(0, 0, 0);">RF_write = T5 * (ALU + Load + Call)</em><span style="background-color: transparent; color: rgb(0, 0, 0);"> meaning that it happens in Tick 5, and with one of the following operations: ALU, Load and Call</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Counter_enable driven by WMFC</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">PLA with AND array and OR array</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">(dis)advantages</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Fast</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Inflexible</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">More complex to design</span></li></ul><p><br></p><ul><li><strong style="background-color: transparent; color: rgb(0, 0, 0);">Microprogrammed control</strong></li><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Idea:</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Execute a “program” based on contents of the instruction register</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Each “line” in this program configures gates in the BPU</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Signal table stored in ROM, which gives increased flexibility (branching)</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">One row is called a control work, micro instruction</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Whole table is called micro program instruction</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">MicroCPU inside CPU, it doesn’t have an ALU, registers etc</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">Control-store organization:</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">No / little encoding: horizontal organization</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Large words</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Less decoding</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Faster</span></li></ul><p><br></p><ul><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Much encoding: vertical organization</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Small words</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">More decoding</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Slower</span></li></ul><p><br></p><ul><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Mixed encoding</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Often used on horizontal</span></li><li class="ql-indent-3"><span style="background-color: transparent; color: rgb(0, 0, 0);">Register addresses vertical encoding</span></li></ul><p><br></p><ul><li class="ql-indent-1"><span style="background-color: transparent; color: rgb(0, 0, 0);">(dis)advantages</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Flexible</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">Slower</span></li><li class="ql-indent-2"><span style="background-color: transparent; color: rgb(0, 0, 0);">More complex to build in hardware</span></li></ul>
  </section>

    </section>
  </div>
</body>

</html>