<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h1 id="recovery">Recovery</h1><p>Recovery deals with the problems of atomicity and durability</p><ul><li>Each transaction has to be completed entirely or must not be performed at all (rollback)</li><li>Results of committed transactions need to be persistent in the database</li><li>Database systems have to be protected against transaction failures and hardware crashes</li></ul><p><br></p><p>See appendix A for the components involved in recovery. </p><p><br></p><h2 id="error-classification">Error classification</h2><ol><li>Transaction failure (abort of transaction, deadlock, error in application etc.)</li><li>System failure (data in main memory lost, crash in OS etc.)</li><li>Media failure (head crash, controller failure, data on disk destroyed etc.)</li></ol><p><br></p><h2 id="how-to-acid">How to ACID</h2><ul><li><strong>Atomicity </strong>and <strong>Durability</strong>: logging</li><li><strong>Consistency</strong>: integrity contraints</li><li><strong>Isolation</strong>: locking / time-stamping</li></ul><p><br></p><h2 id="system-concepts">System concepts</h2><p>Writing a page to the disk:</p><ul><li><strong>In-place updating</strong>: overwriting the original copy on disk with a new version</li><li><strong>Shadow paging</strong>: writing a new item at a different disk location</li></ul><p><br></p><p>When to write pages:</p><ul><li><strong>Force: </strong>always directly write/flush changes to disk after a page in the buffer was modified</li><li><strong>No-force: </strong>writes are deferred to a later time</li><li><strong>Steal-no-steal: </strong>can other transactions evict blocks when the buffer is full?</li><li class="ql-indent-1"><strong>No-steal: </strong>a page modified by a transaction cannot be written back to disk as long as the transaction is not committed</li><li class="ql-indent-1"><strong>Steal: </strong>a page modified by a transaction can be written to disk before it is committed</li></ul><p><br></p><h2 id="processing-transactions">Processing transactions</h2><ul><li>Transaction requests a database element from buffer manager</li><li>Buffer manager retrieves the element from disk if needed</li><li>Element will be fetched into local address space of transaction</li><li>New/changed element will be created inside address space if necessary</li><li>Transaction returns new element to buffer manager</li><li>Eventually: Buffer manager writes element back to disk</li></ul><p><br></p><h2 id="operations">Operations</h2><p><img src="https://i.imgur.com/WiRh9iw.png" width="547"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><p>What you see here are memory and contents of two pieces of data, you can also see how they update accordingly. </p><p><br></p><p>READ and WRITE refer to reading/writing from memory and INPUT and OUTPUT refer to R/W on disk.</p><p><br></p><h1 id="logging">Logging</h1><ul><li>Objective: Atomicity of transaction</li><li>Log = Order of "log records"</li></ul><p><br></p><ul><li>Activities of several transactions may overlap</li><li class="ql-indent-1">Hence: Do not wait for end of transaction to log</li><li class="ql-indent-1">System fault: Use Log for reconstructing a consistent state</li><li>In general</li><li class="ql-indent-1">Some transactions must be repeated (<strong>redo</strong>).</li><li class="ql-indent-1">Some transactions must be rolled back (<strong>undo</strong>).</li></ul><p><br></p><p><strong>Log file</strong>: append only, thus writing to the log is fast, as it's just appending operations to the file.</p><p><br></p><h2 id="log-records"><strong>Log records</strong></h2><div style="white-space: normal;" class="markdown-body"><ul>
<li><code>&lt;START T&gt;</code> - Transaction <code>T</code> has begun</li>
<li><code>&lt;COMMIT T&gt;</code> - Transaction <code>T</code> has completed and does not change anymore</li>
<li><code>&lt;ABORT T&gt;</code> - Transaction <code>T</code> has aborted</li>
<li><code>&lt;T, X, v&gt;</code> - Transaction <code>T</code> has changed element <code>X</code> and <code>v</code> is the old value of <code>X</code></li>
</ul>
</div><p><br></p><h2 id="undo-logging">Undo logging</h2><div style="white-space: normal;" class="markdown-body"><ul>
<li>If transaction <code>T</code> changes element <code>X</code>, <code>&lt;T, X, v&gt;</code> must have been written in the log on disk BEFORE writing new value of <code>X</code> on disc</li>
<li>If transaction <code>T</code> commits , <code>&lt;COMMIT T&gt;</code> can only be written into log after all changed elements have been written to disk.</li>
</ul>
</div><p><br></p><p>Writing to disk is carried out in the following order:</p><ol><li>Write log record for changed elements</li><li>Write elements to disk</li><li>Write COMMIT log record</li></ol><p><br></p><p><img src="https://i.imgur.com/eQtg6pF.png" width="539"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><div style="white-space: normal;" class="markdown-body"><p>Where <code>FLUSH LOG</code> writes all log blocks to disk</p>
</div><p><br></p><p><strong>Recovery using undo logging</strong></p><div style="white-space: normal;" class="markdown-body"><ul>
<li>Naive: examine complete log, check for non-committed transactions and undo the updated records in those transactions</li>
<li>Better: examine log file backwards from end to start, memorize all transactions with <code>COMMIT</code> or <code>ABORT</code>
<ul>
<li>When <code>&lt;T, X, v&gt;</code>: if a <code>COMMIT</code> or <code>ABORT</code> exists, do nothing. Else, undo this update</li>
<li>At the end, write <code>&lt;ABORT X&gt;</code> for all uncommitted transactions into log and <code>FLUSH LOG</code></li>
</ul>
</li>
</ul>
</div><p><br></p><p>If a fault occurs during recovery, rerun log from the beginning</p><p><br></p><p>See the slides (34-38) for examples</p><p><br></p><h2 id="redo-logging">Redo logging</h2><div style="white-space: normal;" class="markdown-body"><ul>
<li>Undo log: <code>COMMIT</code> is written to log when all values are on disk, incomplete transactions are rolled back</li>
<li>Redo log: <code>COMMIT</code>&nbsp;is written to log before any value is written to disk, complete transactions are repeated
<ul>
<li>Before any element <code>X</code> changed by <code>T</code> is written to disc, all log records of <code>T</code> and <code>COMMIT T</code> must be written to log</li>
<li>Redo logging writes a new value <code>v</code> to the log, instead of the old value</li>
</ul>
</li>
</ul>
</div><p><br></p><p>Writing to disk is carried out in the following order:</p><ol><li>Write log record for changed elements</li><li>Write COMMIT log record</li><li>Write elements to disk</li></ol><p><br></p><p><img src="https://i.imgur.com/v312Cjc.png" width="548"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><p><strong>Recovery using redo logging</strong></p><div style="white-space: normal;" class="markdown-body"><ul>
<li>Identify committed transactions</li>
<li>Read log data from the beginning to the end (chronological), for each update record <code>&lt;T, X, v&gt;</code>, if committed, write <code>v</code> to disk (redo)</li>
<li>For each uncommitted transaction write <code>&lt;ABORT T&gt;</code> into log</li>
<li>Flush log</li>
</ul>
</div><p><br></p><p>See the slides (50-52) for examples</p><p><br></p><h2 id="undo/redo-logging">Undo/redo logging</h2><div style="white-space: normal;" class="markdown-body"><ul>
<li>Disadvantage undo: Data must be written immediately after end of transaction</li>
<li>Disadvantage redo: All changed blocks must be retained in buffer till <code>COMMIT</code> and log records are on disc</li>
<li>Undo/redo log: Updated record <code>&lt;T, X, v, w&gt;</code> (it has old and new value) must have been written on disc before <code>X</code> changed by <code>T</code> has been written on disc
<ul>
<li><code>&lt;COMMIT T&gt;</code> can be written on disc before and after <code>OUTPUT</code> of elements to disk</li>
</ul>
</li>
</ul>
</div><p><br></p><p><strong>Recovery using undo/redo logging</strong></p><p>Log allows redo and undo through storage of new and old value</p><ul><li>Redo of all committed transactions in a chronological order</li><li>Undo of all uncommitted transactions in a reverse chronological order</li></ul><p><br></p><p>Both are important: Extreme cases</p><ul><li>Committed transaction with no change on disc</li><li>Uncommitted transaction with all changes on disc</li></ul><p><br></p><p>See the slides (65-66) for examples</p><p><br></p><h2 id="comparison">Comparison</h2><ul><li>Undo Logging</li><li class="ql-indent-1">Stores old values</li><li class="ql-indent-1">Order:</li></ul><ol><li class="ql-indent-2">Log record on disc</li><li class="ql-indent-2">New value on disc</li><li class="ql-indent-2">Commit log on disc</li></ol><ul><li class="ql-indent-1">Recovery through restoring old values for uncommitted transactions</li><li>Redo logging</li><li class="ql-indent-1">Stores new values</li><li class="ql-indent-1">Order:</li></ul><ol><li class="ql-indent-2">Log record on disc</li><li class="ql-indent-2">Commit log on disc</li><li class="ql-indent-2">New value on disc</li></ol><ul><li class="ql-indent-1">Recovery through writing new values of all committed transactions</li><li>Undo/redo Logging</li><li class="ql-indent-1">Stores old and new values</li><li class="ql-indent-1">Order:</li></ul><ol><li class="ql-indent-2">Log record on disc</li><li class="ql-indent-2">New value on disc</li></ol><ul><li class="ql-indent-1">Commit log whenever</li></ul><p><br></p><h1 id="distributed-transactions">Distributed transactions</h1><p>Read more on this <a href="https://cshub.nl/post/487433115" target="_blank">here</a></p><p><br></p><h2 id="two-phase-commit-(2pc)">Two Phase Commit (2PC)</h2><p><strong>Two Roles:</strong></p><ul><li>One coordinator.</li><li> <span class="ql-formula" data-value="n">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>﻿</span> workers (Cohorts)</li></ul><p><br></p><p><strong>Assumptions</strong>:</p><ul><li>Write-ahead log at each node</li><li>No node crashes forever.</li><li>Any two nodes can communicate.</li></ul><p><br></p><p><strong>Commit phase</strong></p><ol><li>System receives user request.</li><li>Coordinator sends "<strong>Prepare commit</strong>" message to all workers.</li><li>Workers process request and write pending changes to log.</li><li class="ql-indent-1">If <strong>successful</strong>, worker answers "ready". All workers answered "ready":</li><li class="ql-indent-2">Coordinator sends “commit” to all workers.</li><li class="ql-indent-2">Workers <strong>commit pending</strong> changes from log. Send "ack" to coordinator.</li><li class="ql-indent-2">Coordinator <strong>completes transaction</strong>, once all workers finished.</li><li class="ql-indent-1">In <strong>case of errors</strong>, worker answers "failure". At least one answered "failure":</li><li class="ql-indent-2">Coordinator sends "rollback" to all workers.</li><li class="ql-indent-2">Workers <strong>undo pending</strong> changes from log. Send "ack" to coordinator.</li><li class="ql-indent-2">Coordinator <strong>undoes transaction</strong>, once all workers finished.</li></ol><p><br></p><p><strong>Failure recovery</strong></p><ul><li>Failure occurs in <strong>Phase 1</strong>:</li><li class="ql-indent-1">Directly after receiving "<strong>prepare</strong>" from coordinator: transaction either timed out (failed) or coordinator is still waiting. <strong>Make local decision</strong> and <strong>check with</strong> coordinator.</li><li class="ql-indent-1">After sending "<strong>failure</strong>" to coordinator: the transaction has failed. <strong>Undo </strong>from log.</li><li class="ql-indent-1">After sending "<strong>ready</strong>" to coordinator: the transaction might have succeeded. <strong>Check back</strong> with coordinator or neighboring nodes.</li><li>Failure occurs in <strong>Phase 2</strong>: undo transaction from log</li></ul><p><br></p><h1 id="appendix">Appendix</h1><h2 id="a">A</h2><p><img src="https://i.imgur.com/qzafaHE.png" width="569"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p>
  </section>

    </section>
  </div>
</body>

</html>