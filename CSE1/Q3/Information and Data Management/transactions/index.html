<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>MyBlog</title>
  <link rel="stylesheet" href="https://nullx76.github.io/CSHub3/main.css">
</head>

<body>
  <div class="container">
    <head>
      <h1><a href="/">CSHub.nl</a></h1>
    </head>
    <section class="section">
      
  <section class="page">
  <h1 id="transactions">Transactions</h1><p>Read a basis on transactions and its properties <a href="https://cshub.nl/post/487433115" target="_blank">here</a>. </p><p><br></p><p><strong>Transaction processing</strong></p><p>Processing transactions well is important as data accesses that are performed <strong>concurrently</strong> can potentially lead to database problems</p><p><br></p><p>Some operations in workflows are <strong>intertwined, </strong>meaning that you might write first and then need to read the updated data, not before it's been written</p><p><br></p><p><strong>Transaction manager</strong></p><p>The transaction manager gets a set of transactions from user/applications, derives a correct transaction schedule and caters for recovery.</p><p><br></p><h2 id="transaction">Transaction</h2><p>A transaction is a finite set of operations (workflow, program) that has to be performed in a certain order, while ensuring certain properties:</p><ul><li><strong>Integrity: </strong>transactions can always be executed safely, in concurrent manner, while ensuring data integrity</li><li><strong>Fail safety: </strong>transactions are immune to system failures</li></ul><p><br></p><p>Applications should not worry about integrity and protection issues, the DBMS should do this. </p><p><br></p><p>Transactions are an <strong>interface contract </strong>of an transaction-enabled server:</p><ul><li><strong>Start</strong>: Starts a transaction followed by a finite amount of operations</li><li><strong>Commit</strong>: Executes all operations and ends the transaction</li><li><strong>Rollback</strong>: Cancel current transaction and revert all effects of the transaction</li></ul><p><br></p><h2 id="page-model">Page model</h2><p>Each operation accesses the complete database page with the changed record(s) on it. Each read and write operation is considered indivisible.</p><p><br></p><p><strong>Definition: </strong>A transaction is a totally-ordered finite sequence of actions of the form <span class="ql-formula" data-value="r\left(x\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">r\left(x\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">r</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">x</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> or <span class="ql-formula" data-value="w\left(x\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">w\left(x\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">x</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> where <span class="ql-formula" data-value="x">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>﻿</span> is some record from the database instance</p><ul><li><span class="ql-formula" data-value="r\left(x\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">r\left(x\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">r</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">x</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> is read</li><li><span class="ql-formula" data-value="w\left(x\right)">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">w\left(x\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span class="mspace" style="margin-right: 0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;">(</span><span class="mord mathdefault">x</span><span class="mclose delimcenter" style="top: 0em;">)</span></span></span></span></span></span>﻿</span> is write</li></ul><p><br></p><div style="white-space: normal;" class="markdown-body"><p>Transaction example: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo><mi mathvariant="normal">≔</mi></mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>r</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>r</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T\coloneqq r(x)\ r(y)\ r(z)\ w(u)\ w(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mop" style="position:relative;top:-0.03472em;">:</span></span><span class="mrel"><span class="mspace" style="margin-right:-0.06666666666666667em;"></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
</div><p><br></p><h2 id="schedules">Schedules</h2><p>For a set of <strong>concurrently executed transactions</strong></p><ul><li>A complete <strong>schedule </strong>is a sequence of operations that contains all the operations of the involved transactions and respects the order of operations within a single transaction</li><li>A <strong>serial schedule </strong>consists of any permutation of the transactions, where each transaction is <strong>fully executed </strong>before the next one starts (costs a lot of performance)</li><li>An <strong>intertwined schedule </strong>consists of any permutation of the operations within the transactions, the transactions are executed disorderly</li><li>Complete schedules are often distinguished from <strong>general schedules</strong>, where some transactions may still be active</li></ul><p><br></p><p><strong>Schedule equivalence: </strong>Two schedules are <strong>equivalent </strong>if</p><ul><li>They comprise of the <strong>same set of operations</strong></li><li>Every transaction in both schedules reads the same values</li><li>Eventually, every transaction in both schedule writes the same values to a given record</li></ul><p><br></p><p><strong>Serializable schedule: </strong>A complete schedule is called <strong>serializable</strong>, if it is equivalent to any serial schedule of the respective set of transactions but allows for <strong>concurrent execution</strong></p><p><br></p><p><strong>Consistency by careful scheduling</strong></p><ul><li>Restricting the system to serializable schedules will lead to consistent concurrency control</li><li>Testing for serializability is not computationally feasible</li></ul><p><br></p><p><strong>Conflicting operations: </strong>Two operations in a schedule are conflicting, if</p><ul><li>They belong to different transactions</li><li>They access the same database record (or page)</li><li>And at least one of them writes data</li></ul><p><br></p><p>All pairs of conflicting operations are called the <strong>conflict relation</strong> of a schedule</p><p><br></p><p><strong>Conflict equivalent: </strong>If a schedule <span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span> can be transformed into a schedule <span class="ql-formula" data-value="S'">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">S&amp;#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> by a series of swaps of non-conflicting instructions, we say that <span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span> and <span class="ql-formula" data-value="S'">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">S&amp;#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>﻿</span> are conflict equivalent.</p><p><br></p><p><strong>Conflict graph</strong></p><ul><li>To test for conflict equivalence, construct a <strong>conflict graph (</strong>transactions as nodes, conflicts as edges)</li><li>Two schedules are <strong>conflict equivalent </strong>iff their conflict graphs are <strong>identical</strong></li><li>If there is an edge between two transactions there is at least one conflict between them</li><li>The direction of each edge respects the ordering of the conflicting steps, for an example, see <em>appendix A</em></li><li>If a conflict graph contains cycles, it's a <strong>non-conflict serializable schedule</strong></li><li>An advantage of using a graph and topologically sorting it to find <strong>conflict serializable </strong>schedules is that it can be done in polynomial time</li></ul><p><br></p><p><strong>Conflict serializable</strong></p><ul><li>A schedule <span class="ql-formula" data-value="S">﻿<span contenteditable="false"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span></span></span></span></span>﻿</span> is conflict serializable if it is conflict equivalent to a serial schedule. For examples on this, see <em>appendix B</em> and the slides from slide 40 to 45.</li><li>Conflict serializability is a good correctness criterion for complete schedules, but it does not consider commits/rollbacks of transactions</li></ul><p><br></p><p><strong>Subsets</strong></p><ul><li><strong>Serial </strong>schedules are a proper subset of <strong>serializable schedules</strong> (there are more serializable schedules than serial schedules)</li><li><strong>Conflict serializable</strong> schedules are a proper subset of all serializable schedules and <strong>serial schedules </strong>are a proper subset of <strong>conflict serializable </strong>schedules:</li></ul><p><img src="https://i.imgur.com/uVvodIY.png" width="282"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><h2 id="schedulers">Schedulers</h2><p>Schedulers are an integral part of every transaction manager. They:</p><ul><li>Keep lists of active, committed and aborted transactions</li><li>Accepts new transactions</li><li>Basic operations are handed on to the scheduler to build a consistent schedule of operations for the storage manager</li><li>Can autonomously decide to abort transactions, whenever a non-serializable situation is detected</li></ul><p><br></p><p><strong>How do we use a scheduler?</strong></p><p>We just let transactions run, if we see a transaction is not serialized, we just kill it and restart it later</p><p><br></p><p><strong>Locking schedulers</strong></p><p>The largest class of practical schedulers are locking schedulers</p><ul><li>Locks can be <strong>set on</strong> and <strong>removed from</strong> data items on behalf of transactions</li><li>Once a lock has been set on behalf of a transaction, the respective item is <strong>not available</strong> to other transactions</li></ul><p><br></p><p><strong>Lock conflicts</strong></p><p>If a lock is requested by some transaction, the scheduler checks whether it has already been issued to another transactions</p><p><br></p><p>Then it locks the record (if it was not locked) or waits (if it was locked) and in the end it will release the lock</p><p><br></p><p><strong>Locking rules</strong></p><ul><li>All data items are locked before a respective data access is performed</li><li>All locks are released at some point after the data accesses have been performed (items are unlocked)</li><li>No unnecessary locks are acquired</li></ul><p><br></p><p><strong>Lock conversion</strong></p><ul><li>Read locks can be <strong>shared </strong>by several transactions</li><li>Write locks are <strong>exclusive </strong>locks</li></ul><p><br></p><p><strong>Two-phase locking protocol</strong></p><ul><li>Locks are granted in a <strong>growing phase</strong> (lock phase)</li><li>Locks are released in a <strong>shrinking phase </strong>(unlock phase)</li><li>So for each transaction all necessary locks are acquired before the first lock is released.</li><li>In two-phase locking, data is usually only written physically to the database during shrinking</li><li><strong>2-Phase-Locking</strong> schedules are a proper subset of <strong>conflict serializable </strong>schedules</li></ul><p><br></p><p><img src="https://i.imgur.com/iyTUjGs.png" width="421"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><p><strong>Deadlocks</strong></p><ul><li>A deadlock happens when transactions mutually wait to obtain locks from each other</li><li>Dealing with deadlocks</li><li class="ql-indent-1"><strong>Ignore: </strong>easiest, but may stop the system</li><li class="ql-indent-1"><strong>Deadlock Detection: </strong>allow deadlocks, detect them, and then resolve them</li><li class="ql-indent-1"><strong>Deadlock Prevention: </strong>prevent that deadlocks can happen. Ensure that at least one of the 4 criteria is not fulfilled</li><li class="ql-indent-1"><strong>Deadlock Avoidance: </strong>prevent that deadlocks can happen. Use additional information about the request to dynamically prevent unsafe situations</li></ul><p><br></p><h1 id="appendix">Appendix</h1><h2 id="a">A</h2><p><img src="https://i.imgur.com/XtYla77.png" width="405"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><h2 id="b">B</h2><p><img src="https://i.imgur.com/SyEAMle.png" width="553"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p><p><br></p><p><img src="https://i.imgur.com/pSoWX3O.png" width="440"></p><p><em>Image taken from slides by C. Lofi and A. Katsifodimos</em></p>
  </section>

    </section>
  </div>
</body>

</html>